#!/usr/bin/env python3


import struct


mem = bytearray(0x1000000)
# hell, let's just wire the registers into memory
regs = 0xF00000
pc = 0x1000
x = n = z = v = c = 0

# test program: infinite loop
struct.pack_into('>L', mem, regs + 15*4, regs) # stack under regs
mem[pc:pc+4] = b'\x61\x00\xff\xfe'

def sign_extend(n, width):
    signbit = 1 << (width - 1)
    if n & (1 << (width - 1)): n -= (1 << width)
    return n

def address_by_mode(mode, width): # mode given by bottom 6 bits
    # side effects: predecrement/postincrement, advance pc to get extension word
    global pc

    if mode >> 3 == 0: # Dn
        ptr = regs + (mode & 7) * 4 + 4 - width
    elif mode >> 3 == 1: # An
        ptr = regs + (mode & 7) * 4 + 32 + 4 - width
    elif mode >> 3 == 2: # (An)
        regptr = regs + (mode & 7) * 4 + 32
        ptr = struct.unpack_from('>L', mem, regptr)[0]
    elif mode >> 3 == 3: # (An)+
        regptr = regs + (mode & 7) * 4 + 32
        newptr = ptr = struct.unpack_from('>L', mem, regptr)[0]
        newptr += width
        if mode & 7 == 7 and width == 1: newptr += 1
        struct.pack_into('>L', mem, regptr, newptr)
    elif mode >> 3 == 4: # -(An)
        regptr = regs + (mode & 7) * 4 + 32
        ptr = struct.unpack_from('>L', mem, regptr)[0]
        ptr -= width
        if mode & 7 == 7 and width == 1: ptr -= 1
        struct.pack_into('>L', mem, regptr, ptr)
    elif mode >> 3 == 5: # d16(An)
        ptr = regs + (mode & 7) * 4 + 32
        ptr = struct.unpack_from('>L', mem, ptr)[0]
        ptr += struct.unpack_from('>h', mem, pc)[0]; pc += 2
    elif mode >> 3 == 6: # d8(An,Xn)
        ptr = regs + (mode & 7) * 4 + 32
        ptr = struct.unpack_from('>L', mem, ptr)[0]
        #
        xreg, xofs = struct.unpack_from('>Bb', mem, pc); pc += 2
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = struct.unpack('>l', mem, whichreg)
        else: rofs = struct.unpack('>h', mem, whichreg + 2)
        ptr += xofs + rofs
    elif mode == 58: # d16(PC)
        ptr = pc + struct.unpack_from('>h', mem, pc)[0]; pc += 2
    elif mode == 59: # d8(PC,Xn)
        ptr = pc
        xreg, xofs = struct.unpack_from('>Bb', mem, pc); pc += 2
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = struct.unpack('>l', mem, whichreg)
        else: rofs = struct.unpack('>h', mem, whichreg + 2)
        ptr += xofs + rofs
    elif mode == 56: # abs.W
        ptr = struct.unpack_from('>H', mem, pc)[0]; pc += 2
    elif mode == 57: # abs.L
        ptr = struct.unpack_from('>L', mem, pc)[0]; pc += 4
    elif mode == 60: # #imm
        if width == 1:
            ptr = pc + 1; pc += 2
        elif width == 2:
            ptr = pc; pc += 2
        elif width == 4:
            ptr = pc; pc += 4

    return ptr


def test_condition(cond):
    if cond == 0: # T true
        return True
    elif cond == 1: # F false
        return False
    elif cond == 2: # HI higher than
        return not (c or z)
    elif cond == 3: # LS lower or same
        return c or z
    elif cond == 4: # CC carry clear aka HS
        return not c
    elif cond == 5: # CS carry set aka LS
        return c
    elif cond == 6: # NE not equal
        return not z
    elif cond == 7: # EQ equal
        return z
    elif cond == 8: # VC overflow clear
        return not v
    elif cond == 9: # VS overflow set
        return not v
    elif cond == 10: # PL plus
        return not n
    elif cond == 11: # MI minus
        return n
    elif cond == 12: # GE greater or equal
        return n == v
    elif cond == 13: # LT less than
        return not (n == v)
    elif cond == 14: # GT greater than
        return n == v and not z
    elif cond == 15: # LE less than
        return n != v or z




def push(data):
    ptr = address_by_mode(39, len(data)) # -(A7)
    mem[ptr:ptr+len(data)] = data

def pop(nbytes):
    ptr = address_by_mode(31, nbytes) # (A7)+
    return mem[ptr:ptr+nbytes]


def line0123(inst):
    pass
def line4(inst):
    pass

def line5(inst): # addq,subq,scc,dbcc
    pass

def line6(inst): # bra,bsr,bcc
    global pc

    disp = sign_extend(inst & 255, 8)
    if disp == 0: # word displacement
        disp = struct.unpack_from('>h', mem, pc)[0]; pc += 2

    cond = (inst >> 8) & 15
    if cond > 1 and not test_condition(cond): return # not taken

    if cond == 1: # is bsr
        push(struct.pack('>L', pc))

    pc += disp - 2

def line7(inst): # moveq
    global n, z, v, c
    dn = (inst >> 9) & 7
    val = sign_extend(inst & 255, 8)
    n = (val < 0); z = (val == 0); v = c = 0
    struct.pack_into('>l', mem, regs + dn * 4, val)

def line8(inst):
    pass
def line9(inst):
    pass
def lineA(inst): # macintosh os/toolbox
    pass
def lineB(inst):
    pass
def lineC(inst):
    pass
def lineD(inst):
    pass
def lineE(inst):
    pass
def lineF(inst):
    pass


instruction_lines = (line0123, line0123, line0123, line0123, line4, line5, line6, line7,
    line8, line9, lineA, lineB, lineC, lineD, lineE, lineF)

while 1:
    inst = struct.unpack_from('>H', mem, pc)[0]; pc += 2
    instruction_lines[inst >> 12](inst)
    # that's it!




# implement:
# add
# adda
# addi
# addq
# addx
# and
# andi
# andi to ccr
# andi to sr
# asl,asr
# bcc
# bchg
# bclr
# bra
# bset
# bsr
# btst
# chk
# clr
# cmp
# cmpa
# cmpi
# cmpm
# dbcc
# divs,divu
# eor
# eori
# eori to ccr
# eori to sr
# exg
# ext
# jmp
# jsr
# lea
# link
# lsl,lsr
# move
# movea
# move to ccr
# move from sr
# move to sr
# movem
# moveq
# muls,mulu
# neg
# negx
# nop
# not
# or
# ori
# ori to ccr
# ori to sr
# pea
# rol,ror
# roxl,roxr
# rtr
# rts
# scc
# sub
# suba
# subi
# subq
# subx
# swap
# tas
# tst
# unlk
