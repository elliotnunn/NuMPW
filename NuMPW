#!/usr/bin/env python3

########################################################################
# 68000 interpreter: minimal user-mode implementation
#
# Notes:
# - all "sizes" are in bytes
# - define read(), write() and lineA() somewhere outside this block
########################################################################

# Emulator state: set to something better than this before running
regs = 0
pc = 0
x = n = z = v = c = 0

def push(size, data):
    ptr = address_by_mode(39, size) # -(A7)
    write(size, ptr, data)

def pop(size):
    ptr = address_by_mode(31, size) # (A7)+
    return read(size, ptr)

def sign_extend(n, size):
    bitsize = size * 8
    n &= (1 << bitsize) - 1 # clip to size
    signbit = 1 << (bitsize - 1)
    if n & (1 << (bitsize - 1)): n -= (1 << bitsize)
    return n

def add_then_set_vc(a, b, size):
    global v, c
    bitsize = size * 8
    signbit = 1 << (bitsize - 1)
    mask = (1 << bitsize) - 1
    a &= mask
    b &= mask
    result = (a + b) & mask
    v = (a & signbit) == (b & signbit) != (result & signbit)
    c = result < a # could use result < b just as easily
    return result

def sub_then_set_vc(a, b, size): # subtract b from a
    global v, c
    bitsize = size * 8
    signbit = 1 << (bitsize - 1)
    mask = (1 << bitsize) - 1
    a &= mask
    b &= mask
    result = (a - b) & mask
    v = (a & signbit) != (b & signbit) == (result & signbit)
    c = a < b
    return result

def set_nz(num, size):
    global n, z
    bitsize = size * 8
    n = bool(num & (1 << (bitsize - 1)))
    z = (num == 0)

def get_ccr():
    return (x << 4) | (n << 3) | (z << 2) | (v << 1) | c

def set_ccr(to_byte):
    global x, n, z, v, c
    x = bool(to_byte & 16)
    n = bool(to_byte & 8)
    z = bool(to_byte & 4)
    v = bool(to_byte & 2)
    c = bool(to_byte & 1)

def address_by_mode(mode, size): # mode given by bottom 6 bits
    # side effects: predecrement/postincrement, advance pc to get extension word
    global pc

    if mode >> 3 == 0: # Dn
        ptr = regs + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 1: # An
        ptr = regs + 32 + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 2: # (An)
        ptr = read(4, regs + 32 + (mode & 7) * 4)
    elif mode >> 3 == 3: # (An)+
        regptr = regs + 32 + (mode & 7) * 4
        newptr = ptr = read(4, regptr)
        newptr += size
        if mode & 7 == 7 and size == 1: newptr += 1
        write(4, regptr, newptr)
    elif mode >> 3 == 4: # -(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, regptr)
        ptr -= size
        if mode & 7 == 7 and size == 1: ptr -= 1
        write(4, regptr, ptr)
    elif mode >> 3 == 5: # d16(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = (read(4, regptr) + read(2, pc, signed=True)); pc += 2
    elif mode >> 3 == 6: # d8(An,Xn)
        ptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, ptr) # get An
        #
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 58: # d16(PC)
        ptr = pc + read(2, pc, signed=True); pc += 2
    elif mode == 59: # d8(PC,Xn)
        ptr = pc
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 56: # abs.W
        ptr = read(2, pc); pc += 2
    elif mode == 57: # abs.L
        ptr = read(4, pc); pc += 4
    elif mode == 60: # #imm
        if size == 1:
            ptr = pc + 1; pc += 2
        elif size == 2:
            ptr = pc; pc += 2
        elif size == 4:
            ptr = pc; pc += 4
    else:
        raise ValueError(mode)

    return ptr

def test_condition(cond):
    if cond == 0: # T true
        return True
    elif cond == 1: # F false
        return False
    elif cond == 2: # HI higher than
        return not (c or z)
    elif cond == 3: # LS lower or same
        return c or z
    elif cond == 4: # CC carry clear aka HS
        return not c
    elif cond == 5: # CS carry set aka LS
        return c
    elif cond == 6: # NE not equal
        return not z
    elif cond == 7: # EQ equal
        return z
    elif cond == 8: # VC overflow clear
        return not v
    elif cond == 9: # VS overflow set
        return v
    elif cond == 10: # PL plus
        return not n
    elif cond == 11: # MI minus
        return n
    elif cond == 12: # GE greater or equal
        return n == v
    elif cond == 13: # LT less than
        return not (n == v)
    elif cond == 14: # GT greater than
        return n == v and not z
    elif cond == 15: # LE less or equal
        return n != v or z

def line0(inst):
    global pc, x, n, z, v, c
    if inst & 256 or inst >> 9 == 4: # btst,bchg,bclr,bset (or movep)
        if inst & 256: # bit numbered by data register
            if (inst >> 3) & 7 == 1: 1/0 # MOVEP instruction :(
            dn = inst >> 9
            bit = read(4, regs + dn * 4)
        else: # bit numbered by immediate
            bit = read(2, pc); pc += 2

        mode = inst & 63
        if mode >> 3 <= 1: size = 4 # applies to register
        else: size = 1 # applies to memory address

        bit %= size * 8
        mask = 1 << bit

        ptr = address_by_mode(mode, size)
        val = read(size, ptr)
        z = not (val & mask)

        if (inst >> 6) & 3 == 1: # bchg
            val ^= mask
        elif (inst >> 6) & 3 == 2: # bclr
            val &= ~mask
        elif (inst >> 6) & 3 == 3: # bset
            val |= mask
        # ^^ the btst case is already handled by setting z

        write(size, ptr, val)

    else: #ori,andi,subi,addi,eori -- including to SR/CCR
        size = (1,2,4,None)[(inst >> 6) & 3] or 1/0 # illegal %11 size!
        src_ptr = address_by_mode(60, size) # '#imm' mode, advances pc
        imm = read(size, src_ptr)

        # now, are we operating on a special mode?
        dest_mode = inst & 63
        if dest_mode == 60: # '#imm' actually means CCR/SR
            # for addi/subi this would simply be invalid
            val = get_ccr()
        else:
            dest_ptr = address_by_mode(dest_mode, size)
            val = read(size, dest_ptr)

        if inst >> 9 == 0: # ori
            val |= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 1: # andi
            val &= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 2: # subi
            val = sub_then_set_vc(val, imm, size)
            x = c
            set_nz(val, size)
        elif inst >> 9 == 3: # addi
            val = add_then_set_vc(val, imm, size)
            x = c
            set_nz(val, size)
        elif inst >> 9 == 5: # eori
            val ^= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 6: # cmpi: same as subi, but don't set
            fake_val = sub_then_set_vc(val, imm, size)
            set_nz(fake_val, size)

        if dest_mode == 60:
            set_ccr(val)
        else:
            write(size, dest_ptr, val)

def line123(inst): # move, and movea which is a special-ish case
    global v, c
    size = (None, 1, 4, 2)[(inst >> 12) & 3] or 1/0
    dest_mode = ((inst >> 3) & 0x38) | ((inst >> 9) & 7)
    src_mode = inst & 63

    src = address_by_mode(src_mode, size)
    datum = read(size, src, signed=True)

    if dest_mode >> 3 == 1: # movea: sign extend to 32 bits
        size = 4
    else: # non-movea: set condition codes
        v = c = 0
        set_nz(datum, size)

    dest = address_by_mode(dest_mode, size)
    write(size, dest, datum)

def line4(inst): # very,crowded,line
    global pc, x, n, z, v, c
    if (inst >> 6) & 63 == 3: # move from sr
        dest = address_by_mode(inst & 63, 2) # sr is 2 bytes
        write(2, dest, get_ccr())
    elif (inst >> 6) & 63 in (19, 27): # move to sr/ccr
        size = 1 if (inst >> 6) & 63 == 19 else 2 # ccr or sr?
        src = address_by_mode(inst & 63, size)
        set_ccr(read(size, src))
    elif (inst >> 8) & 15 in (0, 4, 6): # negx,neg,not
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)

        if (inst >> 8) & 15 == 0: # negx
            datum = sub_then_set_vc(0, datum+x, size)
            x = c
            set_nz(datum, size)
        elif (inst >> 8) & 15 == 4: # neg
            datum = sub_then_set_vc(0, datum, size)
            x = c
            set_nz(datum, size)
        else: # not
            datum = ~datum
            v = c = False
            set_nz(datum, size)

        write(size, dest, datum)

    elif (inst >> 8) & 15 == 2: # clr
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dest = address_by_mode(inst & 63, size)

        n = False
        z = True
        v = False
        c = False

        write(size, dest, 0)

    elif inst & 0xFB8 == 0x880: # ext
        size = 4 if inst & 64 else 2
        dn = inst & 7
        src = regs + dn * 4 + 4 - size//2
        dest = regs + dn * 4 + 4 - size
        datum = read(size//2, src, signed=True)
        set_nz(datum, size)
        v = c = False
        write(size, dest, datum)

    elif inst & 0xFF8 == 0x840: # swap.w
        dn = inst & 7
        dest = regs + dn * 4
        datum = read(4, dest)
        datum = ((datum >> 16) & 0xFFFF) | ((datum & 0xFFFF) << 16)
        set_nz(datum, 4)
        v = c = False
        write(4, dest, datum)

    elif inst & 0xFC0 == 0x840: # pea -- notice similarity to swap.w
        ea = address_by_mode(inst & 63, 4) # size doesn't matter here
        push(4, ea)

    elif inst & 0xF00 == 0xA00: # tst,tas
        size, is_tas = ((1,0), (2,0), (4,0), (1,1))[(inst >> 6) & 3]
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        set_nz(datum, size)
        v = c = False
        if is_tas: write(1, dest, datum | 0x80)

    elif inst & 0xFF8 == 0xE50: # link
        an = inst & 7; an_ea = regs + 32 + an * 4
        imm = read(2, pc, signed=True); pc += 2

        push(4, read(4, an_ea)) # move.l a6,-(sp)
        sp = read(4, regs+60)
        write(4, an_ea, sp) # move.l sp,a6
        write(4, regs+60, sp + imm) # add.w #imm,sp

    elif inst & 0xFF8 == 0xE58: # unlk
        an = inst & 7; an_ea = regs + 32 + an * 4

        write(4, regs+60, read(4, an_ea)) # move.l a6,sp
        write(4, an_ea, pop(4)) # move.l (sp)+,a6

    elif inst & 0xFFF == 0xE71: # nop
        pass

    elif inst & 0xFFF == 0xE75: # rts
        pc = pop(4)

    elif inst & 0xFFF == 0xE77: # rtr
        set_ccr(pop(2))
        pc = pop(4)

    elif inst & 0xF80 == 0xE80: # jsr/jmp
        targ = address_by_mode(inst & 63, 4) # any size
        if not inst & 0x40:
            push(4, pc)
        pc = targ

    elif inst & 0xB80 == 0x880: # movem
        size = 4 if inst & 64 else 2
        dir_to_reg = bool(inst & 0x400)
        which = read(2, pc); pc += 2

        if dir_to_reg: which = [r for r in range(16) if which & (1 << r)]
        else: which = [r for r in range(16) if which & (0x8000 >> r)]

        ptr = address_by_mode(inst & 63, len(which) * size)

        for reg in which:
            if dir_to_reg:
                datum = read(size, ptr, signed=True); ptr += size
                write(4, regs+reg*4, datum)
            else:
                datum = read(size, regs + reg * 4 + 4 - size)
                write(size, ptr, datum); ptr += size

    elif inst & 0x1C0 == 0x1C0: # lea
        an = (inst >> 9) & 7
        ea = address_by_mode(inst & 63, 4) # any size
        write(4, regs + 32 + an * 4, ea)

    elif inst & 0x1C0 == 0x180: # chk
        dn = (inst >> 9) & 7
        testee = read(2, regs + 4 * dn + 2, signed=True)
        ea = address_by_mode(inst & 63, 2)
        ubound = read(2, ea, signed=True)
        if not 0 <= testee <= ubound: raise ValueError('chk failed') # raise exception

def line5(inst): # addq,subq,scc,dbcc
    global pc, x, n, z, v, c
    if (inst >> 6) & 3 != 3: # addq,subq
        size = 1 << ((inst >> 6) & 3)
        if size == 2 and (inst >> 3) & 7 == 1: size = 4 # An.w is really An.l

        imm = ((inst >> 9) & 7) or 8

        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        save_ccr = x, n, z, v, c
        if inst & 256: # subq
            datum = sub_then_set_vc(datum, imm, size)
        else: # addq
            datum = add_then_set_vc(datum, imm, size)
        x = c
        set_nz(datum, size)
        if (inst >> 3) & 7 == 1: x, n, z, v, c = save_ccr # touch not ccr if dest is An
        write(size, dest, datum)

    elif (inst >> 3) & 7 == 1: # dbcc
        disp = read(2, pc, signed=True) - 2; pc += 2

        cond = (inst >> 8) & 15 # if cond satisfied then DO NOT take loop
        if test_condition(cond): return

        # decrement the counter (dn)
        dn = inst & 7
        dest = regs + dn * 4 + 2
        counter = (read(2, dest) - 1) & 0xFFFF
        write(2, dest, counter)
        if counter == 0xFFFF: return # do not take the branch

        pc += disp

    else: # scc
        dest = address_by_mode(inst & 63, 1)
        cond = (inst >> 8) & 15
        write(1, dest, 0xFF * test_condition(cond))

def line6(inst): # bra,bsr,bcc
    global pc
    disp = sign_extend(inst & 255, 1)
    if disp == 0: # word displacement
        disp = read(2, pc, signed=True) - 2; pc += 2

    cond = (inst >> 8) & 15
    if cond > 1 and not test_condition(cond): return # not taken

    if cond == 1: # is bsr
        push(4, pc)

    pc += disp

def line7(inst): # moveq
    global n, z, v, c
    dn = (inst >> 9) & 7
    val = sign_extend(inst & 255, 1)
    n = (val < 0); z = (val == 0); v = c = 0
    write(4, regs + dn * 4, val)

def line8(inst): # divu,divs,sbcd,or
    global n, z, v, c
    if inst & 0x1F0 == 0x100: # sbcd
        1/0
    elif inst & 0x0C0 == 0x0C0: # divu,divs
        signed = bool(inst & 0x100)
        ea = address_by_mode(inst & 63, 2)
        divisor = read(2, ea, signed)
        if divisor == 0: 1/0 # div0 error
        dn = (inst >> 9) & 7
        dividend = read(4, regs + dn * 4, signed)

        # remainder is 0 or has same sign as dividend
        quotient = abs(dividend) // abs(divisor)
        if dividend < 0: quotient = -quotient
        if divisor < 0: quotient = -quotient
        remainder = abs(dividend) % abs(divisor)
        if dividend < 0: remainder = -remainder

        if signed and not (-0x8000 <= quotient < 0x7FFF):
            v = True
            return

        if not signed and quotient > 0xFFFF:
            v = True
            return

        v = False
        set_nz(quotient, 2)

        write(4, regs + dn * 4, ((remainder & 0xFFFF) << 16) | (quotient & 0xFFFF))

    else: # or
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src

        datum = read(size, src) | read(size, dest)
        write(size, dest, datum)
        set_nz(datum, size)
        v = c = False

def line9D(inst): # sub,subx,suba//add,addx,adda: very compactly encoded
    global x, n, z, v, c
    sign = 1 if inst & 0x4000 else -1
    if inst & 0x0C0 == 0x0C0: # suba,adda
        size = 4 if inst & 0x100 else 2
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = read(4, regs + 32 + an * 4, signed=True) + sign * read(size, ea, signed=True)
        write(4, regs + 32 + an * 4, result)

    elif inst & 0x130 == 0x100: # subx,addx: only two addressing modes allowed
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        mode = 32 if inst & 8 else 0 # either -(Ax),-(Ay) or Dx,Dy
        src = address_by_mode(mode | (inst & 7), size)
        dest = address_by_mode(mode | ((inst >> 9) & 7), size)

        if sign == 1:
            result = add_then_set_vc(read(size, dest), read(size, src) + x, size)
        else:
            result = sub_then_set_vc(read(size, dest), read(size, src) + x, size)
        write(size, dest, result)
        x = c
        old_z = z; set_nz(result, size); z &= old_z

    else: # sub,add
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src # direction bit does a swap
        if sign == 1:
            result = add_then_set_vc(read(size, dest), read(size, src), size)
        else:
            result = sub_then_set_vc(read(size, dest), read(size, src), size)
        x = c
        set_nz(result, size)
        write(size, dest, result)

def lineB(inst): # cmpa,cmp,cmpm,eor
    global x, n, z, v, c
    if inst & 0x0C0 == 0x0C0: # cmpa
        size = 4 if inst & 0x100 else 2 # size of ea but An is always .L
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = sub_then_set_vc(read(4, regs + 32 + an * 4, signed=True), read(size, ea, signed=True), 4)
        set_nz(result, 4)

    elif inst & 0x100 == 0x000: # cmp
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size
        src = address_by_mode(inst & 63, size)
        result = sub_then_set_vc(read(size, dest), read(size, src), size)
        set_nz(result, size)

    elif inst & 0x38 == 0x08: # cmpm (Ay)+,(Ax)+
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(24 | (inst & 7), size) # (An)+ mode
        dest = address_by_mode(24 | ((inst >> 9) & 7), size)
        result = sub_then_set_vc(read(size, dest), read(size, src), size)
        set_nz(result, size)

    else: # eor
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7; src = regs + 4 * dn + 4 - size
        dest = address_by_mode(inst & 63, size)

        result = read(size, dest) ^ read(size, src)
        v = c = False
        set_nz(result, size)
        write(size, dest, result)

def lineC(inst):
    if inst & 0xC0 == 0xC0: # mulu,muls
        signed = bool(inst & 0x100)
        src = address_by_mode(inst & 63, 2) # ea.w
        dest = regs + ((inst >> 9) & 7) * 4 # dn.l

        datum = read(2, dest+2, signed=signed) # read dn.w
        datum *= read(2, src, signed=signed)
        set_nz(datum, 4)
        v = c = False
        write(4, dest, datum) # write dn.l

    elif inst & 0x1F0 == 0x100: # abcd
        1/0 # I don't like BCD instructions
    elif inst & 0x1F8 in (0x140, 0x148, 0x188): # exg
        rx = (inst >> 9) & 7
        ry = inst & 7
        if inst & 0x1F8 == 0x148: # Ax,Ay
            rx |= 8; ry |= 8 # bump the addressing mode from Dn to An
        if inst & 0x1F8 == 0x188: # Dx,Ay
            ry |= 8

        rx = address_by_mode(rx, 4)
        ry = address_by_mode(ry, 4)

        x = read(4, rx)
        y = read(4, ry)
        write(4, rx, y)
        write(4, ry, x)

    else: # and
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7; dest = address_by_mode(dn, size)
        src = address_by_mode(inst & 63, size)

        if inst & 0x100: src, dest = dest, src # direction bit

        result = read(size, src) & read(size, dest)
        set_nz(result, size)
        v = c = False
        write(size, dest, result)

def lineE(inst):
    global x, n, z, v, c
    size = (1, 2, 4, None)[(inst >> 6) & 3]

    if size is None: # single-bit shift on a memory address
        size = 2
        kind = (inst >> 9) & 3
        dest = address_by_mode(inst & 63, size)
        by = 1
    else:
        kind = (inst >> 3) & 3
        dest = regs + (inst & 7) * 4 + 4 - size # dn
        if inst & 0x20:
            by = read(1, regs + ((inst >> 9) & 7) * 4 + 3) % 64
        else:
            by = (inst >> 9) & 7
            by = ((inst >> 9) & 7) or 8

    isleft = bool(inst & 0x100)

    v = False # clear V if msb never changes
    c = False # clear C if shift count is zero

    result = read(size, dest)
    mask = (1 << (size * 8)) - 1
    msb = 1 << (size * 8 - 1)
    numbits = size * 8
    if kind == 0: # asl/asr
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(result & msb) # shifted-out bit
                if newresult & msb != result & msb: v = 1 # set V if sign ever changes
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                newresult |= result & msb # replicate sign bit
                result = newresult
    elif kind == 1: # lsl/lsr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(result & msb) # shifted-out bit
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                result = newresult
    elif kind == 2: # roxl/roxr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) | x
                x = c = bool(newresult >> numbits)
                result = newresult & mask
        else:
            for i in range(by):
                newresult = (result >> 1) | (x * msb)
                x = c = bool(result & 1)
                result = newresult & mask
    elif kind == 3: # rol/ror
        v = False
        if isleft:
            for i in range(by):
                result = (result << 1) | (result >> (numbits - 1))
                c = bool(result & 1)
        else:
            for i in range(by):
                c = bool(result & 1)
                result = (result << (numbits - 1)) | (result >> 1)

    set_nz(result, size)

    write(size, dest, result)

def run_m68k_interpreter():
    global pc
    instruction_lines = (line0, line123, line123, line123, line4, line5, line6, line7,
        line8, line9D, lineA, lineB, lineC, line9D, lineE, lineF)

#     import pdb; pdb.set_trace()
    while True: # need a way to bust out of this loop
        inst = read(2, pc); pc += 2; instruction_lines[inst >> 12](inst)

def roughly_where_we_are(pc):
    # This might be adapted to shell out to a disassembler?
    is_after_NV = False
    for i in reversed(range(pc-1000, pc+2, 2)):
        if mem[i:i+2] == b'NV':
            is_after_NV = True
            break
#         elif mem[i:i+2] in (b'Nu', b'\x4e\xd0'):
#             is_after_NV = False
#             break

    is_before_rts = False
    for j in range(pc+2, pc+1000, 2):
        if mem[j:j+2] == b'NV':
            is_before_rts = False
            break
        elif mem[j:j+2] in (b'Nu', b'\x4e\xd0'):
            is_before_rts = True
            break

#     print(is_after_NV, is_before_rts)

    if is_after_NV and is_before_rts and mem[j+2] & 0x80:
        funcname = mem[j+3:j+3+(mem[j+2] & 0x7f)].decode('mac_roman')
        funcname += '+' + hex(pc-i)
    else:
        funcname = '<unknownfunc>'

    return funcname + ' ' + (mem[pc:pc+2].hex())

    # search backwards and confirm we are after an 'NV'

def print_state():
#     global pc, x, n, z, v, c
    for i in (regs, regs+32):
        print(' '.join(mem[r:r+4].hex() for r in range(i, i+32, 4)))

    sp = read(4, regs + 32 + 7 * 4)
    print('sp:', ' '.join(mem[r:r+2].hex() for r in range(sp, sp+16, 2)),
        'ccr:', 'xX'[x]+'nN'[n]+'zZ'[z]+'vV'[v]+'cC'[c])

########################################################################
# Resources! At least we can be slow when dealing with them.
########################################################################

import re # the below code could be turned into one giant regex if we were brave

rez_tokens = [
    ((),         r'(\s|//.*?\n|/\*.*?\*/)+'),                                   # 0 whitespace/comment (gets ignored)
    ((1,11),     r'\$"\s*((?:[0-9A-Fa-f]{2}\s*)*)"'),                           # 1 hex data
    ((3,),       r'(data)'),                                                    # 2 start of raw resource
    ((4,),       r"('(?:[^'\\]|\\0x[0-9A-Fa-f]{2}|\\[\\'\\?btrvfn])*')"),       # 3 type
    ((5,),       r'(\()'),                                                      # 4 start of bracketed resource info
    ((6,7,8,9),  r'(-?\d+)'),                                                   # 5 ID
    ((7,8,9),    r',gap("(?:[^"\\]|\\0x[0-9A-Fa-f]{2}|\\[\\"\\?btrvfn])*")'),   # 6 name
    ((9,),       r',gap\$([0-9a-fA-F]{1,2})'),                                  # 7 attribs (hex)
    ((8,9),      r',gap(sysheap|purgeable|locked|protected|preload)'),          # 8 attribs (specific)
    ((10,),      r'(\))'),                                                      # 9 end of bracketed resource info
    ((1,11),     r'(\{)'),                                                      # 10 start of hex block
    ((12,),      r'(\})'),                                                      # 11 end of hex block
    ((2,-1),     r'(;)'),                                                       # 12 the end for real
    ((),         r'(.)'),                                                       # 13 unexpected character (always errors)
]

allowed_to_follow_kind, token_regexen = zip(*rez_tokens)

# The 'gap' hack turns ', sysheap' etc into a single token
gap = r'(?:\s|//.*?\n|/\*.*?\*/)*'
rez_tokenizer = '|'.join(token_regexen).replace('gap', gap).encode('ascii')
rez_tokenizer = re.compile(rez_tokenizer)

def string_surrogate(m):
    m = m.group(0)

    if len(m) == 5: # \0xFF is the most common
        return bytes([int(m[3:], 16)])
    elif m == b'\\"':
        return b'"'
    elif m == b"\\'":
        return b"'"
    elif m == b'\\b':
        return b'\x08' # backspace
    elif m == b'\\t':
        return b'\t'
    elif m == b'\\r':
        return b'\n'
    elif m == b'\\v':
        return b'\x0b' # vertical tab
    elif m == b'\\f':
        return b'\x0c' # form feed
    elif m == b'\\n':
        return b'\r'
    elif m == b'\\?':
        return b'\x7f' # del

def string_literal(string):
    return re.sub(rb'(\\0x..|\\.)', string_surrogate, string[1:-1])

def readrez(path):
    # lifted from my macresources package, but a little bit 'nastier'
    # returns a list of [type, id, name, flags, data]'s
    retval = []

    with open(path, 'rb') as f: from_rezcode = f.read()
    from_rezcode = from_rezcode.replace(b'\r\n', b'\n').replace(b'\r', b'\n')

    # Slightly faster than finditer
    all_tokens = rez_tokenizer.findall(from_rezcode)
    def line_no_for_error(token_idx):
        # Redo all the lexing with finditer, which is slower but
        # gives us Match objects with a byte offset
        work_redoer = rez_tokenizer.finditer(from_rezcode)
        match_obj = next(m for i, m in enumerate(work_redoer) if i == token_idx)
        line_no = from_rezcode[:match_obj.start()].count(ord('\n')) + 1

    allowed_token_kinds = (2,-1)
    for token_idx, token_captures in enumerate(all_tokens):
        # Which single capture is non-empty?
        for token_kind, payload in enumerate(token_captures):
            if payload: break

        # Ignore whitespace
        if not token_kind: continue

        # Unexpected token!
        if token_kind not in allowed_token_kinds:
            raise ValueError('File %r, line %r' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 1:
            hex_accum.append(payload)

        elif token_kind == 2:
            res = [b'type', 9999, None, 0, b'']; retval.append(res)
            hex_accum = []

        elif token_kind == 3:
            res[0] = string_literal(payload)
            if len(res[0]) != 4:
                raise ValueError('File %r, line %r, type not 4 chars' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 5:
            res[1] = int(payload)
            if not (-32768 <= res[1] < 32767):
                raise ValueError('File %r, line %r, ID out of 16-bit range' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 6:
            res[2] = string_literal(payload)
            if len(res[2]) > 255:
                raise ValueError('File %r, line %r, name > 255 chars' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 7:
            res[3] = int(payload, 16)

        elif token_kind == 8:
            if payload == b'sysheap':
                res[3] |= 0x40
            elif payload == b'purgeable':
                res[3] |= 0x20
            elif payload == b'locked':
                res[3] |= 0x10
            elif payload == b'protected':
                res[3] |= 0x08
            elif payload == b'preload':
                res[3] |= 0x04

        elif token_kind == 12:
            res[4] = bytes.fromhex(b''.join(hex_accum).decode('ascii'))

        allowed_token_kinds = allowed_to_follow_kind[token_kind]

    # Premature EOF
    if -1 not in allowed_token_kinds:
        raise ValueError('File %r, unexpected end of file' % original_file)

    return retval

########################################################################
# Filesystem access, used by both the Toolbox and MPW code
########################################################################

import sys
import os
from os import path

def path_to_native(s):
    try:
        s = s.decode('mac_roman')
    except AttributeError:
        pass

    if path.__name__ == 'posixpath': # gives faithful but quite verbose paths
        # Expand repeated separators to ..
        while '::' in s: s = s.replace('::', ':..:')

        # Reverse the meaning of leading separator from 'relative' to 'absolute'
        if s.startswith(':'): # explicitly relative, with leading :
            s = '.' + s
        elif ':' not in s: # implicitly relative, with no :
            pass
        else: # absolute, with : but no leading :
            s = ':' + s

        # Swap separators
        s = ''.join((':' if c == path.sep else path.sep if c == ':' else c) for c in s)

        return s

    else:
        raise NotImplementedError(path.__name__)

def normcase(x): # only fail if path is ambiguous
    elements = [] # make a list of separators and non-separator runs
    for char in x:
        if len(elements) == 0 or (elements[-1][-1] == path.sep) != (char == path.sep):
            elements.append('')

        elements[-1] += char

    y = ''
    for el in elements:
        if el[0] == path.sep:
            y += el
        else:
            if el in '..':
                y += el
                continue

            possibles = os.listdir(y or '.')

            if el in possibles:
                y += el
                continue

            possibles = [p for p in possibles if p.lower() == el.lower()]

            if len(possibles) == 0:
                return y + x[len(y):] # bail out

            if len(possibles) > 1:
                raise FileNotFoundError('%r could refer to any of %r' % (y + el, possibles))

            y += possibles[0]

    return y

# We do *not* pass through the nuances of system calls to the underlying OS.
# Instead, use the well-tested Python technique of slurping a whole binary file,
# and blatting it out when we are done.
# This lets us do whole-file heuristics and avoid funky ioctl interfaces.
# It might also be faster?
# Remember that we need to do atexit stuff too.

def get_typecreator(f):
    try:
        with open(f + '.idump', 'rb') as f:
            t = f.read(4)
            if len(t) != 4: t = b'????'
            c = f.read(4)
            if len(c) != 4: c = b'????'
            return t, c
    except FileNotFoundError:
        return b'????', b'????'

def set_typecreator(f, t=None, c=None):
    try:
        with open(f + '.idump', 'w+b') as f:
            if t:
                f.write(t)
            if c:
                f.seek(4)
                f.write(c)
    except FileNotFoundError:
        pass

refnums = []

# Reimplement Unix io syscall interface atop Python
# Slurp and blat all files wholesale

def text_to_native(x):
    return x.decode('mac_roman').encode('utf8').replace(b'\r', b'\n') # can't fail

def text_to_mac(x):
    try:
        return x.decode('utf8').encode('mac_roman').replace(b'\n', b'\r')
    except UnicodeError:
        return x

# MPW open() and OS PBOpen() call me
def macopen(fname, readable=False, writable=False, exclusive=False, create=False, append=False, truncate=False, rsrcfork=False):
    # Hack to allow resource forks to be copied wholesale
    if rsrcfork: fname = path.readlink(fname) + '.rdump'

    # Will error out if the path is ambiguous
    fname = normcase(path_to_native(fname))

    if exclusive and path.exists(fname): raise FileExistsError(fname)
    if not create and not path.exists(fname): raise FileNotFoundError(fname)

    if readable and writable:
        mode = 'r+b'
    elif readable:
        mode = 'rb'
    elif writable:
        mode = 'wb'

    f = open(fname, mode)
    refnums.append(f)

    f.__mpw_mark = 0
    f.__mpw_append = append

    f.__mpw_contents = bytearray() if (truncate or not readable or fname.startswith('/dev/')) else bytearray(f.read())

    # Make our own decision about textfiles
    ftype = get_typecreator(fname)[0]
    if ftype in (b'TEXT', b'ttro') or (ftype == b'????' and not fname.endswith(('.o', '.x'))):
        f.__mpw_contents[:] = text_to_mac(f.__mpw_contents)

    return len(refnums) - 1

macopen('Dev:StdIn', readable=True)
macopen('Dev:StdOut', writable=True)
macopen('Dev:StdErr', writable=True)

def macclose(refnum):
    file = refnums[refnum]
    if file is None: return
    refnums[refnum] = None
    if file in refnums: return # rudimentary refcount

    if file.writable():
        file.seek(0)
        file.write(f.__mpw_contents)
        file.truncate()

    file.close()

def macwrite(refnum, writewhat):
    print(writewhat)
    file = refnums[refnum]

    if file.__mpw_append: __mpw_mark = len(file.__mpw_contents)
    while len(file.__mpw_contents) < file.__mpw_mark: file.__mpw_contents.append(0)
    file.__mpw_contents[file.__mpw_mark:file.__mpw_mark+len(writewhat)] = writewhat
    file.__mpw_mark += len(writewhat)

def macread(refnum, howmuch):
    file = refnums[refnum]

    retval = file.__mpw_contents[file.__mpw_mark:file.__mpw_mark+howmuch]
    file.__mpw_mark += len(retval)
    return retval

# def macdelete(f):
#     import shutil
#     for f in (f, f + '.idump', f + '.rdump'):
#         shutil.rmtree(f)

########################################################################
# The Macintosh Toolbox. Wish me luck...
########################################################################

os_traps = {}
toolbox_traps = {}
ftrap_table_addr = 0xc0000 # every permutation of f-trap

# Memory Manager OS traps

heap_blocks = {} # addr: size
master_ptrs = {}

# os_traps[0x19] = initzone_trap

def zone_nop_trap(trap, d0, a0, a1):
    return 0, 0

os_traps[0x1a] = zone_nop_trap # _GetZone
os_traps[0x1b] = zone_nop_trap # _SetZone

def freemem_trap(trap, d0, a0, a1):
    return 0x7ffffffe, 0 # d0=free, a0=growable (MaxMem only)

os_traps[0x1c] = freemem_trap
os_traps[0x1d] = freemem_trap

def newptr(size): # fixed 16b header before all "heap" blocks
    while len(mem) % 16: mem.append(0)
    mem.extend(bytes(16 + size))
    retval = len(mem) - size
    heap_blocks[retval] = size
    return retval

def newptr_trap(trap, d0, a0, a1):
    return 0, newptr(d0) # a0,d0
os_traps[0x1e] = newptr_trap

def disposptr(ptr):
    try:
        del heap_blocks[ptr]
    except:
        pass

def disposptr_trap(trap, d0, a0, a1):
    disposptr(a0)
    return 0, 0
os_traps[0x1f] = disposptr_trap

def setptrsize(ptr, size):
    if heap_blocks[ptr] >= size:
        heap_blocks[ptr] = size
        return True
    else:
        return False # failure

def setptrsize_trap(trap, d0, a0, a1):
    if setptrsize(a0, d0):
        return 0, 0 # noErr
    else:
        return -108, 0 # memFullErr
os_traps[0x20] = setptrsize_trap

def getptrsize(ptr):
    return heap_blocks[ptr]

def getptrsize_trap(trap, d0, a0, a1):
    return getptrsize(ptr), 0
os_traps[0x21] = getptrsize_trap

def newhandle(size):
    ptr = newptr(size)
    write(4, ptr - 4, ptr)
    write(4, ptr - 8, 0xFA7B175) # FatBits
    master_ptrs[ptr] = ptr - 4
    return ptr - 4 # a handle points to its owning pointer

def newhandle_trap(trap, d0, a0, a1):
    return 0, newhandle(d0)
os_traps[0x22] = newhandle_trap

def disposhandle(handle):
    try:
        ptr = read(4, handle)
        if not ptr: return
        disposptr(ptr)
    except:
        pass

def disposhandle_trap(trap, d0, a0, a1):
    return 0, disposhandle(a0)
os_traps[0x23] = disposhandle_trap

def sethandlesize(handle, size):
    ptr = read(4, handle)
    oldsize = heap_blocks[ptr] if ptr else 0
    if oldsize >= size:
        # can shrink the handle
        heap_blocks[ptr] = size
    else:
        ptr2 = newptr(size)
        del master_ptrs[ptr]
        master_ptrs[ptr2] = handle
        mem[ptr2:ptr2+oldsize] = mem[ptr:ptr+oldsize]
        disposptr(ptr)
        write(4, handle, ptr2)

def sethandlesize_trap(trap, d0, a0, a1):
    sethandlesize(a0, d0)
    return 0, 0
os_traps[0x24] = sethandlesize_trap

def gethandlesize(handle):
    ptr = read(4, handle)
    return heap_blocks[ptr] if ptr else 0

def gethandlesize_trap(trap, d0, a0, a1):
    return gethandlesize(a0), 0
os_traps[0x25] = gethandlesize_trap

def handlezone_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x26] = handlezone_trap

def reallochandle(handle, size):
    emptyhandle(handle)
    sethandlesize(handle, size)

def reallochandle_trap(trap, d0, a0, a1):
    reallochandle(a0, d0)
    return 0, 0
os_traps[0x27] = reallochandle_trap

def recoverhandle(ptr):
    return master_ptrs[ptr]

def recoverhandle_trap(trap, d0, a0, a1):
    return 0, recoverhandle(a0)
os_traps[0x28] = recoverhandle_trap

def hlock_nop_trap(trap, d0, a0, a1):
    return d0, a0
os_traps[0x29] = hlock_nop_trap # _HLock
os_traps[0x2a] = hlock_nop_trap # _HUnlock

def emptyhandle(handle):
    ptr = read(4, handle)
    del master_ptrs[ptr]
    disposptr(ptr)
    write(4, handle, 0)

def emptyhandle_trap(trap, d0, a0, a1):
    emptyhandle(a0)
    return 0, 0
os_traps[0x2b] = emptyhandle_trap

def initapplzone_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x2c] = initapplzone_trap

def setappllimit_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x2d] = setappllimit_trap

def blockmove(src, dest, size):
    shouldbe = len(mem)
    mem[dest:dest+size] = mem[src:src+size]
    if len(mem) != shouldbe: raise ValueError('hopelessly corrupted memory')

def blockmove_trap(trap, d0, a0, a1):
    blockmove(a0, a1, d0)
    return 0, 0
os_traps[0x2e] = blockmove_trap

# Trap Manager OS traps

def gettrapaddress(n, kind='auto'):
    if kind == 'auto':
        trapnum = n & 0x1f
        if trapnum < 0x4f or trapnum == 0x54 or trapnum == 0x57:
            kind = 'os'
        else:
            kind = 'toolbox'

    if kind == 'os': n &= 0xff # 256 OS traps
    elif kind == 'toolbox': n &= 0x3ff # 1024 Toolbox traps

    if kind == 'os':
        return os_trap_table[n]
    elif kind == 'toolbox':
        return toolbox_trap_table[n]

def gettrapaddress_trap(trap, d0, a0, a1):
    if trap & 0x200:
        kind = 'auto'
    else:
        if trap & 0x400:
            kind = 'toolbox'
        else:
            kind = 'os'

    # d0, a0
    return 0, gettrapaddress(d0 & 0xffff, kind)

os_traps[0x46] = gettrapaddress_trap

def settrapaddress(n, addr, kind='auto'):
    if kind == 'auto':
        trapnum = n & 0x1f
        if trapnum < 0x4f or trapnum == 0x54 or trapnum == 0x57:
            kind = 'os'
        else:
            kind = 'toolbox'

    if kind == 'os': n &= 0xff # 256 OS traps
    elif kind == 'toolbox': n &= 0x3ff # 1024 Toolbox traps

    if kind == 'os':
        os_trap_table[n] = addr
    elif kind == 'toolbox':
        toolbox_trap_table[n] = addr

def settrapaddress_trap(trap, d0, a0, a1):
    if trap & 0x200:
        kind = 'auto'
    else:
        if trap & 0x400:
            kind = 'toolbox'
        else:
            kind = 'os'

    settrapaddress(d0 & 0xffff, a0, kind)

    return 0, 0 # d0, a0

os_traps[0x47] = settrapaddress_trap

# Resource Manager Toolbox traps

def getresource(rtype, rid, one=False): # always load the resource
    for file in reversed(resource_chain):
        for resource in file:
            thistype, thisid, thisname, thisflags, thisdata, *thishandle = resource
            if thistype == rtype and thisid == rid:
                if thishandle:
                    return thishandle[0]
                else:
                    handle = newhandle(len(thisdata))
                    mem[handle+4:handle+4+len(thisdata)] = thisdata
                    resource.append(handle)
                    return handle

        if one: break

    return 0

def getresource_trap():
    rid = sign_extend(pop(2), 2)
    rtype = pop(4).to_bytes(4, 'big')
    push(4, getresource(rtype, rid, one=False))
toolbox_traps[0x1a0] = getresource_trap

def get1resource_trap():
    rid = sign_extend(pop(2), 2)
    rtype = pop(4).to_bytes(4, 'big')
    return getresource(rtype, rid, one=True)
toolbox_traps[0x1f] = get1resource_trap

def getnamedresource(rtype, rname, one=False): # always load the resource
    for file in reversed(resource_chain):
        for resource in file:
            thistype, thisid, thisname, thisflags, thisdata, *thishandle = resource
            if thistype == rtype and thisname == rname:
                if thishandle:
                    return thishandle[0]
                else:
                    handle = newhandle(len(thisdata))
                    mem[handle+4:handle+4+len(thisdata)] = thisdata
                    resource.append(handle)
                    return handle

        if one: break

    return 0

def getnamedresource_trap():
    name = pop(4)
    name = mem[name+1:name+1+mem[name]].decode('mac_roman')
    rtype = pop(4).to_bytes(4, 'big')
    push(4, getnamedresource(rtype, name, one=False))
toolbox_traps[0x1a1] = getnamedresource_trap

def get1namedresource_trap():
    name = pop(4)
    name = mem[name+1:name+1+mem[name]].decode('mac_roman')
    rtype = pop(4).to_bytes(4, 'big')
    push(4, getnamedresource(rtype, name, one=True))
toolbox_traps[0x20] = get1namedresource_trap

def setresload_trap():
    pop(2) # trash the parameter
toolbox_traps[0x19b] = setresload_trap

# Misc traps

def tickcount_trap():
    pop(4); push(4, 0) # always zero
toolbox_traps[0x175] = tickcount_trap

def purgespace_trap(trap, d0, a0, a1):
    return 0x7fffffff, 0x7fffffff # d0, a0
os_traps[0x62] = purgespace_trap

def debugstr_trap():
    strstart = pop(4)
    lenbyte = mem[strstart]
    string = mem[strstart+1:strstart+1+lenbyte].decode('mac_roman')
    print('_DebugStr', string, flush=True, file=sys.stderr)
    if string.startswith('python:'): eval(string[7:])
toolbox_traps[0x3ff] = debugstr_trap

def debugger_trap():
    import pdb; pdb.set_trace()

toolbox_traps[0x1ff] = debugger_trap

def syserror(n):
    sys.exit('System error %d' % n)

def syserror_trap():
    # trap is in toolbox table but actually uses registers
    err = read(2, regs + 2, signed=True)
    if err == -491: # display string on stack
        strstart = pop(4)
        lenbyte = mem[strstart]
        string = mem[strstart+1:strstart+1+lenbyte].decode('mac_roman')
        print('SysErr -491 string:', string, flush=True, file=sys.stderr)
    syserror(err)

toolbox_traps[0x1c9] = syserror_trap

def gestalt(selector):
    if selector == b'sysv':
        return 0x09228000 # highest possible

def gestalt_trap(trap, d0, a0, a1):
    print('gestalt', hex(d0))
    selector = d0.to_bytes(4, 'big')

    if trap & 0x600 == 0: # ab=00
        # _Gestalt
        val = gestalt(selector)
        if val == None:
            return -5551, 0 # d0, a0
        else:
            return 0, val

    elif trap & 0x600 == 0x200: # ab=01
        # _NewGestalt
        sys.exit('NewGestalt %r' % selector)

    elif trap & 0x600 == 0x400: # ab=10
        # _ReplaceGestalt
        sys.exit('ReplaceGestalt %r' % selector)

    else: # ab=11
        # _GetGestaltProcPtr
        sys.exit('GetGestaltProcPtr %r' % selector)

os_traps[0xad] = gestalt_trap

# Populate the "classic" trap table, and also our list of implementations
# The user-visible trap table initially points to _Unimplemented
toolbox_trap_table = [ftrap_table_addr + 0x89f * 2] * 0x400
os_trap_table = [ftrap_table_addr + 0x89f * 2] * 0x100

for trapnum, traphandler in toolbox_traps.items():
    ftrap_addr = ftrap_table_addr + (0x800 + trapnum) * 2
    toolbox_trap_table[trapnum] = ftrap_addr

for trapnum, traphandler in os_traps.items():
    ftrap_addr = ftrap_table_addr + trapnum * 2
    os_trap_table[trapnum] = ftrap_addr

def lineA(inst):
    global pc
    if inst & 0x0800: # Toolbox trap
        # Push return address, but not if autoPop bit set
        if not inst & 0x400: push(4, pc)

        # Look up the implementation in the classic trap table
        pc = toolbox_trap_table[inst & 0x3ff]

        if pc == ftrap_table_addr + 0x89f * 2:
            sys.exit('Unimplemented trap %04X' % inst)

    else: # OS trap
        # Push return address
        push(4, pc)

        push(4, read(4, regs + 32 + 2 * 4)) # push a2
        push(4, read(4, regs + 2 * 4))      # push d2
        push(4, read(4, regs + 1 * 4))      # push d1
        push(4, read(4, regs + 32 + 1 * 4)) # push a1
        if not inst & 0x100: # only if trap word specifies
            push(4, read(4, regs + 32 + 0 * 4)) # push a0

        if inst & 0x100:
            # Push address of four-register return f-trap
            push(4, ftrap_table_addr + 0x300 * 2) # f300
        else:
            # Push address of five-register return f-trap
            push(4, ftrap_table_addr + 0x301 * 2) # f301

        # Set d1.w to trap word
        write(2, regs + 1 * 4 + 2, inst)

        # Look up the implementation in the classic trap table
        pc = os_trap_table[inst & 0xff]

        if pc == ftrap_table_addr + 0x89f * 2:
            sys.exit('Unimplemented trap %04X' % inst)


def lineF(inst):
    global pc
    if inst & 0x0800: # Call-through to our implementation of Toolbox trap
        pc = pop(4)
        toolbox_traps[inst & 0x3ff]()

    elif inst & 0x0f00 == 0: # Call-through to our implementation of OS trap
        pc = pop(4)
        retval = os_traps[inst & 0xff](
            read(2, regs      + 1 * 4 + 2), # d1.w = trap word
            read(4, regs      + 0 * 4),     # d0.l
            read(4, regs + 32 + 0 * 4),     # a0.l
            read(4, regs + 32 + 1 * 4),     # a1.l
        )

        if isinstance(retval, tuple):
            write(4, regs, retval[0]) # d0.l = return value
            write(4, regs + 32, retval[1]) # a0.l = other return value
        else:
            write(4, regs, retval) # d0.l = only return value

    elif inst in (0xf300, 0xf301): # OS trap return assistance code
        if inst & 1: # was this a "save-a0" OS trap word?
            write(4, regs + 32 + 0 * 4, pop(4)) # pop a0
        write(4, regs + 32 + 1 * 4, pop(4)) # pop a1
        write(4, regs      + 1 * 4, pop(4)) # pop d1
        write(4, regs      + 2 * 4, pop(4)) # pop d2
        write(4, regs + 32 + 2 * 4, pop(4)) # pop a2
        set_nz(read(2, regs + 0 * 4), 2) # tst.w d0
        pc = pop(4) # Return to the actual caller

    else: # Special MPW call
        mpw_ftrap(inst)

########################################################################
# Initialise an MPW environment
########################################################################

import struct

# A memory, and some memory-mapped registers
mem = bytearray(0x100000) # plenty of room for globals
regs = 0x80000

def mpw_ftrap(inst): # special breakout instructions, not for general use
    if inst == 0xf100:
        # quit
        sys.exit()

    elif inst == 0xf101:
        # access
        sp = read(4, regs + 64 - 4)
        arg1 = read(4, sp + 4)
        arg2 = read(4, sp + 8)
        arg3 = read(4, sp + 12)

        if arg2 == 0x6400: # open
            # No error handling, yet
            flags = read(2, arg3)
            name = mem[arg1+1:arg1+1+mem[arg1]]
            fd = macopen(fname,
                readable=flags & 3 in (0, 2),
                writable=flags & 3 in (1, 2),
                append=flags & 8,        # O_APPEND
                rsrcfork=flags & 0x10,   # O_RSRC
                create=flags & 0x100,    # O_CREAT
                truncate=flags & 0x200,  # O_TRUNC
                exclusive=flags & 0x400, # O_EXCL
                # note that we ignore O_BINARY
                )
            write(4, regs, 0) # d0.l = 0
            write(2, arg3 + 2, 0) # error code = 0
            write(4, arg3 + 8, fd) # cookie = index into our array

        elif arg2 == 0x6401: # delete
            name = mem[arg1+1:arg1+1+mem[arg1]]
            macdelete(name)
            write(4, regs, 0) # d0.l = 0

        elif arg2 == 0x6402: # rename
            raise NotImplementedError('rename')

        else: # something else not supported
            pass

    elif inst == 0xf102:
        # close
        raise NotImplementedError('close')

    elif inst == 0xf103:
        # read
        raise NotImplementedError('read')

    elif inst == 0xf104:
        # write
        sp = read(4, regs + 64 - 4)
        fptr = read(4, sp + 4)
        fd = read(4, fptr + 8) # cookie
        cnt = read(4, fptr + 12)
        buf = read(4, fptr + 16)
        macwrite(fd, mem[buf:buf+cnt])

    elif inst == 0xf105:
        # ioctl
        sp = read(4, regs + 64 - 4)
        fptr = read(4, sp + 4)
        request = read(4, sp + 8)
        argp = read(4, sp + 12)

        print('ioctl', hex(fptr), hex(request), hex(argp))
        print(' fptr', mem[fptr:fptr+28].hex())
        print(' argp', mem[argp:argp+16].hex())

        fd = read(4, fptr + 8) # cookie
        f = refnums[fd]

        def err(n):
            write(2, fptr + 2, n) # set in structure
            write(4, regs, n) # set in d0

        if request == 0x6600:
            # seek
            if fd <= 2: # standard stream
                err(-1)
                return

            offset = read(4, argp + 4, signed=True)
            whence = read(4, argp)
            if whence == 2: # SEEK_END
                f.__mpw_mark = len(f.__mpw_contents)
            elif whence == 0: # SEEK_SET
                f.__mpw_mark = 0
            f.__mpw_mark += offset

            if f.__mpw_mark > len(f.__mpw_contents):
                f.__mpw_mark = len(f.__mpw_contents)
                err(-1)

            err(0)

        elif request == 0x6601:
            # duplicate fd, required for freopen
            refnums.append(f)
            err(0)
        elif request == 0x6602:
            # is interactive?
            if fd <= 2:
                err(0)
            else:
                err(23) # EINVAL
        elif request == 0x6603:
            # ideal buffer size
            err(23) # use default 1k, that's fine
        elif request == 0x6604:
            # fname
            err(0) # todo, implement
        elif request == 0x6605:
            # refnum
            write(4, argp, fd)
            err(0)
        elif request == 0x6606:
            # set eof
            del f.__mpw_contents[argp:]
            f.__mpw_contents.extend(bytes(argp - len(f.__mpw_contents)))
        else:
            raise NotImplementedError('ioctl 0x%x' % request)



    else:
        raise ValueError('%04X not implemented' % inst)

def read(numbytes, addr, signed=False):
    return int.from_bytes(mem[addr:addr+numbytes], 'big', signed=signed)

def write(numbytes, addr, val):
    val &= (1 << (numbytes * 8)) - 1
    mem[addr:addr+numbytes] = val.to_bytes(numbytes, 'big')
#     print('write', numbytes, hex(addr), val.to_bytes(numbytes, 'big').hex())

write(4, regs + 8 * 4 + 7 * 4, 0x80000) # stack growing down from registers


# Big table of every permutation of f-trap at c0000
for i in range(0x1000):
    struct.pack_into('>H', mem, ftrap_table_addr + i * 2, 0xf000 + i)


argv = sys.argv[1:]
argv[0] = argv[0].rpartition('/')[2]

env = []
for key, val in sorted(os.environ.items()):
    if key.lower().startswith('MPW_'):
        env.append((key[4:] + '\0' + val + b'\0').encode('mac_roman'))

# Block of code for MPW callbacks
# elements ending with '::' are labels, with '??' are ptrs
bigblock = [
    b'MPGM',
    'pointer to sh table',

    'sh table',
        b'SH',
        len(argv).to_bytes(4, 'big'),
        'pointer to argument array',
        'pointer to environment array',
        bytes(12),
        b'\x01\x90', # ?default fd table size
        'pointer to io table',
        'pointer to dev table',
        bytes(12),

    'quit instruction',
        b'\xf1\x00\x4e\x75',

    'access instruction',
        b'\xf1\x01\x4e\x75',

    'close instruction',
        b'\xf1\x02\x4e\x75',

    'read instruction',
        b'\xf1\x03\x4e\x75',

    'write instruction',
        b'\xf1\x04\x4e\x75',

    'ioctl instruction',
        b'\xf1\x05\x4e\x75',

    'dev table',
        b'FSYS',
        'pointer to access instruction',
        'pointer to close instruction',
        'pointer to read instruction',
        'pointer to write instruction',
        'pointer to ioctl instruction',
        b'ECON',
        bytes(20),
        b'SYST',
        bytes(20),

    'io table',
        b'\x00\x01', # flags = read
        b'\x00\x00', # error code
        'pointer to dev table',
        b'\x00\x00\x00\x01', # cookie = stdin
        b'\x00\x00\x00\x00', # transfer byte count (set by tool)
        b'\x00\x00\x00\x00', # buffer ptr (set by tool)

        b'\x00\x02', # flags = write
        b'\x00\x00', # error code
        'pointer to dev table',
        b'\x00\x00\x00\x02', # cookie = stdout
        b'\x00\x00\x00\x00', # transfer byte count (set by tool)
        b'\x00\x00\x00\x00', # buffer ptr (set by tool)

        b'\x00\x02', # flags = write
        b'\x00\x00', # error code
        'pointer to dev table',
        b'\x00\x00\x00\x03', # cookie = stderr
        b'\x00\x00\x00\x00', # transfer byte count (set by tool)
        b'\x00\x00\x00\x00', # buffer ptr (set by tool)

    'environment array',
        *('pointer to environment %d' % i for i in range(len(env))),

    'argument array',
        *('pointer to argument %d' % i for i in range(len(argv))),
]

for i, arg in enumerate(argv):
    bigblock.append('argument %d' % i)
    bigblock.append(arg.encode('mac_roman') + b'\0')

for i, e in enumerate(env):
    bigblock.append('environment %d' % i)
    bigblock.append(e)

putwhere = 0x90000
ctr = putwhere
labels = {}
relocations = []
for item in bigblock:
    if isinstance(item, str):
        if item.startswith('pointer to '):
            relocations.append((ctr, item[11:]))
            ctr += 4
        else: # a label
            labels[item] = ctr
    else: # plain bytes
        mem[ctr:ctr+len(item)] = item
        ctr += len(item)
        ctr += ctr & 1 # pad to even
for address, targetlabel in relocations:
    struct.pack_into('>L', mem, address, labels[targetlabel])
struct.pack_into('>L', mem, 0x316, putwhere)
push(4, labels['quit instruction'])

resource_chain = [[], readrez(sys.argv[1] + '.rdump')] # system and app
code0 = next(r for r in resource_chain[1] if r[0] == b'CODE' and r[1] == 0)[-1]

# Some misc globals
write(4, 0x31a, 0x00ffffff)
write(4, 0xa02, 0x00010001)
write(4, 0xa06, 0xffffffff)
write(4, 0x130, 0) # ApplLimit
write(4, 0x908, 0x70000000) # CurStackBase
mem[0x910:0x910+5] = b'\x04Sort'

# Make an a5 world
abovea5, belowa5, jtsize, jtoffset = struct.unpack_from('>LLLL', code0)
a5world = newptr(belowa5 + abovea5) + belowa5
write(4, regs + 8 * 4 + 5 * 4, a5world); write(4, 0x904, a5world)
pc = a5world + jtoffset + 2

is_far_model = False
for i in range(0, jtsize, 8):
    words = struct.unpack_from('>HHHH', code0, 16 + i)
    if words[1] == 0xFFFF:
        is_far_model = True
        continue

    if is_far_model:
        raise NotImplementedError('far model not written yet')

    else:
        segmenthandle = getresource(b'CODE', words[2])
        target = segmenthandle + 4 + 4 + words[0]

    write(6, a5world + jtoffset + i + 2, (0x4EF9 << 32) | target) # jmp there

run_m68k_interpreter()
