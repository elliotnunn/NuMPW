#!/usr/bin/env python3

########################################################################
# 68000 interpreter: minimal user-mode implementation
#
# Notes:
# - all "sizes" are in bytes
# - define read(), write() and lineA() somewhere outside this block
########################################################################

class IllegalInstruction(Exception): pass

# Emulator state: set to something better than this before running
regs = 0
pc = 0
x = n = z = v = c = 0

def push(size, data):
    ptr = address_by_mode(39, size) # -(A7)
    write(size, ptr, data)

def pop(size):
    ptr = address_by_mode(31, size) # (A7)+
    return read(size, ptr)

def sign_extend(n, size):
    bitsize = size * 8
    n &= (1 << bitsize) - 1 # clip to size
    signbit = 1 << (bitsize - 1)
    if n & (1 << (bitsize - 1)): n -= (1 << bitsize)
    return n

def add_then_set_vc(a, b, size):
    global v, c
    bitsize = size * 8
    signbit = 1 << (bitsize - 1)
    mask = (1 << bitsize) - 1
    a &= mask
    b &= mask
    result = (a + b) & mask
    v = (a & signbit) == (b & signbit) != (result & signbit)
    c = result < a # could use result < b just as easily
    return result

def sub_then_set_vc(a, b, size): # subtract b from a
    global v, c
    bitsize = size * 8
    signbit = 1 << (bitsize - 1)
    mask = (1 << bitsize) - 1
    a &= mask
    b &= mask
    result = (a - b) & mask
    v = (a & signbit) != (b & signbit) == (result & signbit)
    c = a < b
    return result

def set_nz(num, size):
    global n, z
    bitsize = size * 8
    n = bool(num & (1 << (bitsize - 1)))
    z = (num == 0)

def get_ccr():
    return (x << 4) | (n << 3) | (z << 2) | (v << 1) | c

def set_ccr(to_byte):
    global x, n, z, v, c
    x = bool(to_byte & 16)
    n = bool(to_byte & 8)
    z = bool(to_byte & 4)
    v = bool(to_byte & 2)
    c = bool(to_byte & 1)

def address_by_mode(mode, size): # mode given by bottom 6 bits
    # side effects: predecrement/postincrement, advance pc to get extension word
    global pc

    if mode >> 3 == 0: # Dn
        ptr = regs + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 1: # An
        ptr = regs + 32 + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 2: # (An)
        ptr = read(4, regs + 32 + (mode & 7) * 4)
    elif mode >> 3 == 3: # (An)+
        regptr = regs + 32 + (mode & 7) * 4
        newptr = ptr = read(4, regptr)
        newptr += size
        if mode & 7 == 7 and size == 1: newptr += 1
        write(4, regptr, newptr)
    elif mode >> 3 == 4: # -(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, regptr)
        ptr -= size
        if mode & 7 == 7 and size == 1: ptr -= 1
        write(4, regptr, ptr)
    elif mode >> 3 == 5: # d16(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = (read(4, regptr) + read(2, pc, signed=True)); pc += 2
    elif mode >> 3 == 6: # d8(An,Xn)
        ptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, ptr) # get An
        #
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 58: # d16(PC)
        ptr = pc + read(2, pc, signed=True); pc += 2
    elif mode == 59: # d8(PC,Xn)
        ptr = pc
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 56: # abs.W
        ptr = read(2, pc); pc += 2
    elif mode == 57: # abs.L
        ptr = read(4, pc); pc += 4
    elif mode == 60: # #imm
        if size == 1:
            ptr = pc + 1; pc += 2
        elif size == 2:
            ptr = pc; pc += 2
        elif size == 4:
            ptr = pc; pc += 4
    else:
        raise IllegalInstruction('reserved address mode %s' % bin(mode)[2:].zfill(3))

    return ptr

def test_condition(cond):
    if cond == 0: # T true
        return True
    elif cond == 1: # F false
        return False
    elif cond == 2: # HI higher than
        return not (c or z)
    elif cond == 3: # LS lower or same
        return c or z
    elif cond == 4: # CC carry clear aka HS
        return not c
    elif cond == 5: # CS carry set aka LS
        return c
    elif cond == 6: # NE not equal
        return not z
    elif cond == 7: # EQ equal
        return z
    elif cond == 8: # VC overflow clear
        return not v
    elif cond == 9: # VS overflow set
        return v
    elif cond == 10: # PL plus
        return not n
    elif cond == 11: # MI minus
        return n
    elif cond == 12: # GE greater or equal
        return n == v
    elif cond == 13: # LT less than
        return not (n == v)
    elif cond == 14: # GT greater than
        return n == v and not z
    elif cond == 15: # LE less or equal
        return n != v or z

def line0(inst):
    global pc, x, n, z, v, c
    if inst & 256 or inst >> 9 == 4: # btst,bchg,bclr,bset (or movep)
        if inst & 256: # bit numbered by data register
            if (inst >> 3) & 7 == 1: raise IllegalInstriction('movep')
            dn = inst >> 9
            bit = read(4, regs + dn * 4)
        else: # bit numbered by immediate
            bit = read(2, pc); pc += 2

        mode = inst & 63
        if mode >> 3 <= 1: size = 4 # applies to register
        else: size = 1 # applies to memory address

        bit %= size * 8
        mask = 1 << bit

        ptr = address_by_mode(mode, size)
        val = read(size, ptr)
        z = not (val & mask)

        if (inst >> 6) & 3 == 1: # bchg
            val ^= mask
        elif (inst >> 6) & 3 == 2: # bclr
            val &= ~mask
        elif (inst >> 6) & 3 == 3: # bset
            val |= mask
        # ^^ the btst case is already handled by setting z

        write(size, ptr, val)

    else: #ori,andi,subi,addi,eori -- including to SR/CCR
        size = (1,2,4,None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('ori/andi/subi/addi/eori size=%11')
        src_ptr = address_by_mode(60, size) # '#imm' mode, advances pc
        imm = read(size, src_ptr)

        # now, are we operating on a special mode?
        dest_mode = inst & 63
        if dest_mode == 60: # '#imm' actually means CCR/SR
            # for addi/subi this would simply be invalid
            val = get_ccr()
        else:
            dest_ptr = address_by_mode(dest_mode, size)
            val = read(size, dest_ptr)

        if inst >> 9 == 0: # ori
            val |= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 1: # andi
            val &= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 2: # subi
            val = sub_then_set_vc(val, imm, size)
            x = c
            set_nz(val, size)
        elif inst >> 9 == 3: # addi
            val = add_then_set_vc(val, imm, size)
            x = c
            set_nz(val, size)
        elif inst >> 9 == 5: # eori
            val ^= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 6: # cmpi: same as subi, but don't set
            fake_val = sub_then_set_vc(val, imm, size)
            set_nz(fake_val, size)

        if dest_mode == 60:
            set_ccr(val)
        else:
            write(size, dest_ptr, val)

def line123(inst): # move, and movea which is a special-ish case
    global v, c
    size = (None, 1, 4, 2)[(inst >> 12) & 3]
    if size is None: raise IllegalInstruction('move size=%00')
    dest_mode = ((inst >> 3) & 0x38) | ((inst >> 9) & 7)
    src_mode = inst & 63

    src = address_by_mode(src_mode, size)
    datum = read(size, src, signed=True)

    if dest_mode >> 3 == 1: # movea: sign extend to 32 bits
        size = 4
    else: # non-movea: set condition codes
        v = c = 0
        set_nz(datum, size)

    dest = address_by_mode(dest_mode, size)
    write(size, dest, datum)

def line4(inst): # very,crowded,line
    global pc, x, n, z, v, c
    if (inst >> 6) & 63 == 3: # move from sr
        dest = address_by_mode(inst & 63, 2) # sr is 2 bytes
        write(2, dest, get_ccr())
    elif (inst >> 6) & 63 in (19, 27): # move to sr/ccr
        size = 1 if (inst >> 6) & 63 == 19 else 2 # ccr or sr?
        src = address_by_mode(inst & 63, size)
        set_ccr(read(size, src))
    elif (inst >> 8) & 15 in (0, 4, 6): # negx,neg,not
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('negx/neg/not size=%11')
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)

        if (inst >> 8) & 15 == 0: # negx
            datum = sub_then_set_vc(0, datum+x, size)
            x = c
            set_nz(datum, size)
        elif (inst >> 8) & 15 == 4: # neg
            datum = sub_then_set_vc(0, datum, size)
            x = c
            set_nz(datum, size)
        else: # not
            datum = ~datum
            v = c = False
            set_nz(datum, size)

        write(size, dest, datum)

    elif (inst >> 8) & 15 == 2: # clr
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('clr size=%11')
        dest = address_by_mode(inst & 63, size)

        n = False
        z = True
        v = False
        c = False

        write(size, dest, 0)

    elif inst & 0xFB8 == 0x880: # ext
        size = 4 if inst & 64 else 2
        dn = inst & 7
        src = regs + dn * 4 + 4 - size//2
        dest = regs + dn * 4 + 4 - size
        datum = read(size//2, src, signed=True)
        set_nz(datum, size)
        v = c = False
        write(size, dest, datum)

    elif inst & 0xFF8 == 0x840: # swap.w
        dn = inst & 7
        dest = regs + dn * 4
        datum = read(4, dest)
        datum = ((datum >> 16) & 0xFFFF) | ((datum & 0xFFFF) << 16)
        set_nz(datum, 4)
        v = c = False
        write(4, dest, datum)

    elif inst & 0xFC0 == 0x840: # pea -- notice similarity to swap.w
        ea = address_by_mode(inst & 63, 4) # size doesn't matter here
        push(4, ea)

    elif inst & 0xF00 == 0xA00: # tst,tas
        size, is_tas = ((1,0), (2,0), (4,0), (1,1))[(inst >> 6) & 3]
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        set_nz(datum, size)
        v = c = False
        if is_tas: write(1, dest, datum | 0x80)

    elif inst & 0xFF8 == 0xE50: # link
        an = inst & 7; an_ea = regs + 32 + an * 4
        imm = read(2, pc, signed=True); pc += 2

        push(4, read(4, an_ea)) # move.l a6,-(sp)
        sp = read(4, regs+60)
        write(4, an_ea, sp) # move.l sp,a6
        write(4, regs+60, sp + imm) # add.w #imm,sp

    elif inst & 0xFF8 == 0xE58: # unlk
        an = inst & 7; an_ea = regs + 32 + an * 4

        write(4, regs+60, read(4, an_ea)) # move.l a6,sp
        write(4, an_ea, pop(4)) # move.l (sp)+,a6

    elif inst & 0xFFF == 0xE71: # nop
        pass

    elif inst & 0xFFF == 0xE75: # rts
        pc = pop(4)

    elif inst & 0xFFF == 0xE77: # rtr
        set_ccr(pop(2))
        pc = pop(4)

    elif inst & 0xF80 == 0xE80: # jsr/jmp
        targ = address_by_mode(inst & 63, 4) # any size
        if not inst & 0x40:
            push(4, pc)
        pc = targ

    elif inst & 0xB80 == 0x880: # movem
        size = 4 if inst & 64 else 2
        dir_to_reg = bool(inst & 0x400)
        which = read(2, pc); pc += 2
        mode = inst & 63

        if mode >> 3 == 4: # predecrement, reverse "which"
            which = [r for r in range(16) if which & (0x8000 >> r)]
        else:
            which = [r for r in range(16) if which & (1 << r)]

        ptr = address_by_mode(mode, len(which) * size)

        for reg in which:
            if dir_to_reg:
                datum = read(size, ptr, signed=True); ptr += size
                write(4, regs+reg*4, datum)
            else:
                datum = read(size, regs + reg * 4 + 4 - size)
                write(size, ptr, datum); ptr += size

    elif inst & 0x1C0 == 0x1C0: # lea
        an = (inst >> 9) & 7
        ea = address_by_mode(inst & 63, 4) # any size
        write(4, regs + 32 + an * 4, ea)

    elif inst & 0x1C0 == 0x180: # chk
        dn = (inst >> 9) & 7
        testee = read(2, regs + 4 * dn + 2, signed=True)
        ea = address_by_mode(inst & 63, 2)
        ubound = read(2, ea, signed=True)
        if not 0 <= testee <= ubound: raise ValueError('chk failed') # raise exception

def line5(inst): # addq,subq,scc,dbcc
    global pc, x, n, z, v, c
    if (inst >> 6) & 3 != 3: # addq,subq
        size = 1 << ((inst >> 6) & 3)
        if size == 2 and (inst >> 3) & 7 == 1: size = 4 # An.w is really An.l

        imm = ((inst >> 9) & 7) or 8

        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        save_ccr = x, n, z, v, c
        if inst & 256: # subq
            datum = sub_then_set_vc(datum, imm, size)
        else: # addq
            datum = add_then_set_vc(datum, imm, size)
        x = c
        set_nz(datum, size)
        if (inst >> 3) & 7 == 1: x, n, z, v, c = save_ccr # touch not ccr if dest is An
        write(size, dest, datum)

    elif (inst >> 3) & 7 == 1: # dbcc
        disp = read(2, pc, signed=True) - 2; pc += 2

        cond = (inst >> 8) & 15 # if cond satisfied then DO NOT take loop
        if test_condition(cond): return

        # decrement the counter (dn)
        dn = inst & 7
        dest = regs + dn * 4 + 2
        counter = (read(2, dest) - 1) & 0xFFFF
        write(2, dest, counter)
        if counter == 0xFFFF: return # do not take the branch

        pc += disp

    else: # scc
        dest = address_by_mode(inst & 63, 1)
        cond = (inst >> 8) & 15
        write(1, dest, 0xFF * test_condition(cond))

def line6(inst): # bra,bsr,bcc
    global pc
    disp = sign_extend(inst & 255, 1)
    if disp == 0: # word displacement
        disp = read(2, pc, signed=True) - 2; pc += 2

    cond = (inst >> 8) & 15
    if cond > 1 and not test_condition(cond): return # not taken

    if cond == 1: # is bsr
        push(4, pc)

    pc += disp

def line7(inst): # moveq
    global n, z, v, c
    dn = (inst >> 9) & 7
    val = sign_extend(inst & 255, 1)
    n = (val < 0); z = (val == 0); v = c = 0
    write(4, regs + dn * 4, val)

def line8(inst): # divu,divs,sbcd,or
    global n, z, v, c
    if inst & 0x1F0 == 0x100: # sbcd
        raise IllegalInstruction('sbcd')
    elif inst & 0x0C0 == 0x0C0: # divu,divs
        signed = bool(inst & 0x100)
        ea = address_by_mode(inst & 63, 2)
        divisor = read(2, ea, signed)
        if divisor == 0: 1/0 # div0 error
        dn = (inst >> 9) & 7
        dividend = read(4, regs + dn * 4, signed)

        # remainder is 0 or has same sign as dividend
        quotient = abs(dividend) // abs(divisor)
        if dividend < 0: quotient = -quotient
        if divisor < 0: quotient = -quotient
        remainder = abs(dividend) % abs(divisor)
        if dividend < 0: remainder = -remainder

        if signed and not (-0x8000 <= quotient < 0x7FFF):
            v = True
            return

        if not signed and quotient > 0xFFFF:
            v = True
            return

        v = False
        set_nz(quotient, 2)

        write(4, regs + dn * 4, ((remainder & 0xFFFF) << 16) | (quotient & 0xFFFF))

    else: # or
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('or size=%11')
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src

        datum = read(size, src) | read(size, dest)
        write(size, dest, datum)
        set_nz(datum, size)
        v = c = False

def line9D(inst): # sub,subx,suba//add,addx,adda: very compactly encoded
    global x, n, z, v, c
    sign = 1 if inst & 0x4000 else -1
    if inst & 0x0C0 == 0x0C0: # suba,adda
        size = 4 if inst & 0x100 else 2
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = read(4, regs + 32 + an * 4, signed=True) + sign * read(size, ea, signed=True)
        write(4, regs + 32 + an * 4, result)

    elif inst & 0x130 == 0x100: # subx,addx: only two addressing modes allowed
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('subx/addx size=%11')
        mode = 32 if inst & 8 else 0 # either -(Ax),-(Ay) or Dx,Dy
        src = address_by_mode(mode | (inst & 7), size)
        dest = address_by_mode(mode | ((inst >> 9) & 7), size)

        if sign == 1:
            result = add_then_set_vc(read(size, dest), read(size, src) + x, size)
        else:
            result = sub_then_set_vc(read(size, dest), read(size, src) + x, size)
        write(size, dest, result)
        x = c
        old_z = z; set_nz(result, size); z &= old_z

    else: # sub,add
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('sub/add size=%11')
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src # direction bit does a swap
        if sign == 1:
            result = add_then_set_vc(read(size, dest), read(size, src), size)
        else:
            result = sub_then_set_vc(read(size, dest), read(size, src), size)
        x = c
        set_nz(result, size)
        write(size, dest, result)

def lineB(inst): # cmpa,cmp,cmpm,eor
    global x, n, z, v, c
    if inst & 0x0C0 == 0x0C0: # cmpa
        size = 4 if inst & 0x100 else 2 # size of ea but An is always .L
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = sub_then_set_vc(read(4, regs + 32 + an * 4, signed=True), read(size, ea, signed=True), 4)
        set_nz(result, 4)

    elif inst & 0x100 == 0x000: # cmp
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('cmp size=%11')
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size
        src = address_by_mode(inst & 63, size)
        result = sub_then_set_vc(read(size, dest), read(size, src), size)
        set_nz(result, size)

    elif inst & 0x38 == 0x08: # cmpm (Ay)+,(Ax)+
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('cmpm size=%11')
        src = address_by_mode(24 | (inst & 7), size) # (An)+ mode
        dest = address_by_mode(24 | ((inst >> 9) & 7), size)
        result = sub_then_set_vc(read(size, dest), read(size, src), size)
        set_nz(result, size)

    else: # eor
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('eor size=%11')
        dn = (inst >> 9) & 7; src = regs + 4 * dn + 4 - size
        dest = address_by_mode(inst & 63, size)

        result = read(size, dest) ^ read(size, src)
        v = c = False
        set_nz(result, size)
        write(size, dest, result)

def lineC(inst):
    if inst & 0xC0 == 0xC0: # mulu,muls
        signed = bool(inst & 0x100)
        src = address_by_mode(inst & 63, 2) # ea.w
        dest = regs + ((inst >> 9) & 7) * 4 # dn.l

        datum = read(2, dest+2, signed=signed) # read dn.w
        datum *= read(2, src, signed=signed)
        set_nz(datum, 4)
        v = c = False
        write(4, dest, datum) # write dn.l

    elif inst & 0x1F0 == 0x100: # abcd
        raise IllegalInstruction('abcd')
    elif inst & 0x1F8 in (0x140, 0x148, 0x188): # exg
        rx = (inst >> 9) & 7
        ry = inst & 7
        if inst & 0x1F8 == 0x148: # Ax,Ay
            rx |= 8; ry |= 8 # bump the addressing mode from Dn to An
        if inst & 0x1F8 == 0x188: # Dx,Ay
            ry |= 8

        rx = address_by_mode(rx, 4)
        ry = address_by_mode(ry, 4)

        x = read(4, rx)
        y = read(4, ry)
        write(4, rx, y)
        write(4, ry, x)

    else: # and
        size = (1, 2, 4, None)[(inst >> 6) & 3]
        if size is None: raise IllegalInstruction('and size=%11')
        dn = (inst >> 9) & 7; dest = address_by_mode(dn, size)
        src = address_by_mode(inst & 63, size)

        if inst & 0x100: src, dest = dest, src # direction bit

        result = read(size, src) & read(size, dest)
        set_nz(result, size)
        v = c = False
        write(size, dest, result)

def lineE(inst):
    global x, n, z, v, c
    size = (1, 2, 4, None)[(inst >> 6) & 3]

    if size is None: # single-bit shift on a memory address
        size = 2
        kind = (inst >> 9) & 3
        dest = address_by_mode(inst & 63, size)
        by = 1
    else:
        kind = (inst >> 3) & 3
        dest = regs + (inst & 7) * 4 + 4 - size # dn
        if inst & 0x20:
            by = read(1, regs + ((inst >> 9) & 7) * 4 + 3) % 64
        else:
            by = (inst >> 9) & 7
            by = ((inst >> 9) & 7) or 8

    isleft = bool(inst & 0x100)

    v = False # clear V if msb never changes
    c = False # clear C if shift count is zero

    result = read(size, dest)
    mask = (1 << (size * 8)) - 1
    msb = 1 << (size * 8 - 1)
    numbits = size * 8
    if kind == 0: # asl/asr
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(result & msb) # shifted-out bit
                if newresult & msb != result & msb: v = 1 # set V if sign ever changes
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                newresult |= result & msb # replicate sign bit
                result = newresult
    elif kind == 1: # lsl/lsr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(result & msb) # shifted-out bit
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                result = newresult
    elif kind == 2: # roxl/roxr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) | x
                x = c = bool(newresult >> numbits)
                result = newresult & mask
        else:
            for i in range(by):
                newresult = (result >> 1) | (x * msb)
                x = c = bool(result & 1)
                result = newresult & mask
    elif kind == 3: # rol/ror
        v = False
        if isleft:
            for i in range(by):
                result = (result << 1) | (result >> (numbits - 1))
                c = bool(result & 1)
        else:
            for i in range(by):
                c = bool(result & 1)
                result = (result << (numbits - 1)) | (result >> 1)

    set_nz(result, size)

    write(size, dest, result)

def run_m68k_interpreter():
    global pc
    instruction_lines = (line0, line123, line123, line123, line4, line5, line6, line7,
        line8, line9D, lineA, lineB, lineC, line9D, lineE, lineF)

#     import pdb; pdb.set_trace()
    wse = None
    watched = 0x14885c
    while True: # need a way to bust out of this loop
        try:
            inst = read(2, pc)
#             wse2 = mem[watched:watched+4]
#             if wse2 != wse: print('CHANGED! ', end='')
#             print(hex(watched), '=', wse2.hex() if wse2 else 'nonexistent')
#             wse = wse2
            print_state(); print()
            print(roughly_where_we_are(pc)); print()
            pc += 2
            instruction_lines[inst >> 12](inst)
        except IllegalInstruction as e:
            print(e, hex(inst), file=sys.stderr)
            sys.exit(1)

def roughly_where_we_are(pc):
    # This might be adapted to shell out to a disassembler?
    is_after_NV = False
    for i in reversed(range(pc-1000, pc+2, 2)):
        if mem[i:i+2] == b'NV':
            is_after_NV = True
            break
#         elif mem[i:i+2] in (b'Nu', b'\x4e\xd0'):
#             is_after_NV = False
#             break

    is_before_rts = False
    for j in range(pc+2, pc+1000, 2):
        if mem[j:j+2] == b'NV':
            is_before_rts = False
            break
        elif mem[j:j+2] in (b'Nu', b'\x4e\xd0'):
            is_before_rts = True
            break

#     print(is_after_NV, is_before_rts)

    if is_after_NV and is_before_rts and j+2 < len(mem) and mem[j+2] & 0x80:
        funcname = mem[j+3:j+3+(mem[j+2] & 0x7f)].decode('mac_roman')
        funcname += '+' + hex(pc-i)
    else:
        funcname = '<unknownfunc>'

    # Find out which segment this is:
    found = '<unknownseg>'
    for segment in resource_chain[1]:
        if len(segment) == 6:
            ptr = read(4, segment[5])
            endptr = ptr + len(segment[4])
            if ptr <= pc < endptr:
                found = 'seg-' + str(segment[1])
                if segment[2]: found += '-' + segment[2].decode('mac_roman')
                found += '+' + hex(pc - ptr)
                break

    return hex(pc) + ' ' + funcname + ' ' + found + ' ' + (mem[pc:pc+2].hex())

    # search backwards and confirm we are after an 'NV'

def print_state():
#     global pc, x, n, z, v, c
    for i in (regs, regs+32):
        print(' '.join(mem[r:r+4].hex() for r in range(i, i+32, 4)))

    sp = read(4, regs + 32 + 7 * 4)
    print('sp:', ' '.join(mem[r:r+2].hex() for r in range(sp, sp+20, 2)),
        'ccr:', 'xX'[x]+'nN'[n]+'zZ'[z]+'vV'[v]+'cC'[c])

def where_string_is(string):
    locs = []
    i = -1
    while (i := mem.find(string, i+1)) != -1:
        locs.append(i)
    retval = []
    for i in locs:
        retval.append('%r at %08x, preceded by %s, followed by %s' %
        (string, i, mem[i-2:i].hex(), mem[i+len(string):i+len(string)+2].hex()))
    return '\n'.join(retval)

########################################################################
# SANE -- blobs from Mac Plus ROM
########################################################################

pack4 = bytes.fromhex('''
600A 0000 5041 434B 0004 0002 4E56 FFFE 48E7 FFF8 307C 0A4A 6026 00E1 00E1 00E1
00E1 00C1 00C1 00E1 0061 0161 00A0 00A0 00A0 00A1 00A0 0041 4E56 FFFE 48E7 FFF8
3C2E 0008 7E1E CE46 0886 0000 6600 09EA 08A8 0007 0001 8C7B 70C2 7060 C028 0001
EE58 8C40 0806 0008 6714 3006 0246 00FF 0240 3800 3200 E749 E658 8C40 8C41 4846
4282 2602 3C02 0806 0017 670E 2006 4840 EE58 266E 000A 6100 00CA 0806 0016 6720
2244 2445 2F0C E21E D442 3003 D643 D640 2006 4840 ED58 266E 000E 6100 00A6 265F
E306 6804 08C6 0006 E216 3007 4287 487A 002E 4A42 6600 01DC 303B 0006 4EFB 00FA
04BC 04B8 0556 05F6 070C 070C 068E 0778 07EC 0854 0780 078C 0930 08FA 0940 0806
0015 670A 2006 4840 EE58 6100 03C0 4847 3010 4206 8046 30C0 E05E C046 6718 3F07
3F00 4857 4CEE 000F 0006 48E7 F000 548F 2050 4E90 2E1F 0806 0010 6706 7010 720E
6004 700C 720A 3D40 FFFE 2DAE 0004 1000 2C56 44C7 4CDF 1FFF DED7 4E75 7014 7212
60E4 4284 2A04 0240 000E 303B 0006 4EFB 00F2 0068 00F2 00C8 0068 001E 0026 002C
700F 3813 4844 602A 701F 2813 6024 703F 2813 2A2B 0004 6704 4A84 601A 0C84 8000
0000 660E 387C 7FFF 7814 4844 08C4 001E 606A 4A84 673A 6A08 08C6 0007 4485 4084
0640 3FFF 4A84 6B3A 6030 3013 6A08 08C6 0007 0880 000F 282B 0002 2A2B 0006 0C40
7FFF 6724 4A84 6B1A 4A84 660A 4A85 6606 99CC 5443 4E75 08C3 001F 5340 DA85 D984
6AF8 48C0 2840 4E75 387C 7FFF 0884 001F 4A84 6608 4A85 6604 5843 4E75 08C4 001E
6604 08C6 0008 5442 4E75 4280 2813 DC06 D884 E216 E19C 1004 6712 183C 0001 E29C
0C00 00FF 67C2 0640 3F80 60B6 303C 3F81 E29C 6094 2813 6A04 08C6 0007 2A2B 0004
E19D E79D E19C E99C 3004 E28C 0244 F800 3205 0241 07FF 8841 0245 F800 0240 07FF
6608 303C 3C01 6000 FF60 0C40 07FF 6700 FF78 08C4 001F 0640 3C00 6000 FF66 08C6
0008 4840 08C0 001E 2800 4285 387C 7FFF 6024 0C42 0002 671E 0C42 0004 6710 203C
00FF 0000 2209 C280 C084 B280 6F08 E31E 284B 2A0A 2809 0806 001A 671E 4284 7A01
E29D 0806 0018 6608 0806 0019 6608 4845 08C6 0008 4E75 C945 4E75 0806 0015 661A
0806 0014 6606 7002 6000 04E2 7001 0886 0008 6602 5240 6000 0712 0806 001F 6706
7A00 1805 600A 0806 001E 6704 0245 F800 2004 0880 001E 8085 6608 7815 4844 08C4
001E 4E75 DC06 2809 2A0A 284B 4E75 0C40 0042 6304 303C 0042 E28C E295 E257 55C1
8E01 5340 66F2 4E75 4A84 660C 4A85 6608 4A47 6604 99CC 4E75 4A84 6008 538C DE47
DB85 D984 6AF6 4A86 6B00 00C6 0806 001E 6600 00F6 97CB 611A 4281 7401 0805 0000
6120 367C 7FFE 616C 6706 284B 78FF 2A04 4E75 200B 908C 6E02 4E75 08C6 0009 284B
608C 56C0 4A47 6606 0886 0009 4E75 08C6 000C 0810 0005 670E 0810 0006 6702 4E75
4A06 6A1E 4E75 0810 0006 6610 0C47 8000 6402 4E75 620C 4A00 6608 4E75 4A06 6B02
4E75 08E8 0007 0001 DA82 D981 6404 E294 528C 4E75 B7CC 6D04 4240 4E75 08C6 000A
08C6 000C 387C 7FFF 4284 2A04 1210 0201 0060 6602 4E75 0C01 0060 6604 4A01 4E75
4A06 6B06 0C01 0020 4E75 0C01 0040 4E75 367C 3F81 6100 FF5C 4A85 56C0 8E00 D804
E257 8E04 4285 4204 223C 0000 0100 4282 0804 0008 6100 FF4C 367C 407E 6196 6706
284B 78FF 4204 4E75 367C 3C01 6100 FF24 303C 07FF C045 0245 F800 EB48 E24F 6404
08C7 0000 8E40 4281 243C 0000 0800 0805 000B 6100 FF0E 367C 43FE 6100 FF58 670A
284B 78FF 2A3C FFFF F800 4E75 0240 000E 303B 0010 266E 000A 360C 0C43 7FFF 4EFB
00EC 0032 0086 0060 0000 0024 0028 002C 3685 4E75 2685 4E75 26C4 2685 4E75 0806
0009 6718 4A43 6714 4A84 660E 4A85 6604 4283 6008 5343 DA85 D984 6AF8 4A06 6A04
0643 8000 36C3 26C4 2685 4E75 6606 363C 4080 6008 4A43 6604 363C 3F81 0443 3F80
D884 6502 5343 8843 E09C DC06 E294 2684 4E75 6606 363C 4400 6008 4A43 6604 363C
3C01 0443 3C00 4A84 6B02 5343 203C 0000 07FF C084 8A80 E09D E69D 0244 F800 D884
8843 E09C E69C DC06 E294 26C4 2685 4E75 0A06 00A0 363B 3006 4EFB 30FA 001A 0080
FDB8 0088 0066 FDB8 FDB0 FDB0 008C 2604 2809 CB8A 300C 904B 6712 6E0C CB8A C943
4440 284B DC06 E206 6100 FD84 0806 0005 6612 DA8A D983 6408 E294 E295 E257 528C
6000 FDA4 4606 9A8A 9983 6714 6408 4447 4085 4084 4606 6000 FD80 0806 0005 6712
99CC 4206 0810 0006 6708 0810 0005 6602 4606 4E75 2A0A 2809 284B DC06 6000 FD68
0806 0005 6602 4E75 7002 6000 FC72 E51E 7008 363B 3006 4EFB 30F6 001E FD1E FD1E
FD18 FD1E FC70 FD18 FC70 FD1E D9CB 98FC 3FFE 48E7 0680 2644 4284 2A04 2044 2217
6606 200A 6728 6012 200A 6130 4A85 56C7 2A04 4284 2217 2009 6122 220B 200A 611C
4A45 56C0 8E00 4845 8E45 2A04 2808 220B 2009 6108 4CDF 0141 6000 FCDE 3401 3601
C4C0 3C00 4840 4841 CCC1 C6C0 C2C0 4842 4280 3002 D680 D686 3403 4842 4243 D743
4843 D283 DA82 D981 6402 5248 4E75 E51E 7004 363B 3006 4EFB 30F6 0034 001E 002C
FC78 FBD0 FC78 FC78 FC78 FBD0 08C6 000B 387C 7FFF 4284 2A04 4E75 99CC 280C 2A04
4E75 C74C 99CB D8FC 3FFF 7041 4A86 6A02 7021 B889 6602 BA8A 6304 5240 538C 2209
240A 2604 2445 611A 4A86 6A04 2805 4285 44FC 0010 E294 E295 E257 8282 56C7 6000
FC46 4284 2A04 600A DA85 D984 D482 D381 6508 B283 6602 B48A 6506 5205 948A 9383
5340 66E4 4E75 426F 0006 DC06 7009 0286 3FFF FFFF 363B 3006 4EFB 30EC 0028 FB38
0030 FBE0 FB38 FBE0 FB38 FB38 FB38 200B 5480 908C 6E08 2809 2A0A 284B 6042 538C
2209 240A 2604 2445 6198 0805 0000 671C 4A81 660A 4A82 6606 0805 0001 6706 0846
0007 5445 C58A C343 948A 9383 E20D 0806 0006 6702 4405 4885 3F45 0006 2801 2A02
6000 FB86 363B 301C 4EBB 30FA 0C40 0002 660A 0806 0011 6704 08C6 0008 3E00 4847
4E75 0048 0030 0034 0034 0044 0034 0030 0030 003E DC06 4606 7000 4A06 6B02 7019
4E75 0806 0005 66F0 7004 4E75 0806 0005 66E6 B7CC 6E0E 6D0E B3C4 6208 6508 B5C5
67E6 6502 4606 7019 4A06 6A02 7000 4E75 4A43 6700 FB32 4E75 4A43 6702 4E75 6134
3450 6012 4A43 6702 4E75 6128 3450 08D0 0006 08D0 0005 6100 FB0E 308A 4A84 6B12
6608 4A85 6604 99CC 6008 538C DA85 D984 6AF8 4E75 4A86 6B0C 0806 001E 670C 7034
6000 000A 7017 6000 0004 703F 0640 3FFF 3200 908C 6E02 4E75 3841 6100 FA92 44FC
0000 4E75 0806 001A 6786 0C43 0002 6602 4E75 0C43 0004 6604 78FF 6010 61CC 6F0C
4281 7401 0805 0000 6100 FAD8 7201 E299 0806 0018 6608 0806 0019 6626 4841 4A84
6614 BA81 6210 6504 4A06 6A0A 4A06 6A04 4485 4084 4E75 2A01 08C6 0008 0886 000C
4E75 4A84 6AE6 4285 2801 60EC 0C43 0002 6602 4E75 7001 4A06 6B00 F964 0C43 0004
6602 4E75 300C E240 40C1 6402 5240 0640 1FFF 3840 2246 2447 2E05 2C04 4283 2403
DE87 DD86 D743 44C1 6506 DE87 DD86 D743 2002 2802 7A03 5343 7241 3641 4281 DE87
DD86 D783 D582 D341 DE87 DD86 D783 D582 D341 DA85 D984 D140 5345 9685 9584 9340
6408 D685 D584 D340 6002 5445 C18B 5340 C18B 66CA 2C09 2E0A 8282 8283 6602 5345
7203 E248 E294 E295 E257 5341 66F4 6000 F9B6 4206 0C43 0002 660E 0046 0880 387C
7FFF 4284 2A04 4E75 0C43 0004 6602 4E75 4285 98FC 3FFF 280C 6A06 0006 0080 4484
387C 401E 6000 F962 4A43 6702 4E75 266E 000E D8D3 6000 F970 7005 4A83 6B0A 670A
5540 0C43 0004 6702 5240 4A06 6702 4440 266E 000A 3680 4E75 4CEE 0600 000A 3E3B
7006 4EFB 70F4 002A 0034 0038 003E 01F2 055A 0044 004A 005E 0072 01D8 002E 01E4
0052 3091 6020 3290 4250 601A 3290 6016 2151 0002 6010 22A8 0002 600A 0851 0007
6004 0891 0007 6000 F6BA 3011 0110 56C0 4400 1280 60F0 0811 0007 6706 08D2 0007
6004 0892 0007 6000 F694 9EFC 0016 284F 3A06 0245 3800 5246 4846 4246 2F0A 486C
000A 700E 8045 3F00 6100 F56E 4294 42AC 0004 426C 0008 4854 486C 000A 3F3C 0008
6100 F556 56C4 2F09 4854 3F00 6100 F54A 4854 486C 000A 3F3C 0008 6100 F53C 6822
4854 486C 000A 3F3C 0004 6100 F52C 486C 000A 2F0A 7010 8045 3F00 6100 F51C 6000
0080 677C 6408 0812 0007 6708 607A 0812 0007 6774 0805 000C 6704 5292 6034 0805
000B 670A 52AA 0004 6402 5292 6024 52AA 0006 641E 52AA 0002 6418 E4EA 0002 5252
0C52 7FFF 6706 0C52 FFFF 6606 08AA 0007 0002 2F0A 486C 0014 701C 8045 3F00 6100
F4B8 322C 0014 6A02 4441 0C41 0003 6606 0046 1400 600A 0C41 0005 6704 0046 1200
DEFC 0016 6000 F568 0805 000C 6710 4A04 6608 0852 0007 5292 60B8 5392 60B4 0805
000B 6718 4A04 660A 0852 0007 526A 0006 60A0 53AA 0004 6402 5392 6096 4A04 660A
0852 0007 526A 0008 6088 53AA 0006 641C 53AA 0002 6B12 4A52 6712 0C52 8000 670C
066A 8000 0002 6002 6402 5352 6000 FF64 4846 4246 3011 5040 01C6 600A 4846 3C3C
1F00 CC50 3091 6000 F4E6 9EFC 0014 264F 49EA 0004 362A 0002 4846 4284 2A04 2E04
7413 1C1C 6768 1014 0C00 0049 6754 0C00 004E 6654 142C FFFF 528C 5302 7008 0C02
0004 6C04 5900 D002 610A 2805 4285 7008 6102 601E E99D 5302 6B12 121C 0C01 0039
6F04 0601 0009 0201 000F 8A01 5340 66E4 4E75 0284 7FFF FFFF 6608 7815 4844 08C4
001E 303C 7FFF 6008 0C00 0030 6628 4280 4A12 6704 08C0 000F 6100 0074 6000 0052
DA85 D984 2205 2004 DA85 D984 DA85 D984 DA81 D980 4E75 61E8 700F C01C DA80 4240
D980 5306 6716 5302 66EC 1E3C 000F CE14 600E 0C43 001B 6F08 61C6 5343 5342 66F2
303C 403E 4A12 6704 08C0 000F 6120 6128 4846 0246 3800 0046 0010 4853 2F2E 000A
3F06 6100 F314 DEFC 0014 6000 F410 36C0 26C4 2685 5D8B 4E75 1C10 1F06 0206 0060
670E 7240 4A13 6A0C 0C06 0040 670C 600E 1086 6014 0C06 0020 6604 0A01 0060 4A43
6A04 0A01 0060 1081 43EB 000A 6100 00F2 0010 0060 486B 000A 4853 7004 4A43 6A02
7006 3F00 6100 F2B2 0810 0004 56C0 4A07 56C7 8007 1210 0201 001F 821F 1081 4400
673E 08D0 0004 4A06 6728 0C06 0060 6730 2F3C 0000 0001 42A7 3F13 5357 6502 6802
5257 4857 4853 4267 6100 F26E DEFC 000A 600E 3013 5240 D040 6706 08EB 0000 0009
4E75 000E 0000 402D B5E6 20F4 8000 0000 001B 0000 4058 CECB 8F27 F420 0F3A 0037
0001 40B5 D0CF 4B50 CFE2 0766 006C 0001 4165 DA01 EE64 1A70 8DEA 00CE FFFF 42AB
9F79 A169 BD20 3E41 019C 0001 4557 C6B0 A096 A952 02BE 0338 0001 4AB0 9A35 B246
41D0 5953 0670 0001 5561 B9C9 4B7F A8D7 6515 0CE0 0001 6AC4 86D4 8D66 26C2 7EEC
7209 3003 6A02 4440 0C40 000F 6564 0C40 1388 6504 303C 1388 45FA FFD8 B052 654A
905A 4A52 673E 08D0 0004 0810 0006 6706 4A52 6F30 600A 0810 0005 6728 4A52 6C24
2F0A 3F2A 000A 4A5A 6A04 5257 6002 5357 2F2A 0004 2F12 244F 6120 508F 548F 245F
548A 6004 548A 6112 598A 94FC 000E 5341 66AA C0FC 000A 45FB 0024 4A81 6A0E 4852
4851 3F3C 0004 6100 F150 4E75 32DA 22DA 2292 5D89 5D8A 08C1 001F 4E75 3FFF 8000
0000 0000 0000 4002 A000 0000 0000 0000 4005 C800 0000 0000 0000 4008 FA00 0000
0000 0000 400C 9C40 0000 0000 0000 400F C350 0000 0000 0000 4012 F424 0000 0000
0000 4016 9896 8000 0000 0000 4019 BEBC 2000 0000 0000 401C EE6B 2800 0000 0000
4020 9502 F900 0000 0000 4023 BA43 B740 0000 0000 4026 E8D4 A510 0000 0000 402A
9184 E72A 0000 0000 402D B5E6 20F4 8000 0000 3006 ED58 4282 2602 2C02 2E02 264A
6100 F1C0 300C 286E 0012 9EFC 001E 264F E31E 1286 137C 0001 0004 4A42 6734 5889
12FC 0011 12FC 004E 610C 2805 6108 92FC 0016 6000 01DC 7008 E99C 720F C204 0001
0030 0C01 0039 6F02 5E01 12C1 5340 66E8 4E75 4A43 6712 7030 0C43 0002 6702 7049
1340 0005 6000 01AA 2204 3200 0441 3FFF 4841 D241 4A40 6A08 E28C E295 5240 6BF8
E25E 8046 6100 FD08 4284 4A14 662C 203C 4D10 4D42 4A81 6A02 5240 2800 4844 C8C1
4244 4844 4841 3A01 CBC0 4845 48C5 D885 4840 C1C1 D880 4844 5244 6100 0084 9644
226E 000A 3343 0002 4469 0002 3753 0014 276B 0002 0016 276B 0006 001A 6100 FCBA
4853 3F3C 0014 6100 EFB0 43EB 000A 4A14 6604 614C 6002 7613 6100 FDC6 3013 0880
000F B051 6612 202B 0002 B0A9 0002 6608 202B 0006 B0A9 0006 6540 4A14 6614 5244
36AB 0014 276B 0016 0002 276B 001A 0006 6088 226E 000A 137C 003F 0005 6000 00D2
362C 0002 4A14 6610 4A43 6F0A 0C43 0013 6F06 7613 6002 7601 4E75 4A14 6636 61E0
5343 6100 FD5C 3013 0880 000F B051 6612 202B 0002 B0A9 0002 6608 202B 0006 B0A9
0006 6410 3691 2769 0002 0002 2769 0006 0006 4E71 226E 000A 3613 222B 0002 660A
137C 0030 0005 6000 0068 242B 0006 0883 000F 0443 403E 6708 E289 E292 5243 6BF8
263C 8AC7 2304 247C 89E8 0000 7041 6100 F5D2 5285 D980 5889 2449 421A 7C13 DA85
D984 D140 2605 2404 3200 DA85 D984 D140 DA85 D984 D140 DA83 D982 D141 4A40 670C
0080 0000 0130 14C0 4200 5211 5306 66CE DEFC 001E 6000 EFA6
''')

pack5 = bytes.fromhex('''
600A 0000 5041 434B 0005 0001 4E56 FFD0 48E7 FFF8 4283 2078 0ACC 1D50 FFD0 08D0
0007 47EE 0004 41EE 0008 3618 6A48 2858 2810 0803 000E 6618 2093 36BC 000A 2A0C
740F 0C43 8010 6706 2044 6110 3400 6032 5888 2A10 2093 36BC 000E 60EC 4850 486E
FFFC 3F3C 001C A9EB 302E FFFC 6A06 4440 0040 8000 4E75 740F 2850 2093 36BC 0006
2A0C 2045 61D6 3200 486E FFFE 3F3C 0017 A9EB 5702 6C10 2045 224C 614C 2F04 4854
4267 A9EB 600E 5701 6C0E 2F05 4854 3F3C 000E A9EB 6000 030C 3003 0240 00FE 303B
0006 4EFB 00F4 013A 013A 013A 013A 0326 0326 03D6 03D6 04E6 0608 06F8 078E 08E8
093A 0A52 0B3C 0C80 22D8 22D8 3290 5189 4E75 3019 4851 4850 3F3C 000E A9EB 4852
4850 3F3C 0004 A9EB 5089 5489 4851 4850 4267 A9EB 5340 6EE6 5089 5489 4E75 7001
600A 7002 6006 7000 6002 7004 558F 4857 3F3C 0003 A9EB 0197 4857 3F3C 0001 A9EB
548F 4A00 4E75 7002 600E 7001 600A 7003 6006 7000 6002 7004 3F00 4857 3F3C 0015
A9EB 60DC 7003 600E 7001 600A 7002 6006 7000 6002 7004 3F00 4857 3F3C 001B A9EB
1017 60BC 3D7C 7FFF FFFA 47EE FFE6 2729 0006 2729 0002 3711 0893 0007 6144 6C16
487A 0C9A 4853 3F3C 0002 A9EB 4A11 6A04 446E FFFA 611E 612A 6C06 487A 0C80 6002
4853 486E FFFA 3F3C 2010 A9EB 4A11 6A04 446E FFFA 486E FFFA 4850 3F3C 2018 A9EB
4E75 486E FFDC 487A 0C54 3F3C 0008 A9EB 4E75 5301 6A0C 4A41 6A00 01A0 7024 6000
01B0 0803 0002 660A 4A01 671C 4A41 6BEC 605A 4A01 6700 01AC 4854 487A 0BF8 3F3C
0008 A9EB 62D6 6504 6000 0176 204C 43EE FFF0 6100 FEB4 487A 0BD2 4854 4267 A9EB
487A 0C7C 4854 3F3C 0008 A9EB 6F1E 4854 487A 0C62 3F3C 0008 A9EB 6310 2049 224C
6100 FE86 6100 007E 6000 0064 204C 43EE FFF0 6100 FE74 4851 3F3C 001A A9EB 0851
0007 204C 6100 FEFE 0851 0007 487A 0C26 4854 3F3C 0008 A9EB 6F00 001A 487A 0B6C
486E FFF0 4267 A9EB 487A 0B88 4854 3F3C 0006 A9EB 487A 0B54 4854 3F3C 0002 A9EB
6100 0022 486E FFF0 4854 4267 A9EB 0803 0001 660C 487A 0BFC 4854 3F3C 0004 A9EB
6000 00E0 4854 486E FFFA 3F3C 001C A9EB 302E FFFA 6A02 4440 5940 6602 4E75 5340
670A 487A 0BCE 6100 FE42 6064 204C 43EE FFE6 6100 FDD4 487A 0B1A 4854 4267 A9EB
4854 4851 3F3C 0006 A9EB 2049 4851 4851 43EE FFDC 6100 FDB2 3F3C 0004 A9EB 204C
43FA 0A20 45EE FFE6 6100 FDA8 486E FFDC 4854 3F3C 0004 A9EB 41EE FFDC 43FA 0A42
45EE FFE6 6100 FD8C 6100 FDB4 486E FFDC 4854 3F3C 0006 A9EB 6100 FDDC 4E75 41FA
0A9E 6024 41FA 0AA2 601E 41FA 0A7E 6018 41FA 0A82 6012 6100 FDB6 41FA 0AAA 6008
6100 FDAC 41FA 0AAA 224C 6100 FD3C 6012 0080 7FFF 4000 28C0 429C 4254 518C 6100
FD92 486E FFFE 3F3C 0019 A9EB 2078 0ACC 10AE FFD0 4CDF 1FFF 4E5E DED7 4E75 5301
67A8 6E06 4A41 6B96 60D8 0803 0001 6704 613A 601E 6100 0058 6100 FD72 6714 6100
FD56 4A41 6A94 6100 FD1A 6100 FD3E 6000 FF6E 6100 010E 487A 09F2 4854 4267 A9EB
204C 43EE FFF0 6100 FD5C 6096 204C 43EE FFF0 6100 FCB4 4851 3F3C 0014 A9EB 6100
FCEA 4851 4854 3F3C 0002 A9EB 4E75 204C 43EE FFF0 6100 FC92 487A 0A78 2F17 2F17
4854 3F3C 000C A9EB 4854 4851 3F3C 0002 A9EB 4851 3F3C 0006 A9EB 4851 3F3C 0014
A9EB 4854 3F3C 0006 A9EB 6000 FC9E 5301 6E0E 6700 0008 4A41 6B00 FEF6 6000 FF24
5301 0803 0001 6720 4A01 6716 487A 0A24 4854 3F3C 0004 A9EB 6100 FC90 6100 FC98
605C 6100 FF68 601E 4A01 66EC 6180 6100 FC9C 6712 6100 FC80 4A41 6A00 FEBE 6100
FC42 6000 FEAC 6100 003A 487A 0932 486E FFF0 3F3C 0008 A9EB 6724 487A 090E 4854
4267 A9EB 204C 43EE FFF0 6100 FC78 487A 08FA 4854 3F3C 0002 A9EB 6100 FC02 6000
FEA2 487A 08FA 4854 3F3C 0008 A9EB 6602 4E75 43EE FFDC 204C 6100 FBAE 4851 4851
3F3C 0004 A9EB 41EE FFE6 43FA 0874 45EE FFDC 6100 FB9E 486E FFE6 4854 3F3C 0004
A9EB 41EE FFE6 43FA 0882 45EE FFDC 6100 FB82 4854 486E FFE6 3F3C 0002 A9EB 487A
08B2 4854 3F3C 0004 A9EB 486E FFE6 4854 3F3C 0006 A9EB 6100 FBBE 6000 FB82 2044
3410 6700 FDE6 5301 6E26 E242 6504 0894 0007 D542 6A00 FE0C 4A01 6A0A 4A14 6A00
FDBE 6000 FDC0 4A14 6A00 FDCC 6000 FDD2 3002 6A02 4440 0C40 00FF 6206 612C 6000
FDE2 3F14 0894 0007 2F04 486E FFF0 2817 3F3C 200E A9EB 6100 0098 301F 6A08 E242
6404 08D4 0007 6000 FDBA 204C 43EE FFE6 6100 FAD6 614E 4A42 6B08 2049 224C 6000
FAC8 41FA 07E6 43D4 6100 FABE 6100 FB3A 6614 6100 FB38 660E 486E FFF0 4854 3F3C
0006 A9EB 4E75 6100 FADA 6100 FAD2 486E FFE6 4854 3F3C 0006 A9EB 3002 6A02 4440
6102 60B6 41FA 07A4 43EE FFF0 6100 FA7A 600A 4854 4854 3F3C 0004 A9EB E248 640A
4854 4851 3F3C 0004 A9EB 4A40 66E4 4E75 204C 43EE FFE6 6100 FA50 4851 3F3C 0002
6100 F95E 2F04 4851 3F3C 0004 A9EB 4851 3F3C 000A 6100 F94A 2049 224C 6000 FA2A
4A41 6B14 6100 0068 6000 FCF8 588F 6100 FA5A 7025 6000 FCDA 4A02 67F2 2044 43EE
FFF0 6100 FA04 4851 3F3C 0014 A9EB 6100 FA84 66DA 487A 073C 4851 3F3C 0006 A9EB
4851 3F3C 0014 A9EB 486E FFFA 3F3C 0003 A9EB 6100 FA16 0894 0007 6100 0012 082E
0004 FFFA 6704 0854 0007 6000 FC96 5301 661C 5302 6796 4A42 6A0A 6100 FA12 41FA
0706 6004 41FA 06D8 224C 6000 F99C 6A08 5302 6618 6000 FF76 5302 6A10 487A 06AC
4854 3F3C 0008 A9EB 6700 FF62 3C02 2F04 486E FFFC 3F3C 2010 A9EB 6100 F9F4 56C7
6100 F9A4 6100 F9EE 56C1 8E01 6612 342E FFFC 3002 6A02 4440 0C40 00FF 6F00 FE6C
6100 F988 6100 FEEA 4A06 6B00 F97E 4E75 487A 0662 2F05 3F3C 0008 A9EB 6D00 0082
6E00 0016 5302 6604 6000 FBC0 2044 4A10 6B00 FBC4 6000 FBA8 5302 67EC 6E0C 5301
675E B541 6BEE 6000 FBB2 43EE FFE6 2045 6100 F8F6 3011 0880 000F 0C40 3F7F 6D1C
4851 3F3C 0006 6100 F7F8 2F04 4851 3F3C 0004 A9EB 4851 3F3C 000A 6010 2F04 4851
3F3C 0004 A9EB 4851 3F3C 0008 6100 F8F0 6100 F7CE 2049 224C 6100 F8AE 6000 FB84
7026 6000 FB6C 487A 05CC 2F05 3F3C 0008 A9EB 6DEC 660E 5302 670E 4A42 6A00 FB38
6000 FB2E 5302 6604 6000 FB14 5301 6E28 6D0C 224C 2044 6100 F870 6000 FB46 4A42
6AE6 487A 0590 2F04 3F3C 0008 A9EB 67D0 6E00 FAF2 6000 FB0E 4A02 6A26 B541 6BD2
2045 43EE FFE6 6100 F840 4851 224C 41FA 055A 6100 F834 4851 3F3C 0006 A9EB 6000
FB02 43EE FFE6 2045 6100 F81E 3011 0880 000F 0C40 3F7F 6D2E 4851 3F3C 0006 6100
F720 2F04 4851 3F3C 0004 A9EB 0851 0007 0C51 4007 6D08 2045 0C50 407F 6C5C 4851
3F3C 000E 6014 2F04 4851 3F3C 0004 A9EB 0851 0007 4851 3F3C 000C 6100 F6E4 0851
0007 2F05 4851 3F3C 0006 A9EB 6100 F7F0 6100 F7F0 2049 6100 F724 5700 6606 6100
F806 6008 5500 6704 6100 F800 41EE FFE6 224C 6100 F794 6000 FA6A 2045 6100 F78A
4851 3F3C 0002 6100 F698 43EE FFDC 2044 6100 F776 487A 0494 4851 4267 A9EB 4851
43EE FFE6 4851 3F3C 0004 A9EB 0851 0007 4851 3F3C 000A 6100 F668 0851 0007 608C
7021 7400 5301 6700 FA1A 6B00 FA04 614E 0802 0000 6604 6156 6004 6100 00B8 0242
0003 5542 6B04 0854 0007 6100 F752 6100 F786 4854 486E FFFC 3F3C 001C A9EB 302E
FFFC 6A02 4440 5D40 6604 6100 F75E 6000 F9D2 7021 7401 5301 66B0 6000 F98E 487A
048C 4854 3F3C 000C A9EB D440 4E75 45FA 04EA 612E 4854 4852 3F3C 0004 A9EB 4852
4850 3F3C 0004 A9EB 4850 4854 3F3C 0002 A9EB 4E75 610C 4852 4850 3F3C 0004 A9EB
4E75 204C 43EE FFF0 6100 F69E 4851 4851 3F3C 0004 A9EB C34A 41EE FFDC 6100 F694
4850 41EE FFE6 6100 F68A 4850 3F3C 0006 A9EB 4E75 45FA 04D8 61BA 4852 4850 3F3C
0004 A9EB 487A 03DE 4852 3F3C 0008 A9EB 6E28 487A 03DA 4852 3F3C 0004 A9EB 4852
4850 3F3C 0002 A9EB 224C 6100 F63C 487A 035A 4854 4267 A9EB 4E75 0894 0007 487A
03AE 4854 3F3C 0002 A9EB 4850 204C 224A 6100 F616 487A 0398 4851 3F3C 0004 A9EB
4851 4854 3F3C 0004 A9EB 4854 3F3C 0002 A9EB 4851 4854 4267 A9EB 0854 0007 487A
0382 4854 4267 A9EB 4E75 7021 7400 5301 6B00 F89E 6700 F8AC 6100 FEE4 6134 E25A
642C 0854 0007 204C 43EE FFF0 6100 F5BA 4851 41FA 02D6 224C 6100 F5AE 4854 3F3C
0006 A9EB 6100 F61E 6704 0854 0007 6000 FE7A 45FA 044E 6100 FEDC 204C 43EE FFD2
6100 F586 4852 4851 3F3C 0004 A9EB 4851 41EE FFE6 4850 3F3C 0004 A9EB 487A 02E6
4852 3F3C 0008 A9EB 6E16 487A 02CE 4851 3F3C 0006 A9EB 4851 4850 4267 A9EB 604A
4850 204C 43EE FFDC 6100 F53E 487A 02CA 4851 3F3C 0002 A9EB 487A 02A0 4851 3F3C
0006 A9EB 4852 4851 3F3C 0004 A9EB 4851 4267 A9EB 487A 028E 4852 3F3C 0004 A9EB
4852 4851 4267 A9EB 2049 4850 4854 4267 A9EB 4E75 5301 6C10 41FA 0292 224C 6100
F4E8 4201 8354 6002 6604 6000 F7B6 0894 0007 6108 4201 8354 6000 FDB0 7400 487A
01EA 4854 3F3C 0008 A9EB 6320 74FF 204C 43EE FFF0 6100 F4B2 4851 41FA 01CE 224C
6100 F4A6 4851 3F3C 0006 A9EB 2F1C 2F1C 3F14 518C 487A 029A 4854 3F3C 0008 A9EB
6E16 45FA 0392 6100 FDDA 4850 4854 3F3C 0004 A9EB 6000 0098 204C 43EE FFF0 6100
F468 487A 0258 4851 3F3C 0004 A9EB 4851 41FA 0178 43EE FFDC 6100 F44E 4851 3F3C
0006 A9EB 487A 0164 4851 4267 A9EB 487A 015A 486E FFF0 4267 A9EB 487A 0220 4854
3F3C 0002 A9EB 204C 43EE FFD2 6100 F41A 486E FFF0 4854 3F3C 0006 A9EB 486E FFDC
4851 3F3C 0006 A9EB 45FA 030C 6100 FD54 4850 4854 3F3C 0004 A9EB 487A 01EA 4854
4267 A9EB 486E FFD2 4854 4267 A9EB 43EE FFF8 329F 231F 231F 4851 4854 3F3C 0002
A9EB 4A42 6606 0854 0007 4E75 487A 015E 4854 4267 A9EB 4E75 487A 0166 4854 3F3C
0004 A9EB 487A 0164 4854 3F3C 000C A9EB 4A14 6A0A 487A 0154 4854 4267 A9EB 6000
F662 0005 3FF6 B946 46AF F6CE 3BFF 3FF9 94F4 3221 4D61 FBEB 3FFB DC97 8903 D944
7893 3FFF 9F9E 3946 57CA 1D05 C001 CD6B C53A 46EC DC9A 4001 B483 97E7 BAE6 FCE0
0002 3FFF 8000 0000 0000 0000 C000 B818 35C3 CE0A 5E1D 3FFF FA3E DF0E DDF4 1A96
0003 BFEE FF88 90C8 1B20 9B79 3FF9 DA5C 84EF B813 272F 4003 97D3 BAEA F80F FD45
4009 AB86 71A1 95BE FF0C 0002 3FFF 8000 0000 0000 0000 4006 D548 7002 984B 5AB4
400A F775 612E 96B7 0780 3FFF 8000 0000 0000 0000 BFFF 8000 0000 0000 0000 0000
0000 0000 0000 0000 8000 0000 0000 0000 0000 4000 8000 0000 0000 0000 400D FFFE
0000 0000 0000 7FFF 0000 0000 0000 0000 FFFF 0000 0000 0000 0000 4000 C000 0000
0000 0000 3FFD 8000 0000 0000 0000 3FFE 8000 0000 0000 0000 3FFE C000 0000 0000
0000 3FFE E000 0000 0000 0000 3FFF C90F DAA2 2168 C235 3FFE C90F DAA2 2168 C235
400D 834E 0000 0000 0000 401D FFFF FFFE 0000 0000 3FFF B504 F333 F9DE 6484 3FFE
B504 F333 F9DE 6484 4000 ADF8 5458 A2BB 4A9B 3FFE B172 17F7 D1CF 79AC 3FFE 93CD
3A2C 8198 E26A 3FFA DC2A 86B1 5FDB 6462 3FFD 8930 A2F4 F66A B18A 0003 3FFF 8000
0000 0000 0000 4007 88D8 B844 A6A8 5A30 400E 8A15 8A49 0979 2320 4013 FAA9 FE26
FE63 F22B 0003 BFFE C250 86AE 43F5 CBF5 4006 9E76 EC66 BEE7 6BA2 C00C AF51 A1D6
C4C4 AA01 4011 A71B FEC4 A997 F6CE 0003 3FFF 8000 0000 0000 0000 4007 A6D9 6A95
FBDF 9685 400E C7A7 EA65 E85D 156B 4014 D26E 871C 7B17 52B2 0003 BFFB D57E 18D7
A6F6 D758 4003 E364 937E 32B3 D072 C00A A62D 4056 586B C045 4010 8C49 AF68 520F
8C7A 0003 BFFF 8000 0000 0000 0000 4005 B513 0324 83C0 0955 C009 D1FF B242 5762
E0CF 400A E190 9309 9376 66AB 0003 BFE9 B1FC 3363 D79B 2838 3FFD AA9D 71D8 3EC7
4CD1 C003 E9CD 8E24 B965 7DBB 4007 F09A 3670 9D4B 1836 0004 3FFF 98D3 1EAE 2AFA
5DAD 4003 8F79 4CD8 B3CD EFD9 4005 8E37 ED85 70B8 B368 4005 CDA4 BEA1 AC59 F3B8
4004 C405 9C55 4CF0 C656 0004 3FFF 8000 0000 0000 0000 4002 A23B 6C13 1F92 0E30
4003 C3C8 593D FA3A 486F 4003 82AE 6838 DDF5 D945 0000 0000 0000 0000 0000
''')

pack7 = bytes.fromhex('''
600A 0000 5041 434B 0007 0001 536F 0004 6A76 2F57 0002 544F 48E7 FE40 7200 7400
7600 7800 7A00 7C1F 43E8 0001 4A80 6E0E 6B06 12FC 0030 6028 12FC 002D 4480 D080
CB05 C904 C703 C502 C301 51CE FFF2 611E 1202 611A 1203 6116 1204 6112 1205 610E
3009 9048 5300 1080 4CDF 027F 4E75 E859 6102 E959 4A46 6A06 4A01 670A 7C00 0001
0030 12C1 9201 4E75 302F 0004 2F57 0002 544F 5340 6A3E 48E7 7080 7000 7200 7600
1418 672A 0C10 002B 6708 0C10 002D 6608 7601 5288 5302 6716 720F C218 D080 D280
E588 D081 5302 66F0 4A03 6702 4480 4CDF 010E 4E75 5340 6B0A 670C 0C40 0001 670A
4E75 4EFA 0010 4EFA 02A8 4EFA 0002 7201 E299 6002 7200 4E56 0000 48E7 3F30 4CEE
0070 000C CCB8 031A 2046 2245 7C00 1C10 47F0 6000 D0D1 2C08 2244 45E9 0004 2801
0604 0030 7E39 7000 7200 7400 7600 7A00 4291 24BC 054E 3030 357C 3131 0004 6100
008A 0C00 0020 67F6 0C00 00CA 67F0 0C00 0009 67EA 0C00 002B 6708 0C00 002D 6604
5211 6166 0C00 0030 650C 621C 08C4 000F 7CFF 6156 60EE 0C00 002E 6700 0074 4A44
6A00 01B0 6000 00E4 0C00 0039 630A 4A44 6A00 0130 6000 0086 7CFF 6118 6506 0C00
0039 63F6 0C00 002E 6600 0072 611C 6500 00BA 6062 0C02 0013 6D04 6E0A 5241 528A
1480 5202 6004 8112 5241 4A84 6A06 1018 6710 6006 B7C8 6D08 1018 0C00 0030 4E75
5288 08C4 0010 4A86 6A00 0148 6000 007C 61D8 6710 6506 0C00 0039 6312 4A44 6A00
0132 6018 08C4 000F 7CFF 5341 60E2 7CFF 5341 61A0 6554 0C00 0039 63F2 2C08 5386
0C00 0045 6706 0C00 0065 663E 619C 0C00 002B 670A 0C00 002D 6606 08C2 001F 618A
0C00 0030 651E 0C00 0039 6218 7CFF 0240 000F CAFC 000A DA40 0C45 2000 6504 3A3C
2000 60DA 4A86 6A00 00CA 5388 4A02 660A 4A44 6A2A 34BC 0130 6024 4A82 6A02 4445
0C31 0030 2004 660C 5302 0C02 0013 6702 5245 60EC 1342 0004 DA41 3345 0002 91EE
0014 226E 0010 3288 206E 0004 226E 0008 4844 1284 4CEE 0CFC FFE0 4E5E DEFC 0014
4ED0 0C00 00B0 6700 007C 5388 7649 6100 0094 6700 0064 0C00 004E 6656 7641 6100
0084 664E 764E 6100 007C 6600 0046 24FC 054E 3430 34BC 3030 2C08 6100 FECE 0C00
0028 662E 7600 6100 FEC2 6512 0C00 0039 6220 C6FC 000A 0240 000F D640 60E8 0C00
0029 660E 6156 E058 E81B 6150 E058 3480 6016 2046 6000 FF36 764E 6128 66F4 7646
6122 66EE 34BC 0149 7CFF 4A84 6A08 1010 6600 FF4C 6006 B7C8 6C00 FF44 08C4 0010
6000 FF3C 6100 FE64 0C00 0061 650A 0C00 007A 6204 0400 0020 B003 4E75 103C 000F
C003 0C00 0009 6302 5E00 0600 0030 4E75 48E7 3C00 4E56 0000 206E 0020 2A10 206E
0018 226E 001C 2819 5248 74B0 7200 1219 671E 0804 0018 6706 10FC 002D 600A 0805
0018 6606 10FC 0020 5242 1011 0C00 003F 6700 00FE 0000 0020 0C00 0069 6700 0150
0C00 006E 6646 10FC 004E 10FC 0041 10FC 004E 10FC 0028 117C 0029 0003 5A42 7600
0C01 0005 6F02 7205 610C 2003 6108 E903 8680 7004 6068 5341 6FF8 1631 1000 0C03
0039 6F02 5F03 0203 000F 4E75 0C11 0030 6604 7201 7800 0805 0018 6600 009E 4A45
6E02 7A01 7001 6162 3601 48C3 5383 6E06 0C45 0001 6F0C 6160 3003 614E 3005 9041
6168 5442 6E6A 10FC 0065 48C4 D684 6D06 10FC 002B 6006 10FC 002D 4483 7000 43FA
00BE 5440 B671 00FE 6518 0C00 0008 6DF2 86F1 00FE 5242 6E38 0643 0030 10C3 4843
48C3 5540 6EEA 67EC 606E 6F0A D440 6E20 10D9 5340 6EFA 4E75 5242 6E14 10FC 002E
4E75 5242 6E0A 10FC 0030 5340 6CF4 4E75 206E 0018 30BC 013F 6048 3601 D644 6F22
4A44 6C0C 3003 61C2 61CE 7000 9044 6020 3001 61B6 3004 61D2 3005 6F1C 61BA 61CA
6016 7001 61C4 61B0 7000 9043 61BC 3001 6198 3004 D045 61B2 206E 0018 0642 0050
1082 4E5E 4CDF 013C DEFC 000C 4ED0 10FC 0049 10FC 004E 10BC 0046 5642 60DA 000A
0064 03E8 2710
''')

########################################################################
# Resources! At least we can be slow when dealing with them.
########################################################################

import re # the below code could be turned into one giant regex if we were brave

rez_tokens = [
    ((),         r'(\s|//.*?\n|/\*.*?\*/)+'),                                   # 0 whitespace/comment (gets ignored)
    ((1,11),     r'\$"\s*((?:[0-9A-Fa-f]{2}\s*)*)"'),                           # 1 hex data
    ((3,),       r'(data)'),                                                    # 2 start of raw resource
    ((4,),       r"('(?:[^'\\]|\\0x[0-9A-Fa-f]{2}|\\[\\'\\?btrvfn])*')"),       # 3 type
    ((5,),       r'(\()'),                                                      # 4 start of bracketed resource info
    ((6,7,8,9),  r'(-?\d+)'),                                                   # 5 ID
    ((7,8,9),    r',gap("(?:[^"\\]|\\0x[0-9A-Fa-f]{2}|\\[\\"\\?btrvfn])*")'),   # 6 name
    ((9,),       r',gap\$([0-9a-fA-F]{1,2})'),                                  # 7 attribs (hex)
    ((8,9),      r',gap(sysheap|purgeable|locked|protected|preload)'),          # 8 attribs (specific)
    ((10,),      r'(\))'),                                                      # 9 end of bracketed resource info
    ((1,11),     r'(\{)'),                                                      # 10 start of hex block
    ((12,),      r'(\})'),                                                      # 11 end of hex block
    ((2,-1),     r'(;)'),                                                       # 12 the end for real
    ((),         r'(.)'),                                                       # 13 unexpected character (always errors)
]

allowed_to_follow_kind, token_regexen = zip(*rez_tokens)

# The 'gap' hack turns ', sysheap' etc into a single token
gap = r'(?:\s|//.*?\n|/\*.*?\*/)*'
rez_tokenizer = '|'.join(token_regexen).replace('gap', gap).encode('ascii')
rez_tokenizer = re.compile(rez_tokenizer)

def string_surrogate(m):
    m = m.group(0)

    if len(m) == 5: # \0xFF is the most common
        return bytes([int(m[3:], 16)])
    elif m == b'\\"':
        return b'"'
    elif m == b"\\'":
        return b"'"
    elif m == b'\\b':
        return b'\x08' # backspace
    elif m == b'\\t':
        return b'\t'
    elif m == b'\\r':
        return b'\n'
    elif m == b'\\v':
        return b'\x0b' # vertical tab
    elif m == b'\\f':
        return b'\x0c' # form feed
    elif m == b'\\n':
        return b'\r'
    elif m == b'\\?':
        return b'\x7f' # del

def string_literal(string):
    return re.sub(rb'(\\0x..|\\.)', string_surrogate, string[1:-1])

def readrez(path):
    # lifted from my macresources package, but a little bit 'nastier'
    # returns a list of [type, id, name, flags, data]'s
    retval = []

    with open(path, 'rb') as f: from_rezcode = f.read()
    from_rezcode = from_rezcode.replace(b'\r\n', b'\n').replace(b'\r', b'\n')

    # Slightly faster than finditer
    all_tokens = rez_tokenizer.findall(from_rezcode)
    def line_no_for_error(token_idx):
        # Redo all the lexing with finditer, which is slower but
        # gives us Match objects with a byte offset
        work_redoer = rez_tokenizer.finditer(from_rezcode)
        match_obj = next(m for i, m in enumerate(work_redoer) if i == token_idx)
        line_no = from_rezcode[:match_obj.start()].count(ord('\n')) + 1

    allowed_token_kinds = (2,-1)
    for token_idx, token_captures in enumerate(all_tokens):
        # Which single capture is non-empty?
        for token_kind, payload in enumerate(token_captures):
            if payload: break

        # Ignore whitespace
        if not token_kind: continue

        # Unexpected token!
        if token_kind not in allowed_token_kinds:
            raise ValueError('File %r, line %r' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 1:
            hex_accum.append(payload)

        elif token_kind == 2:
            res = [b'type', 9999, None, 0, b'']; retval.append(res)
            hex_accum = []

        elif token_kind == 3:
            res[0] = string_literal(payload)
            if len(res[0]) != 4:
                raise ValueError('File %r, line %r, type not 4 chars' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 5:
            res[1] = int(payload)
            if not (-32768 <= res[1] < 32767):
                raise ValueError('File %r, line %r, ID out of 16-bit range' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 6:
            res[2] = string_literal(payload)
            if len(res[2]) > 255:
                raise ValueError('File %r, line %r, name > 255 chars' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 7:
            res[3] = int(payload, 16)

        elif token_kind == 8:
            if payload == b'sysheap':
                res[3] |= 0x40
            elif payload == b'purgeable':
                res[3] |= 0x20
            elif payload == b'locked':
                res[3] |= 0x10
            elif payload == b'protected':
                res[3] |= 0x08
            elif payload == b'preload':
                res[3] |= 0x04

        elif token_kind == 12:
            res[4] = bytes.fromhex(b''.join(hex_accum).decode('ascii'))

        allowed_token_kinds = allowed_to_follow_kind[token_kind]

    # Premature EOF
    if -1 not in allowed_token_kinds:
        raise ValueError('File %r, unexpected end of file' % original_file)

    return retval

########################################################################
# Filesystem access, used by both the Toolbox and MPW code
########################################################################

import sys
import os
from os import path

def path_to_native(s):
    try:
        s = s.decode('mac_roman')
    except AttributeError:
        pass

    if path.__name__ == 'posixpath': # gives faithful but quite verbose paths
        # Expand repeated separators to ..
        while '::' in s: s = s.replace('::', ':..:')

        # Reverse the meaning of leading separator from 'relative' to 'absolute'
        if s.startswith(':'): # explicitly relative, with leading :
            s = '.' + s
        elif ':' not in s: # implicitly relative, with no :
            pass
        else: # absolute, with : but no leading :
            s = ':' + s

        # Swap separators
        s = ''.join((':' if c == path.sep else path.sep if c == ':' else c) for c in s)

        return s

    else:
        raise NotImplementedError(path.__name__)

def normcase(x): # only fail if path is ambiguous
    elements = [] # make a list of separators and non-separator runs
    for char in x:
        if len(elements) == 0 or (elements[-1][-1] == path.sep) != (char == path.sep):
            elements.append('')

        elements[-1] += char

    y = ''
    for el in elements:
        if el[0] == path.sep:
            y += el
        else:
            if el in '..':
                y += el
                continue

            possibles = os.listdir(y or '.')

            if el in possibles:
                y += el
                continue

            possibles = [p for p in possibles if p.lower() == el.lower()]

            if len(possibles) == 0:
                return y + x[len(y):] # bail out

            if len(possibles) > 1:
                raise FileNotFoundError('%r could refer to any of %r' % (y + el, possibles))

            y += possibles[0]

    return y

# We do *not* pass through the nuances of system calls to the underlying OS.
# Instead, use the well-tested Python technique of slurping a whole binary file,
# and blatting it out when we are done.
# This lets us do whole-file heuristics and avoid funky ioctl interfaces.
# It might also be faster?
# Remember that we need to do atexit stuff too.

def get_typecreator(f):
    try:
        with open(f + '.idump', 'rb') as f:
            t = f.read(4)
            if len(t) != 4: t = b'????'
            c = f.read(4)
            if len(c) != 4: c = b'????'
            return t, c
    except FileNotFoundError:
        return b'????', b'????'

def set_typecreator(f, t=None, c=None):
    try:
        with open(f + '.idump', 'w+b') as f:
            if t:
                f.write(t)
            if c:
                f.seek(4)
                f.write(c)
    except FileNotFoundError:
        pass

refnums = []

# Reimplement Unix io syscall interface atop Python
# Slurp and blat all files wholesale

def text_to_native(x):
    return x.decode('mac_roman').encode('utf8').replace(b'\r', b'\n') # can't fail

def text_to_mac(x):
    try:
        return x.decode('utf8').encode('mac_roman').replace(b'\n', b'\r')
    except UnicodeError:
        return x

# MPW open() and OS PBOpen() call me
def macopen(macname, readable=False, writable=False, exclusive=False, create=False, append=False, truncate=False, rsrcfork=False):
    fname = macname

    # Hack to allow resource forks to be copied wholesale
    if rsrcfork: fname = path.readlink(fname) + '.rdump'

    # Will error out if the path is ambiguous
    fname = normcase(path_to_native(fname))

    if exclusive and path.exists(fname): raise FileExistsError(fname)
    if not create and not path.exists(fname): raise FileNotFoundError(fname)

    if readable and writable:
        mode = 'r+'
    elif readable:
        mode = 'r'
    elif writable:
        mode = 'w'
    else: raise ValueError(macname, 'neither readable nor writable')

    if fname.startswith('/dev/'):
        f = open(fname, mode, encoding='utf8')
    else:
        f = open(fname, mode + 'b')

    refnums.append(f)

    f.__mpw_name = macname
    f.__mpw_mark = 0
    f.__mpw_append = append

    f.__mpw_contents = bytearray() if (truncate or not readable or fname.startswith('/dev/')) else bytearray(f.read())

    # Make our own decision about textfiles
    ftype = get_typecreator(fname)[0]
    if ftype in (b'TEXT', b'ttro') or (ftype == b'????' and not fname.endswith(('.o', '.x'))):
        f.__mpw_contents[:] = text_to_mac(f.__mpw_contents)

    return len(refnums) - 1

macopen('Dev:StdIn', readable=True) # this is hacky but maybe can stay?
macopen('Dev:StdOut', writable=True)
macopen('Dev:StdErr', writable=True)

def macclose(refnum):
    file = refnums[refnum]
    if file is None: return
    refnums[refnum] = None
    if file in refnums: return # rudimentary refcount

    if file.writable():
        file.seek(0)
        file.write(file.__mpw_contents)
        file.truncate()

    file.close()

def macwrite(refnum, writewhat):
    file = refnums[refnum]

    if file.name.startswith('/dev/'):
        file.write(writewhat.decode('mac_roman').replace('\r', '\n'))
        return

    if file.__mpw_append: __mpw_mark = len(file.__mpw_contents)
    while len(file.__mpw_contents) < file.__mpw_mark: file.__mpw_contents.append(0)
    file.__mpw_contents[file.__mpw_mark:file.__mpw_mark+len(writewhat)] = writewhat
    file.__mpw_mark += len(writewhat)

def macread(refnum, howmuch):
    file = refnums[refnum]

    if file.name.startswith('/dev/'):
        return file.read(howmuch).replace('\n', '\r').encode('mac_roman')

    retval = file.__mpw_contents[file.__mpw_mark:file.__mpw_mark+howmuch]
    file.__mpw_mark += len(retval)
    return retval

def macdelete(f):
    import shutil
    f = normcase(path_to_native(f))
    for f in (f, f + '.idump', f + '.rdump'):
        try:
            shutil.rmtree(f)
        except FileNotFoundError:
            pass

########################################################################
# The Macintosh Toolbox. Wish me luck...
########################################################################

os_traps = {}
toolbox_traps = {}
ftrap_table_addr = 0xb0000 # every permutation of f-trap

# File Manager OS traps

def open_trap(trap, d0, a0, a1):
    ioNamePtr = read(4, a0 + 18)
    ioVRefNum = read(2, a0 + 22)
    ioPermssn = read(1, a0 + 27)

    name = mem[ioNamePtr+1:ioNamePtr+1+mem[ioNamePtr]].decode('mac_roman')
#     print('PBOpen', hex(ioNamePtr), mem[ioNamePtr:ioNamePtr+32].hex(), mem[ioNamePtr:ioNamePtr+32])

    try:
        if name.startswith('.'): raise FileNotFoundError # driver open
        refnum = macopen(name,
            readable=ioPermssn in (0, 1, 3, 4),
            writable=ioPermssn in (0, 2, 3, 4),
            )
        write(2, a0 + 24, refnum) # ioRefNum
    except FileNotFoundError:
        raise
        retval = -43 # fnfErr
    else:
        retval = 0

    write(2, a0 + 16, retval) # ioResult
    return retval, 'completionroutine'

os_traps[0] = open_trap

def close_trap(trap, d0, a0, a1):
    ioRefNum = read(2, a0 + 24)
    macclose(ioRefNum)
    write(2, a0 + 16, 0) # ioResult
    return 0, 'completionroutine'

os_traps[1] = close_trap

def seek_refnum(ioRefNum, ioPosMode, ioPosOffset):
    f = refnums[ioRefNum]

    if ioPosMode == 0: # fsAtMark
        pass
    elif ioPosMode == 1: # fsFromStart
        f.__mpw_mark = ioPosOffset
    elif ioPosMode == 2: # fsFromLEOF
        f.__mpw_mark = len(fs.__mpw_contents) + ioPosOffset
    elif ioPosMode == 3: # fsFromMark
        f.__mpw_mark += ioPosOffset

    f.__mpw_mark = min(f.__mpw_mark, len(f.__mpw_contents))
    f.__mpw_mark = max(f.__mpw_mark, 0)

def read_trap(trap, d0, a0, a1):
    ioRefNum = read(2, a0 + 24)
    ioBuffer = read(4, a0 + 32)
    ioReqCount = read(4, a0 + 36)
    ioPosMode = read(2, a0 + 44)
    ioPosOffset = read(2, a0 + 44, signed=True)

    f = refnums[ioRefNum]
    seek_refnum(ioRefNum, ioPosMode, ioPosOffset)

    data = macread(ioRefNum, ioReqCount)

    mem[ioBuffer:ioBuffer+len(data)] = data
    write(4, a0 + 40, len(data)) # ioActCount
    write(4, a0 + 46, f.__mpw_mark) # ioPosOffset

    retval = -39 if len(data) < ioReqCount else 0 # eofErr or noErr
    write(2, a0 + 16, retval) # ioResult
    return retval, 'completionroutine'

os_traps[2] = read_trap

def write_trap(trap, d0, a0, a1):
    ioRefNum = read(2, a0 + 24)
    ioBuffer = read(4, a0 + 32)
    ioReqCount = read(4, a0 + 36)
    ioPosMode = read(2, a0 + 44)
    ioPosOffset = read(2, a0 + 44, signed=True)

    f = refnums[ioRefNum]
    seek_refnum(ioRefNum, ioPosMode, ioPosOffset)

    macwrite(ioRefNum, mem[ioBuffer:ioBuffer+ioReqCount])

    write(4, a0 + 40, ioReqCount) # ioActCount
    write(4, a0 + 46, f.__mpw_mark) # ioPosOffset

    write(2, a0 + 16, 0) # ioResult
    return 0, 'completionroutine'

os_traps[3] = write_trap

def create_trap(trap, d0, a0, a1):
    ioNamePtr = read(4, a0 + 18)
    ioVRefNum = read(2, a0 + 22)

    name = mem[ioNamePtr+1:ioNamePtr+1+mem[ioNamePtr]].decode('mac_roman')
    name = normcase(path_to_native(name))
    try:
        with open(name, 'xb') as f: pass
        retval = 0
    except FileNotFoundError:
        retval = -35 # nsvErr
    except FileExistsError:
        retval = -48 # dupFNErr

    write(2, a0 + 16, retval) # ioResult
    return retval, 'completionroutine'

os_traps[8] = create_trap

def delete_trap(trap, d0, a0, a1):
    ioNamePtr = read(4, a0 + 18)

    name = mem[ioNamePtr+1:ioNamePtr+1+mem[ioNamePtr]].decode('mac_roman')
    name = normcase(path_to_native(name))
    try:
        for ext in ('', '.idump', '.rdump'):
            os.remove(name + ext)
    except FileNotFoundError:
        pass

    write(2, a0 + 16, 0) # ioResult
    return 0, 'completionroutine'

os_traps[9] = delete_trap

def getfinfo_trap(trap, d0, a0, a1):
    ioNamePtr = read(4, a0 + 18)
    ioVRefNum = read(2, a0 + 22) # ignore, until I implement WD refnums
    ioFDirIndex = read(2, a0 + 28, signed=True) # also probably ignore?

    if ioFDirIndex >= 1: raise NotImplementedError('_GetFInfo with ioFDirIndex')

    name = mem[ioNamePtr+1:ioNamePtr+1+mem[ioNamePtr]].decode('mac_roman')
    name = normcase(path_to_native(name))

    write(50, a0 + 30, 0) # zero out all those fields

    if path.exists(name):
        t, c = get_typecreator(name)
        mem[a0+32:a0+40] = t + c
        # should probably get some other info
        retval = 0
    else:
        retval = -43 # fnfErr

    write(2, a0 + 16, retval) # ioResult
    return retval, 'completionroutine'

os_traps[0xc] = getfinfo_trap

def setfinfo_trap(trap, d0, a0, a1):
    ioNamePtr = read(4, a0 + 18)
    ioVRefNum = read(2, a0 + 22) # ignore, until I implement WD refnums

    name = mem[ioNamePtr+1:ioNamePtr+1+mem[ioNamePtr]].decode('mac_roman')
    name = normcase(path_to_native(name))

    write(50, a0 + 30, 0) # zero out all those fields

    if path.exists(name):
        set_typecreator(name, mem[a0+32:a0+36], mem[a0+36:a0+40])
        retval = 0
    else:
        retval = -43 # fnfErr

    write(2, a0 + 16, retval) # ioResult
    return retval, 'completionroutine'

os_traps[0xd] = setfinfo_trap

def seteof_trap(trap, d0, a0, a1):
    refnum = read(2, a0 + 24)
    try:
        f = refnums[refnum]
        f.__mpw_mark
        f.__mpw_mark = read(4, a0 + 28)
        del f.__mpw_contents[f.__mpw_mark:] # shorten
        f.__mpw_contents.extend(bytes(f.__mpw_mark - len(f.__mpw_contents))) # lengthen
        retval = 0
    except (IndexError, AttributeError):
        retval = -51 # rfNumErr

    write(2, a0 + 16, retval) # ioResult
    return retval, 'completionroutine'

os_traps[0x12] = seteof_trap

def flushvol_trap(trap, d0, a0, a1):
    write(2, a0 + 16, 0) # ioResult
    return 0, 'completionroutine'

os_traps[0x13] = flushvol_trap

def fsdispatch_trap(trap, d0, a0, a1):
    d0 &= 0xffff # word-size selector
    if d0 == 0: # FSControl
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 1: # OpenWD
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 2: # CloseWD
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 5: # CatMove
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 6: # DirCreate
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 7: # GetWDInfo
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 8: # GetFCBInfo
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 9: # GetCatInfo
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 10: # SetCatInfo
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 11: # SetVolInfo
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 12: # SetPMSP
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 13: # SetupWDCB
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 14: # SetupDef
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 15: # ReadWDCB
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 16: # LockRng
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 17: # UnlockRng
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 20: # CreateFileIDRef
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 21: # DeleteFileIDRef
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 22: # ResolveFileIDRef
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 23: # ExchangeFiles
        raise NotImplementedError('fsdispatch', d0)
    elif d0 == 26: # OpenDF
        return open_trap(trap, d0, a0, a1)
    elif d0 == 27: # MakeFSSpec
        raise NotImplementedError('fsdispatch', d0)
    else: # probably Desktop Manager stuff, ignore for now
        raise NotImplementedError('fsdispatch', d0)

    write(2, a0 + 16, 0) # ioResult
    return 0, 'completionroutine'

os_traps[0x60] = fsdispatch_trap

# Memory Manager OS traps

heap_blocks = {} # addr: size
master_ptrs = {}

# os_traps[0x19] = initzone_trap

def zone_nop_trap(trap, d0, a0, a1):
    return 0, 0

os_traps[0x1a] = zone_nop_trap # _GetZone
os_traps[0x1b] = zone_nop_trap # _SetZone

def freemem_trap(trap, d0, a0, a1):
    return 0x7ffffffe, 0 # d0=free, a0=growable (MaxMem only)

os_traps[0x1c] = freemem_trap
os_traps[0x1d] = freemem_trap

def newptr(size): # fixed 16b header before all "heap" blocks
    mem.extend(bytes(0x20000))
    while len(mem) % 16: mem.append(0)
    mem.extend(bytes(16 + size))
    retval = len(mem) - size
    heap_blocks[retval] = size
    return retval

def newptr_trap(trap, d0, a0, a1):
    return 0, newptr(d0) # a0,d0
os_traps[0x1e] = newptr_trap

def disposptr(ptr):
    try:
        del heap_blocks[ptr]
    except:
        pass

def disposptr_trap(trap, d0, a0, a1):
    disposptr(a0)
    return 0, 0
os_traps[0x1f] = disposptr_trap

def setptrsize(ptr, size):
    if heap_blocks[ptr] >= size:
        heap_blocks[ptr] = size
        return True
    else:
        return False # failure

def setptrsize_trap(trap, d0, a0, a1):
    if setptrsize(a0, d0):
        return 0, 0 # noErr
    else:
        return -108, 0 # memFullErr
os_traps[0x20] = setptrsize_trap

def getptrsize(ptr):
    return heap_blocks[ptr]

def getptrsize_trap(trap, d0, a0, a1):
    return getptrsize(ptr), 0
os_traps[0x21] = getptrsize_trap

def newhandle(size):
    ptr = newptr(size)
    write(4, ptr - 4, ptr)
    write(4, ptr - 8, 0xFA7B175) # FatBits
    master_ptrs[ptr] = ptr - 4
    return ptr - 4 # a handle points to its owning pointer

def newhandle_trap(trap, d0, a0, a1):
    return 0, newhandle(d0)
os_traps[0x22] = newhandle_trap

def disposhandle(handle):
    try:
        ptr = read(4, handle)
        if not ptr: return
        disposptr(ptr)
    except:
        pass

def disposhandle_trap(trap, d0, a0, a1):
    disposhandle(a0)
    return 0, 0
os_traps[0x23] = disposhandle_trap

def sethandlesize(handle, size):
    ptr = read(4, handle)
    oldsize = heap_blocks[ptr] if ptr else 0
    if oldsize >= size:
        # can shrink the handle
        heap_blocks[ptr] = size
    else:
        ptr2 = newptr(size)
        del master_ptrs[ptr]
        master_ptrs[ptr2] = handle
        mem[ptr2:ptr2+oldsize] = mem[ptr:ptr+oldsize]
        disposptr(ptr)
        write(4, handle, ptr2)

def sethandlesize_trap(trap, d0, a0, a1):
    sethandlesize(a0, d0)
    return 0, 0
os_traps[0x24] = sethandlesize_trap

def gethandlesize(handle):
    ptr = read(4, handle)
    return heap_blocks[ptr] if ptr else 0

def gethandlesize_trap(trap, d0, a0, a1):
    return gethandlesize(a0), 0
os_traps[0x25] = gethandlesize_trap

def handlezone_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x26] = handlezone_trap

def reallochandle(handle, size):
    emptyhandle(handle)
    sethandlesize(handle, size)

def reallochandle_trap(trap, d0, a0, a1):
    reallochandle(a0, d0)
    return 0, 0
os_traps[0x27] = reallochandle_trap

def recoverhandle(ptr):
    return master_ptrs[ptr]

def recoverhandle_trap(trap, d0, a0, a1):
    return 0, recoverhandle(a0)
os_traps[0x28] = recoverhandle_trap

def hlock_nop_trap(trap, d0, a0, a1):
    return d0, a0
os_traps[0x29] = hlock_nop_trap # _HLock
os_traps[0x2a] = hlock_nop_trap # _HUnlock

def emptyhandle(handle):
    ptr = read(4, handle)
    del master_ptrs[ptr]
    disposptr(ptr)
    write(4, handle, 0)

def emptyhandle_trap(trap, d0, a0, a1):
    emptyhandle(a0)
    return 0, 0
os_traps[0x2b] = emptyhandle_trap

def initapplzone_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x2c] = initapplzone_trap

def setappllimit_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x2d] = setappllimit_trap

def blockmove(src, dest, size):
    shouldbe = len(mem)
    mem[dest:dest+size] = mem[src:src+size]
    if len(mem) != shouldbe: raise ValueError('hopelessly corrupted memory')

def blockmove_trap(trap, d0, a0, a1):
    blockmove(a0, a1, d0)
    return 0, 0
os_traps[0x2e] = blockmove_trap

def resrvmem_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x40] = resrvmem_trap

def stripaddress_trap(trap, d0, a0, a1):
    if len(mem) <= 0x1000000:
        d0 &= 0xffffff
    return d0, 0
os_traps[0x55] = stripaddress_trap

def movehhi_trap(trap, d0, a0, a1):
    return 0, 0
os_traps[0x64] = movehhi_trap

# Trap Manager OS traps

# For historical reasons, unflagged Get/SetTrapAddress need to guess between OS/TB traps
def trap_kind(trapnum, flags):
    if flags & 0x200: # newOS/newTool trap
        if flags & 0x400: return trapnum & 0x3ff, 'toolbox'
        else: return trapnum & 0xff, 'os'
    else: # guess, using traditional trap numbering
        trapnum &= 0x1ff # 64k ROM had a single 512-entry trap table
        if trapnum <= 0x4f or trapnum in (0x54, 0x57): return trapnum, 'os'
        else: return trapnum, 'toolbox'

def gettrapaddress_trap(trap, d0, a0, a1):
    trapnum, trapkind = trap_kind(d0, trap)
    traplist = os_trap_table if trapkind == 'os' else toolbox_trap_table
    return 0, traplist[trapnum]
os_traps[0x46] = gettrapaddress_trap

def settrapaddress_trap(trap, d0, a0, a1):
    trapnum, trapkind = trap_kind(d0, trap)
    traplist = os_trap_table if trapkind == 'os' else toolbox_trap_table
    return 0, 0
os_traps[0x47] = settrapaddress_trap

# Resource Manager Toolbox traps

def getresource(type, id='', name=-1, topmap=False): # defaults are chosen to NEVER match
    for file in reversed(resource_chain):
        for resource in file:
            thistype, thisid, thisname, thisflags, thisdata, *thishandle = resource
            if thistype == type and (thisid == id or thisname == name):
                if thishandle:
                    return thishandle[0]
                else:
                    handle = newhandle(len(thisdata))
                    mem[handle+4:handle+4+len(thisdata)] = thisdata
                    resource.append(handle)
                    return handle

        if topmap: break

    return 0

def get1resource_trap():
    id = sign_extend(pop(2), 2)
    type = pop(4).to_bytes(4, 'big')
    push(4, getresource(type=type, id=id, topmap=True))
toolbox_traps[0x1f] = get1resource_trap

def get1namedresource_trap():
    name = pop(4)
    name = mem[name+1:name+1+mem[name]]
    type = pop(4).to_bytes(4, 'big')
    pop(4)
    push(4, getresource(type=type, name=name, topmap=True))
toolbox_traps[0x20] = get1namedresource_trap

def getresource_trap():
    id = sign_extend(pop(2), 2)
    type = pop(4).to_bytes(4, 'big')
    pop(4)
    push(4, getresource(type=type, id=id, topmap=False))
toolbox_traps[0x1a0] = getresource_trap

def getnamedresource_trap():
    name = pop(4)
    name = mem[name+1:name+1+mem[name]]
    type = pop(4).to_bytes(4, 'big')
    pop(4)
    push(4, getresource(type=type, name=name, topmap=False))
toolbox_traps[0x1a1] = getnamedresource_trap

def setresload_trap():
    pop(2) # trash the parameter
toolbox_traps[0x19b] = setresload_trap

def releaseresource_trap():
    pop(4) # trash the parameter
toolbox_traps[0x1a3] = releaseresource_trap

def getpattern_trap():
    id = pop(2)
    pop(4)
    push(4, getresource(b'PAT ', id))
toolbox_traps[0x1b8] = getpattern_trap

def getcursor_trap():
    id = pop(2)
    pop(4)
    push(4, getresource(b'CURS', id))
toolbox_traps[0x1b9] = getcursor_trap

def getstring_trap():
    id = pop(2)
    pop(4)
    push(4, getresource(b'STR ', id))
toolbox_traps[0x1ba] = getstring_trap

def geticon_trap():
    id = pop(2)
    pop(4)
    push(4, getresource(b'ICON', id))
toolbox_traps[0x1bb] = geticon_trap

def getpicture_trap():
    id = pop(2)
    pop(4)
    push(4, getresource(b'PICT', id))
toolbox_traps[0x1bc] = getpicture_trap

# Segment Loader Toolbox traps

def loadseg_trap():
    global pc

    seg_num = pop(2)

    jumptable = read(4, regs + 32 + 20) + 32 # $20(a5)

    seg_handle = getresource(b'CODE', seg_num)
    seg_ptr = read(4, seg_handle)

    first = read(2, seg_ptr) # index of first entry within jump table
    count = read(2, seg_ptr + 2) # number of jump table entries

    for i in range(count):
        jt_entry = jumptable + first + 8 * i
        code_offset = read(2, jt_entry)

#         magic = read(2, jt_entry + 2) # move.w #imm,-(sp) instruction
#         if magic != 0x3f3c: sys.exit('corrupt jump table %04x' % magic)
#         magic = read(2, jt_entry + 4) # move.w #imm,-(sp) instruction
#         if magic != seg_num: sys.exit('corrupt jump table sn %04x' % seg_num)

        write(2, jt_entry, seg_num)
        write(2, jt_entry + 2, 0x4ef9) # jmp
        write(4, jt_entry + 4, seg_ptr + 4 + code_offset)

    pc -= 6 # re-execute the jump table instruction

toolbox_traps[0x1f0] = loadseg_trap

def unloadseg_trap():
    pop(4) # ignore

toolbox_traps[0x1f1] = unloadseg_trap

# Package Toolbox traps

def pack4_trap(): # FP68K
    global pc
    push(4, pc); pc = 0xc0000
toolbox_traps[0x1eb] = pack4_trap

def pack5_trap(): # Elems68K
    global pc
    push(4, pc); pc = 0xd0000
toolbox_traps[0x1ec] = pack5_trap

def pack7_trap(): # DecStr68K
    global pc
    push(4, pc); pc = 0xe0000
toolbox_traps[0x1ee] = pack7_trap

# QuickDraw Toolbox traps
def qd_nop_trap(): pass
def qd_pop4_trap(): pop(4)
def qd_pop8_trap(): pop(8)
toolbox_traps[0x50] = qd_nop_trap # _InitCursor
toolbox_traps[0x51] = qd_pop4_trap # _SetCursor
toolbox_traps[0x52] = qd_nop_trap # _HideCursor
toolbox_traps[0x53] = qd_nop_trap # _ShowCursor
toolbox_traps[0x55] = qd_pop8_trap # _ShieldCursor
toolbox_traps[0x56] = qd_nop_trap # _ObscureCursor

def bitand_trap():
    result = pop(4) & pop(4)
    pop(4); push(4, result)
toolbox_traps[0x58] = bitand_trap

def bitxor_trap():
    result = pop(4) ^ pop(4)
    pop(4); push(4, result)
toolbox_traps[0x59] = bitxor_trap

def bitnot_trap():
    result = ~pop(4)
    pop(4); push(4, result)
toolbox_traps[0x5a] = bitnot_trap

def bitor_trap():
    result = pop(4) | pop(4)
    pop(4); push(4, result)
toolbox_traps[0x5b] = bitor_trap

def bitshift_trap():
    by = sign_extend(pop(2), 2)
    result = pop(4)
    if by > 0: result <<= by % 32
    else: result >>= (-by) % 32
    pop(4); push(4, result)
toolbox_traps[0x5c] = bitshift_trap

def bittst_trap():
    idx = pop(2) + 8 * pop(4)
    result = mem[idx // 8] & (0x80 >> (idx % 8))
    pop(2); push(2, 0x100 if result else 0)
toolbox_traps[0x5d] = bittst_trap

def bitset_trap():
    idx = pop(2) + 8 * pop(4)
    mem[idx // 8] |= 0x80 >> (idx % 8)
toolbox_traps[0x5e] = bitset_trap

def bitclr_trap():
    idx = pop(2) + 8 * pop(4)
    mem[idx // 8] &= ~(0x80 >> (idx % 8))
toolbox_traps[0x5f] = bitclr_trap

def random_trap():
    import random
    pop(2); push(2, random.randint(0x10000))
toolbox_traps[0x61] = random_trap

def initgraf_trap():
    a5 = read(4, regs + 32 + 5 * 4)
    qd = pop(4)
    write(4, a5, qd)
    write(qd, 0xf8f8f8f8) # illegal thePort address
toolbox_traps[0x6e] = initgraf_trap

def setport_trap():
    a5 = read(4, regs + 32 + 5 * 4)
    qd = read(4, a5)
    port = pop(4)
    write(4, qd, port)
toolbox_traps[0x73] = setport_trap

def getport_trap():
    a5 = read(4, regs + 32 + 5 * 4)
    qd = read(4, a5)
    port = read(4, qd)
    retaddr = pop(4)
    write(4, retaddr, port)
toolbox_traps[0x74] = getport_trap

# Misc traps

def tickcount_trap():
    pop(4); push(4, 0) # always zero
toolbox_traps[0x175] = tickcount_trap

def purgespace_trap(trap, d0, a0, a1):
    return 0x7fffffff, 0x7fffffff # d0, a0
os_traps[0x62] = purgespace_trap

def debugstr_trap():
    strstart = pop(4)
    lenbyte = mem[strstart]
    string = mem[strstart+1:strstart+1+lenbyte].decode('mac_roman')
    print('_DebugStr', string, flush=True, file=sys.stderr)
    if string.startswith('python:'): eval(string[7:])
toolbox_traps[0x3ff] = debugstr_trap

def debugger_trap():
    import pdb; pdb.set_trace()

toolbox_traps[0x1ff] = debugger_trap

def unimplemented_trap(*args):
    raise NotImplementedError('trap, not sure which')

toolbox_traps[0x9f] = unimplemented_trap

def syserror(n):
    sys.exit('System error %d' % n)

def syserror_trap():
    # trap is in toolbox table but actually uses registers
    err = read(2, regs + 2, signed=True)
    if err == -491: # display string on stack
        strstart = pop(4)
        lenbyte = mem[strstart]
        string = mem[strstart+1:strstart+1+lenbyte].decode('mac_roman')
        print('SysErr -491 string:', string, flush=True, file=sys.stderr)
    syserror(err)

toolbox_traps[0x1c9] = syserror_trap

def gestalt(selector):
    if selector == b'sysv':
        return 0x09228000 # highest possible

def gestalt_trap(trap, d0, a0, a1):
    print('gestalt', hex(d0))
    selector = d0.to_bytes(4, 'big')

    if trap & 0x600 == 0: # ab=00
        # _Gestalt
        val = gestalt(selector)
        if val == None:
            return -5551, 0 # d0, a0
        else:
            return 0, val

    elif trap & 0x600 == 0x200: # ab=01
        # _NewGestalt
        sys.exit('NewGestalt %r' % selector)

    elif trap & 0x600 == 0x400: # ab=10
        # _ReplaceGestalt
        sys.exit('ReplaceGestalt %r' % selector)

    else: # ab=11
        # _GetGestaltProcPtr
        sys.exit('GetGestaltProcPtr %r' % selector)

os_traps[0xad] = gestalt_trap

def cmpstring_trap(trap, d0, a0, a1):
    l0 = d0 >> 16       # corresponds with a0 ptr
    l1 = d0 & 0xffff    # corresponds with a1 ptr
    both = (mem[a0:a0+l0] + mem[a1:a1+l1]).decode('mac_roman')

    if trap & 0x200: # ignore diacritics
        import unicodedata
        both = unicodedata.normalize('NFKD', both)
        both = ''.join(c for c in both if not unicodedata.combining(c))

    if trap & 0x400: # ignore case
        both = both.lower()

    return int(bool(both[:len(both)//2] != both[len(both)//2:]))

os_traps[0x3c] = cmpstring_trap









# Populate the "classic" trap table, and also our list of implementations
# The user-visible trap table initially points to _Unimplemented
toolbox_trap_table = [ftrap_table_addr + 0x89f * 2] * 0x400
os_trap_table = [ftrap_table_addr + 0x89f * 2] * 0x100

for trapnum, traphandler in toolbox_traps.items():
    ftrap_addr = ftrap_table_addr + (0x800 + trapnum) * 2
    toolbox_trap_table[trapnum] = ftrap_addr

for trapnum, traphandler in os_traps.items():
    ftrap_addr = ftrap_table_addr + trapnum * 2
    os_trap_table[trapnum] = ftrap_addr

toolbox_traps = [toolbox_traps.get(i, unimplemented_trap) for i in range(1024)]
os_traps = [os_traps.get(i, unimplemented_trap) for i in range(256)]

def lineAF(inst):
    global pc
    if inst & 0x800: # Toolbox trap
        trapnum = inst & 0x3ff
        implementation_68k = toolbox_trap_table[trapnum]

#         if inst & 0xf000 == 0xf000: # for stress-testing traps
        if inst & 0xf000 == 0xf000 or implementation_68k == ftrap_table_addr + (0x800 + trapnum) * 2:
            # Non-SetTrapAddress'd A-trap OR direct F-trap
            if inst & 0x400 or inst & 0xf000 == 0xf000: pc = pop(4) # autoPop

            implementation_python = toolbox_traps[trapnum]
            implementation_python()

        elif implementation_68k == ftrap_table_addr + 0x89f * 2:
            raise NotImplementedError(hex(inst))

        else:
            # SetTrapAddress'd A-trap: dispatch to custom 68k routine
            if not inst & 0x400: push(4, pc) # autoPop
            pc = implementation_68k

    elif inst & 0xf000 == 0xa000 or inst & 0x0f00 == 0: # OS trap
        # note on the condition above!!!
        trapnum = inst & 0xff
        implementation_68k = os_trap_table[trapnum]

#         if inst & 0xf000 == 0xf000: # for stress-testing traps
        if inst & 0xf000 == 0xf000 or implementation_68k == ftrap_table_addr + trapnum * 2:
            # Non-SetTrapAddress'd A-trap OR direct F-trap
            if inst & 0xf000 == 0xf000: pc = pop(4) # return address

            implementation_python = os_traps[trapnum]
            trapword = read(2, regs + 6) if inst & 0x1000 else inst # d1.w
            retval = implementation_python(trapword,
                read(4, regs), read(4, regs + 32), read(4, regs + 36)) # d0,a0,a1

            # returned a0 or (a0, d0) or (a0, d0, 'completionroutine')
            if not isinstance(retval, tuple): retval = (retval,)
            completionroutine = (retval[-1] == 'completionroutine')
            if completionroutine: retval = retval[:-1]

            if len(retval) > 0 and retval[0] != None:
                write(4, regs, retval[0]) # result in d0.l
            if len(retval) > 1 and retval[1] != None:
                write(4, regs + 32, retval[1]) # result in a0.l
            set_nz(read(2, regs + 2), 2) # tst.w d0

            if completionroutine and trapword & 0x400:
                raise NotImplementedError('completion routine')

        elif implementation_68k == ftrap_table_addr + 0x89f * 2:
            raise NotImplementedError(hex(inst))

        else:
            # SetTrapAddress'd A-trap: dispatch to custom 68k routine
            write(2, regs + 1 * 4 + 2, inst)    # d1.w = trap word

            push(4, pc)                         # Push return address

            # Push the registers that the Trap Dispatcher saves around OS traps
            push(4, read(4, regs + 32 + 8))     # push a2
            push(4, read(4, regs + 8))          # push d2
            push(4, read(4, regs + 4))          # push d1
            push(4, read(4, regs + 32 + 4))     # push a1
            if not inst & 0x100: # only if trap word specifies
                push(4, read(4, regs + 32)) # push a0

            # Push f300 or f301, depending on how many registers need restoring
            push(4, ftrap_table_addr + (0x300 if inst & 0x100 else 0x301) * 2) # f300

            pc = implementation_68k

    elif inst in (0xf300, 0xf301): # OS trap return assistance code
        if inst & 1: # was this a "save-a0" OS trap word?
            write(4, regs + 32 + 0 * 4, pop(4)) # pop a0
        write(4, regs + 32 + 4, pop(4))         # pop a1
        write(4, regs + 4, pop(4))              # pop d1
        write(4, regs + 8, pop(4))              # pop d2
        write(4, regs + 32 + 8, pop(4))         # pop a2
        set_nz(read(2, regs + 2), 2)        # tst.w d0
        pc = pop(4) # Return to the actual caller

    elif inst == 0xf302: # Completion routine return assistance code
        write(4, regs,      pop(4)) # pop d0 (result code)
        write(4, regs + 32, pop(4)) # pop a0 (iopb pointer)
        pc = pop(4)

    else: # Special MPW call
        mpw_ftrap(inst)

lineA = lineF = lineAF # cheating cleverly

########################################################################
# Initialise an MPW environment
########################################################################

# Memory map, mixes in parts belonging to emulator, toolbox and mpw
#                 00000
#             lowmem globals
#             .............
#                 stack
#                 40000
#               registers
#             .............
#         below-a5 tool globals
#                 80000
#         above-a5 tool globals
#             .............
#                 a0000
#  'bigblock' of MPW globals <- $316.l
#             .............
#                 b0000
#           huge f-trap table
#             .............
#                 c0000
#            PACK 4 (_FP68K)
#             .............
#                 d0000
#          PACK 5 (_Elems68K)
#             .............
#                100000
#                 heap

import struct

# A memory, and some memory-mapped registers
mem = bytearray(0x100000) # plenty of room for globals
regs = 0x40000

mem[0xc0000:0xc0000+len(pack4)] = pack4
mem[0xd0000:0xd0000+len(pack5)] = pack5
mem[0xe0000:0xe0000+len(pack7)] = pack7

def mpw_ftrap(inst): # special breakout instructions, not for general use
    if inst == 0xf100:
        # quit
        sys.exit()

    elif inst == 0xf101:
        # access
        sp = read(4, regs + 64 - 4)
        arg1 = read(4, sp + 4)
        arg2 = read(4, sp + 8)
        arg3 = read(4, sp + 12)

        if arg2 == 0x6400: # open
            # No error handling, yet
            name = mem[arg1:mem.index(b'\0', arg1)].decode('mac_roman')
            flags = read(2, arg3)
            try:
                print('flags', hex(flags))
                fd = macopen(name,
                    readable=flags & 3 in (0, 2, 3),
                    writable=flags & 3 in (1, 2, 3),
                    append=flags & 8,        # O_APPEND
                    rsrcfork=flags & 0x10,   # O_RSRC
                    create=flags & 0x100,    # O_CREAT
                    truncate=flags & 0x200,  # O_TRUNC
                    exclusive=flags & 0x400, # O_EXCL
                    # note that we ignore O_BINARY
                    )
            except FileNotFoundError:
                fd = -1
                err = 2, 0 # ENOENT
            except FileExistsError:
                fd = -1
                err = 17,0 # EEXIST
            else:
                err = 0, 0
            write(4, regs, err[0]) # d0.l
            write(2, arg3 + 2, err[1]) # error code
            write(4, arg3 + 8, fd) # cookie = index into our array

        elif arg2 == 0x6401: # delete
            name = mem[arg1:mem.index(b'\0', arg1)].decode('mac_roman')
            macdelete(name)
            write(4, regs, 0) # d0.l = 0

        elif arg2 == 0x6402: # rename
            raise NotImplementedError('rename')

        else: # something else not supported
            pass

    elif inst == 0xf102:
        # close
        sp = read(4, regs + 64 - 4)
        fptr = read(4, sp + 4)
        fd = read(4, fptr + 8) # cookie
        macclose(fd)
        write(2, fptr + 2, 0) # file.err=0
        write(4, regs, 0) # d0=0

    elif inst == 0xf103:
        # read
        sp = read(4, regs + 64 - 4)
        fptr = read(4, sp + 4)
        fd = read(4, fptr + 8) # cookie
        cnt = read(4, fptr + 12)
        buf = read(4, fptr + 16)
#         print('read', 'fd', hex(fd), 'cnt', cnt)
        didread = macread(fd, cnt)
        write(4, fptr + 12, cnt - len(didread))
        mem[buf:buf+len(didread)] = didread
        write(2, fptr + 2, 0) # file.err=0
        write(4, regs, 0) # d0=0

    elif inst == 0xf104:
        # write
        sp = read(4, regs + 64 - 4)
        fptr = read(4, sp + 4)
        fd = read(4, fptr + 8) # cookie
        cnt = read(4, fptr + 12)
        buf = read(4, fptr + 16)
        macwrite(fd, mem[buf:buf+cnt])
        write(4, fptr + 12, 0) # 0 bytes left to write
        write(2, fptr + 2, 0) # file.err=0
        write(4, regs, 0) # d0=0

    elif inst == 0xf105:
        # ioctl
        sp = read(4, regs + 64 - 4)
        fptr = read(4, sp + 4)
        request = read(4, sp + 8)
        argp = read(4, sp + 12)

#         print('ioctl', hex(fptr), hex(request), hex(argp))
#         print(' fptr', mem[fptr:fptr+28].hex())
#         print(' argp', mem[argp:argp+16].hex())

        fd = read(4, fptr + 8) # cookie
        f = refnums[fd]

        if request == 0x6600: # FIOLSEEK
            whence = read(4, argp)
            offset = read(4, argp + 4, signed=True)

            oldmark = f.__mpw_mark

            if whence == 0: # SEEK_SET
                f.__mpw_mark = offset
            elif whence == 1: # SEEK_CUR
                f.__mpw_mark += offset
            elif whence == 2: # SEEK_END
                f.__mpw_mark = len(f.__mpw_contents) + offset

            write(4, regs, 0) # d0 = 0
            write(2, fptr + 2, 0) # noErr

            # It is legal to seek on a stream in order to ftell() it
            if f.name.startswith('/dev/'):
                write(2, fptr + 2, -50) # paramErr... not sure why?
                if f.__mpw_mark != oldmark:
                    f.__mpw_mark = oldmark
                    write(4, regs, 22) # d0 = EINVAL

            write(4, argp + 2, f.__mpw_mark)

        elif request == 0x6601: # FIODUPFD
            # confirmed that this prevents closure, but does nothing else!
            refnums.append(f)
            write(4, regs, 0) # d0 = 0
            write(2, fptr + 2, 0) # noErr

        elif request == 0x6602: # FIOINTERACTIVE
            write(4, regs, 22) # d0 = EINVAL
            write(2, fptr + 2, -50) # paramErr

        elif request == 0x6603: # FIOBUFSIZE
            write(4, regs, 22) # d0 = EINVAL
            write(2, fptr + 2, 0) # noErr

        elif request == 0x6604: # FIOFNAME
            name = f.__mpw_name[:255].encode('mac_roman') + b'\0'
            mem[argp:argp+len(name)] = name
            write(4, regs, 0) # d0 = 0
            write(2, fptr + 2, 0) # noErr

        elif request == 0x6605: # FIOREFNUM
            write(4, argp, fd)
            write(4, regs, 0) # d0 = 0
            write(2, fptr + 2, 0) # noErr

        elif request == 0x6606: # FIOSETEOF
            del f.__mpw_contents[argp:]
            f.__mpw_contents.extend(bytes(argp - len(f.__mpw_contents)))
            write(4, regs, 0) # d0 = 0
            write(2, fptr + 2, 0) # noErr

        else:
            write(4, regs, 25) # d0 = ENOTTY
            write(2, fptr + 2, -50) # paramErr

    else:
        raise ValueError('%04X not implemented' % inst)

def read(numbytes, addr, signed=False):
#     if addr < 0x1000: print('read lowmem', hex(addr))
    return int.from_bytes(mem[addr:addr+numbytes], 'big', signed=signed)

def write(numbytes, addr, val):
    val &= (1 << (numbytes * 8)) - 1
    mem[addr:addr+numbytes] = val.to_bytes(numbytes, 'big')
#     print('write', numbytes, hex(addr), val.to_bytes(numbytes, 'big').hex())

write(4, regs + 8 * 4 + 7 * 4, 0x40000) # stack growing down from registers


# Big table of every permutation of f-trap at b0000
for i in range(0x1000):
    struct.pack_into('>H', mem, ftrap_table_addr + i * 2, 0xf000 + i)


argv = sys.argv[1:]
argv[0] = argv[0].rpartition('/')[2]

env = []
for key, val in sorted(os.environ.items()):
    if key.lower().startswith('MPW_'):
        env.append((key[4:] + '\0' + val + b'\0').encode('mac_roman'))

# Block of code for MPW callbacks
# elements ending with '::' are labels, with '??' are ptrs
bigblock = [
    b'MPGM',
    'pointer to sh table',

    'sh table',
        b'SH',
        len(argv).to_bytes(4, 'big'),
        'pointer to argument array',
        'pointer to environment array',
        bytes(12),
        b'\x01\x90', # ?default fd table size
        'pointer to io table',
        'pointer to dev table',
        bytes(12),

    'quit instruction',
        b'\xf1\x00\x4e\x75',

    'access instruction',
        b'\xf1\x01\x4e\x75',

    'close instruction',
        b'\xf1\x02\x4e\x75',

    'read instruction',
        b'\xf1\x03\x4e\x75',

    'write instruction',
        b'\xf1\x04\x4e\x75',

    'ioctl instruction',
        b'\xf1\x05\x4e\x75',

    'dev table',
        b'FSYS',
        'pointer to access instruction',
        'pointer to close instruction',
        'pointer to read instruction',
        'pointer to write instruction',
        'pointer to ioctl instruction',
        b'ECON',
        bytes(20),
        b'SYST',
        bytes(20),

    'io table',
        b'\x00\x01', # flags = read
        b'\x00\x00', # error code
        'pointer to dev table',
        b'\x00\x00\x00\x00', # cookie = stdin
        b'\x00\x00\x00\x00', # transfer byte count (set by tool)
        b'\x00\x00\x00\x00', # buffer ptr (set by tool)

        b'\x00\x02', # flags = write
        b'\x00\x00', # error code
        'pointer to dev table',
        b'\x00\x00\x00\x01', # cookie = stdout
        b'\x00\x00\x00\x00', # transfer byte count (set by tool)
        b'\x00\x00\x00\x00', # buffer ptr (set by tool)

        b'\x00\x02', # flags = write
        b'\x00\x00', # error code
        'pointer to dev table',
        b'\x00\x00\x00\x02', # cookie = stderr
        b'\x00\x00\x00\x00', # transfer byte count (set by tool)
        b'\x00\x00\x00\x00', # buffer ptr (set by tool)

    'environment array',
        *('pointer to environment %d' % i for i in range(len(env))),
        bytes(4),

    'argument array',
        *('pointer to argument %d' % i for i in range(len(argv))),
        bytes(4),
]

for i, arg in enumerate(argv):
    bigblock.append(bytes(16))
    bigblock.append('argument %d' % i)
    bigblock.append(arg.encode('mac_roman') + b'\0')
    bigblock.append(bytes(16))

for i, e in enumerate(env):
    bigblock.append('environment %d' % i)
    bigblock.append(e)

putwhere = 0xa0000
ctr = putwhere
labels = {}
relocations = []
for item in bigblock:
    if isinstance(item, str):
        if item.startswith('pointer to '):
            relocations.append((ctr, item[11:]))
            ctr += 4
        else: # a label
            labels[item] = ctr
    else: # plain bytes
        mem[ctr:ctr+len(item)] = item
        ctr += len(item)
        ctr += ctr & 1 # pad to even
for address, targetlabel in relocations:
    struct.pack_into('>L', mem, address, labels[targetlabel])
struct.pack_into('>L', mem, 0x316, putwhere)
push(4, labels['quit instruction'])

resource_chain = [ # system and app
    [
        [b'STR ', -16096, None, 0x40, b'\x06drongo'],
    ],
    readrez(sys.argv[1] + '.rdump')
]
code0 = next(r for r in resource_chain[1] if r[0] == b'CODE' and r[1] == 0)[-1]

# Some misc globals
write(4, 0x31a, 0x00ffffff)
write(4, 0xa02, 0x00010001)
write(4, 0xa06, 0xffffffff)
write(4, 0x130, 0) # ApplLimit
write(4, 0x908, 0x70000000) # CurStackBase
mem[0x910:0x910+5] = b'\x04Sort'

# Make an a5 world
abovea5, belowa5, jtsize, jtoffset = struct.unpack_from('>LLLL', code0)
a5world = 0x80000
write(4, regs + 8 * 4 + 5 * 4, a5world); write(4, 0x904, a5world)
mem[a5world+jtoffset:a5world+jtoffset+jtsize] = code0[16:16+jtsize]
pc = a5world + jtoffset + 2

run_m68k_interpreter()
