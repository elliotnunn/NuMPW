#!/usr/bin/env python3

########################################################################
# 68000 interpreter: minimal user-mode implementation
#
# Notes:
# - all "sizes" are in bytes
# - define read(), write() and lineA() somewhere outside this block
########################################################################

# Emulator state: set to something better than this before running
regs = 0
pc = 0
x = n = z = v = c = 0

def push(size, data):
    ptr = address_by_mode(39, size) # -(A7)
    write(size, ptr, data)

def pop(size):
    ptr = address_by_mode(31, size) # (A7)+
    return read(size, ptr)

def sign_extend(n, size):
    bitsize = size * 8
    n &= (1 << bitsize) - 1 # clip to size
    signbit = 1 << (bitsize - 1)
    if n & (1 << (bitsize - 1)): n -= (1 << bitsize)
    return n

def add_then_set_vc(a, b, size):
    global v, c
    bitsize = size * 8
    signbit = 1 << (bitsize - 1)
    mask = (1 << bitsize) - 1
    a &= mask
    b &= mask
    result = (a + b) & mask
    v = (a & signbit) == (b & signbit) != (result & signbit)
    c = result < a # could use result < b just as easily
    return result

def set_nz(num, size):
    global n, z
    bitsize = size * 8
    n = bool(num & (1 << (bitsize - 1)))
    z = (num == 0)

def get_ccr():
    return (x << 4) | (n << 3) | (z << 2) | (v << 1) | c

def set_ccr(to_byte):
    global x, n, z, v, c
    x = bool(to_byte & 16)
    n = bool(to_byte & 8)
    z = bool(to_byte & 4)
    v = bool(to_byte & 2)
    c = bool(to_byte & 1)

def address_by_mode(mode, size): # mode given by bottom 6 bits
    # side effects: predecrement/postincrement, advance pc to get extension word
    global pc

    if mode >> 3 == 0: # Dn
        ptr = regs + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 1: # An
        ptr = regs + 32 + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 2: # (An)
        ptr = read(4, regs + 32 + (mode & 7) * 4)
    elif mode >> 3 == 3: # (An)+
        regptr = regs + 32 + (mode & 7) * 4
        newptr = ptr = read(4, regptr)
        newptr += size
        if mode & 7 == 7 and size == 1: newptr += 1
        write(4, regptr, newptr)
    elif mode >> 3 == 4: # -(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, regptr)
        ptr -= size
        if mode & 7 == 7 and size == 1: ptr -= 1
        write(4, regptr, ptr)
    elif mode >> 3 == 5: # d16(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = (read(4, regptr) + read(2, pc, signed=True)); pc += 2
    elif mode >> 3 == 6: # d8(An,Xn)
        ptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, ptr) # get An
        #
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 58: # d16(PC)
        ptr = pc + read(2, pc, signed=True); pc += 2
    elif mode == 59: # d8(PC,Xn)
        ptr = pc
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 56: # abs.W
        ptr = read(2, pc); pc += 2
    elif mode == 57: # abs.L
        ptr = read(4, pc); pc += 4
    elif mode == 60: # #imm
        if size == 1:
            ptr = pc + 1; pc += 2
        elif size == 2:
            ptr = pc; pc += 2
        elif size == 4:
            ptr = pc; pc += 4
    else:
        raise ValueError(mode)

    return ptr

def test_condition(cond):
    if cond == 0: # T true
        return True
    elif cond == 1: # F false
        return False
    elif cond == 2: # HI higher than
        return not (c or z)
    elif cond == 3: # LS lower or same
        return c or z
    elif cond == 4: # CC carry clear aka HS
        return not c
    elif cond == 5: # CS carry set aka LS
        return c
    elif cond == 6: # NE not equal
        return not z
    elif cond == 7: # EQ equal
        return z
    elif cond == 8: # VC overflow clear
        return not v
    elif cond == 9: # VS overflow set
        return v
    elif cond == 10: # PL plus
        return not n
    elif cond == 11: # MI minus
        return n
    elif cond == 12: # GE greater or equal
        return n == v
    elif cond == 13: # LT less than
        return not (n == v)
    elif cond == 14: # GT greater than
        return n == v and not z
    elif cond == 15: # LE less or equal
        return n != v or z

def line0(inst):
    global pc, x, n, z, v, c
    if inst & 256 or inst >> 9 == 4: # btst,bchg,bclr,bset (or movep)
        if inst & 256: # bit numbered by data register
            if (inst >> 3) & 7 == 1: 1/0 # MOVEP instruction :(
            dn = inst >> 9
            bit = read(4, regs + dn * 4)
        else: # bit numbered by immediate
            bit = read(2, pc); pc += 2

        mode = inst & 63
        if mode >> 3 <= 1: size = 4 # applies to register
        else: size = 1 # applies to memory address

        bit %= size * 8
        mask = 1 << bit

        ptr = address_by_mode(mode, size)
        val = read(size, ptr)
        z = not (val & mask)

        if (inst >> 6) & 3 == 1: # bchg
            val ^= mask
        elif (inst >> 6) & 3 == 2: # bclr
            val &= ~mask
        elif (inst >> 6) & 3 == 3: # bset
            val |= mask
        # ^^ the btst case is already handled by setting z

        write(size, ptr, val)

    else: #ori,andi,subi,addi,eori -- including to SR/CCR
        size = (1,2,4,None)[(inst >> 6) & 3] or 1/0 # illegal %11 size!
        src_ptr = address_by_mode(60, size) # '#imm' mode, advances pc
        imm = read(size, src_ptr)

        # now, are we operating on a special mode?
        dest_mode = inst & 63
        if dest_mode == 60: # '#imm' actually means CCR/SR
            # for addi/subi this would simply be invalid
            val = get_ccr()
        else:
            dest_ptr = address_by_mode(dest_mode, size)
            val = read(size, dest_ptr)

        if inst >> 9 == 0: # ori
            val |= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 1: # andi
            val &= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 2: # subi
            val = add_then_set_vc(val, -imm, size)
            c = not c
            x = c
            set_nz(val, size)
        elif inst >> 9 == 3: # addi
            val = add_then_set_vc(val, -imm, size)
            x = c
            set_nz(val, size)
        elif inst >> 9 == 5: # eori
            val ^= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 6: # cmpi: same as subi, but don't set
            fake_val = add_then_set_vc(val, -imm, size)
            c = not c # don't set x
            set_nz(fake_val, size)

        if dest_mode == 60:
            set_ccr(val)
        else:
            write(size, dest_ptr, val)

def line123(inst): # move, and movea which is a special-ish case
    global v, c
    size = (None, 1, 4, 2)[(inst >> 12) & 3] or 1/0
    dest_mode = ((inst >> 3) & 0x38) | ((inst >> 9) & 7)
    src_mode = inst & 63

    src = address_by_mode(src_mode, size)
    datum = read(size, src, signed=True)

    if dest_mode >> 3 == 1: # movea: sign extend to 32 bits
        size = 4
    else: # non-movea: set condition codes
        v = c = 0
        set_nz(datum, size)

    dest = address_by_mode(dest_mode, size)
    write(size, dest, datum)

def line4(inst): # very,crowded,line
    global pc, x, n, z, v, c
    if (inst >> 6) & 63 == 3: # move from sr
        dest = address_by_mode(inst & 63, 2) # sr is 2 bytes
        write(2, dest, get_ccr())
    elif (inst >> 6) & 63 in (19, 27): # move to sr/ccr
        size = 1 if (inst >> 6) & 63 == 19 else 2 # ccr or sr?
        src = address_by_mode(inst & 63, size)
        set_ccr(read(size, src))
    elif (inst >> 8) & 15 in (0, 4, 6): # negx,neg,not
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)

        if (inst >> 8) & 15 == 0: # negx
            datum = add_then_set_vc(0, -datum-x, size)
            c = not c # because subtraction
            x = c
            set_nz(datum, size)
        elif (inst >> 8) & 15 == 4: # neg
            datum = add_then_set_vc(0, -datum, size)
            c = not c # because subtraction
            x = c
            set_nz(datum, size)
        else: # not
            datum = ~datum
            datum &= (1 << size) - 1 # clip python's bignum
            v = c = False
            set_nz(datum, size)

        write(size, dest, datum)

    elif (inst >> 8) & 15 == 2: # clr
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dest = address_by_mode(inst & 63, size)

        n = False
        z = True
        v = False
        c = False

        write(size, dest, 0)

    elif inst & 0xFB8 == 0x880: # ext
        size = 4 if inst & 64 else 2
        dn = (inst >> 3) & 7
        src = regs + dn * 4 + 4 - size//2
        dest = regs + dn * 4 + 4 - size
        datum = read(size//2, src)
        set_nz(datum, size)
        v = c = False
        write(size, src, datum)

    elif inst & 0xFF8 == 0x840: # swap.w
        dn = (inst >> 3) & 7
        dest = regs + dn * 4
        datum = read(4, dest)
        datum = ((datum >> 16) & 0xFFFF) | ((datum & 0xFFFF) << 16)
        set_nz(datum, 4)
        v = c = False
        write(4, dest, datum)

    elif inst & 0xFC0 == 0x840: # pea -- notice similarity to swap.w
        ea = address_by_mode(inst & 63, 4) # size doesn't matter here
        push(4, ea)

    elif inst & 0xF00 == 0xA00: # tst,tas
        size, is_tas = ((1,0), (2,0), (4,0), (1,1))[(inst >> 6) & 3]
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        set_nz(datum, size)
        v = c = False
        if is_tas: write(1, dest, datum | 0x80)

    elif inst & 0xFF8 == 0xE50: # link
        an = inst & 7; an_ea = regs + 32 + an * 4
        imm = read(2, pc, signed=True); pc += 2

        push(4, read(4, an_ea)) # move.l a6,-(sp)
        sp = read(4, regs+60)
        write(4, an_ea, sp) # move.l sp,a6
        write(4, regs+60, sp + imm) # add.w #imm,sp

    elif inst & 0xFF8 == 0xE58: # unlk
        an = inst & 7; an_ea = regs + 32 + an * 4

        write(4, regs+60, read(4, an_ea)) # move.l a6,sp
        write(4, an_ea, pop(4)) # move.l (sp)+,a6

    elif inst & 0xFFF == 0xE71: # nop
        pass

    elif inst & 0xFFF == 0xE75: # rts
        pc = pop(4)

    elif inst & 0xFFF == 0xE77: # rtr
        set_ccr(pop(2))
        pc = pop(4)

    elif inst & 0xF80 == 0xE80: # jsr/jmp
        targ = address_by_mode(inst & 63, 4) # any size
        if not inst & 0x40:
            push(4, pc)
        pc = targ

    elif inst & 0xB80 == 0x880: # movem
        size = 4 if inst & 64 else 2
        dir_to_reg = bool(inst & 0x400)
        which = read(2, pc); pc += 2

        if dir_to_reg: which = [r for r in range(16) if which & (1 << r)]
        else: which = [r for r in range(16) if which & (0x8000 >> r)]

        ptr = address_by_mode(inst & 63, len(which) * size)

        for reg in which:
            if dir_to_reg:
                datum = read(size, ptr, signed=True); ptr += size
                write(4, regs+reg*4, datum)
            else:
                datum = read(size, regs + reg * 4 + 4 - size)
                write(size, ptr, datum); ptr += size

    elif inst & 0x1C0 == 0x1C0: # lea
        an = (inst >> 9) & 7
        ea = address_by_mode(inst & 63, 4) # any size
        write(4, regs + 32 + an * 4, ea)

    elif inst & 0x1C0 == 0x180: # chk
        dn = (inst >> 9) & 7
        testee = read(2, regs + 4 * dn + 2, signed=True)
        ea = address_by_mode(inst & 63, 2)
        ubound = read(2, ea, signed=True)
        if not 0 <= testee <= ubound: raise ValueError('chk failed') # raise exception

def line5(inst): # addq,subq,scc,dbcc
    global pc, x, n, z, v, c
    if (inst >> 6) & 3 != 3: # addq,subq
        size = 1 << ((inst >> 6) & 3)
        if size == 2 and (inst >> 3) & 7 == 1: size = 4 # An.w is really An.l

        imm = ((inst >> 9) & 7) or 8
        if inst & 256: imm = -imm # subq, not addq

        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        save_ccr = x, n, z, v, c
        datum = add_then_set_vc(datum, imm, size)
        if inst & 256: c = not c # subq, not addq
        x = c
        set_nz(datum, size)
        if (inst >> 3) & 7 == 1: x, n, z, v, c = save_ccr # touch not ccr if dest is An
        write(size, dest, datum)

    elif (inst >> 3) & 7 == 1: # dbcc
        disp = read(2, pc, signed=True) - 2; pc += 2

        # decrement the counter (dn)
        dn = inst & 7
        dest = regs + dn * 4 + 2
        counter = (read(2, dest) - 1) & 0xFFFF
        write(2, dest, counter)
        if counter == 0xFFFF: return # do not take the branch

        cond = (inst >> 8) & 15 # if cond satisfied then DO NOT take loop
        if test_condition(cond): return

        pc += disp

    else: # scc
        dest = address_by_mode(inst & 63, 1)
        cont = (inst >> 8) & 15
        write(1, dest, 0xFF * test_condition(cond))

def line6(inst): # bra,bsr,bcc
    global pc
    disp = sign_extend(inst & 255, 1)
    if disp == 0: # word displacement
        disp = read(2, pc, signed=True) - 2; pc += 2

    cond = (inst >> 8) & 15
    if cond > 1 and not test_condition(cond): return # not taken

    if cond == 1: # is bsr
        push(4, pc)

    pc += disp

def line7(inst): # moveq
    global n, z, v, c
    dn = (inst >> 9) & 7
    val = sign_extend(inst & 255, 1)
    n = (val < 0); z = (val == 0); v = c = 0
    write(4, regs + dn * 4, val)

def line8(inst): # divu,divs,sbcd,or
    global n, z, v, c
    if inst & 0x1F0 == 0x100: # sbcd
        1/0
    elif inst & 0x0C0 == 0x0C0: # divu,divs
        signed = bool(inst & 0x100)
        ea = address_by_mode(inst & 63, 2)
        divisor = read(2, ea, signed)
        if divisor == 0: 1/0 # div0 error
        dn = (inst >> 9) & 7
        dividend = read(4, regs + dn * 4, signed)

        # remainder is 0 or has same sign as dividend
        quotient = abs(dividend) // abs(divisor)
        if dividend < 0: quotient = -quotient
        if divisor < 0: quotient = -quotient
        remainder = abs(dividend) % abs(divisor)
        if dividend < 0: remainder = -remainder

        if signed and not (-0x8000 <= quotient < 0x7FFF):
            v = True
            return

        if not signed and quotient > 0xFFFF:
            v = True
            return

        v = False
        set_nz(quotient, 2)

        write(4, regs + dn * 4, ((remainder & 0xFFFF) << 16) | (quotient & 0xFFFF))

    else: # or
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src

        datum = read(size, src) | read(size, dest)
        write(size, dest, datum)
        set_nz(datum, size)
        v = c = False

def line9D(inst): # sub,subx,suba//add,addx,adda: very compactly encoded
    global x, n, z, v, c
    sign = 1 if inst & 0x4000 else -1
    if inst & 0x0C0 == 0x0C0: # suba,adda
        size = 4 if inst & 0x100 else 2
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = read(4, regs + 32 + an * 4, signed=True) + sign * read(size, ea, signed=True)
        write(4, regs + 32 + an * 4, result)

    elif inst & 0x130 == 0x100: # subx,addx: only two addressing modes allowed
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        mode = 32 if inst & 8 else 0 # either -(Ax),-(Ay) or Dx,Dy
        src = address_by_mode(mode | (inst & 7), size)
        dest = address_by_mode(mode | ((inst >> 9) & 7), size)

        result = add_then_set_vc(read(size, dest), sign * (read(size, src) + x), size)
        write(size, dest, result)
        if sign == -1: c = not c
        x = c
        old_z = z; set_nz(result, size); z &= old_z

    else: # sub,add
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src # direction bit does a swap
        result = add_then_set_vc(read(size, dest), sign * read(size, src), size)
        if sign == -1: c = not c
        x = c
        set_nz(result, size)
        write(size, dest, result)

def lineB(inst): # cmpa,cmp,cmpm,eor
    global x, n, z, v, c
    if inst & 0x0C0 == 0x0C0: # cmpa
        size = 4 if inst & 0x100 else 2 # size of ea but An is always .L
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = add_then_set_vc(read(4, regs + 32 + an * 4, signed=True), -read(size, ea, signed=True), 4)
        c = not c
        set_nz(result, 4)

    elif inst & 0x100 == 0x000: # cmp
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size
        src = address_by_mode(inst & 63, size)
        result = add_then_set_vc(read(size, dest), -read(size, src), size)
        c = not c
        set_nz(result, size)

    elif inst & 0x38 == 0x08: # cmpm (Ay)+,(Ax)+
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(24 | (inst & 7), size) # (An)+ mode
        dest = address_by_mode(24 | ((inst >> 9) & 7), size)
        result = add_then_set_vc(read(size, dest), -read(size, src), size)
        c = not c
        set_nz(result, size)

    else: # eor
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7; src = regs + 4 * dn + 4 - size
        dest = address_by_mode(inst & 63, size)

        result = read(size, dest) ^ read(size, src)
        v = c = False
        set_nz(result, size)
        write(size, dest, result)

def lineC(inst):
    if inst & 0xC0 == 0xC0: # mulu,muls
        pass
    elif inst & 0x1F0 == 0x100: # abcd
        1/0 # I don't like BCD instructions
    elif inst & 0x1F8 in (0x140, 0x148, 0x188): # exg
        rx = (inst >> 9) & 7
        ry = inst & 7
        if inst & 0x1F8 == 0x148: # Ax,Ay
            rx |= 8; ry |= 8 # bump the addressing mode from Dn to An
        if inst & 0x1F8 == 0x188: # Dx,Ay
            ry |= 8

        rx = address_by_mode(rx, 4)
        ry = address_by_mode(ry, 4)

        x = read(4, rx)
        y = read(4, ry)
        write(4, rx, y)
        write(4, ry, x)

    else: # and
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7; dest = address_by_mode(dn, size)
        src = address_by_mode(inst & 63, size)

        if inst & 0x100: src, dest = dest, src # direction bit

        result = read(size, src) & read(size, dest)
        set_nz(result, size)
        v = c = False
        write(size, dest, result)

def lineE(inst):
    global x, n, z, v, c
    size = (1, 2, 4, None)[(inst >> 6) & 3]

    if size is None: # single-bit shift on a memory address
        size = 2
        kind = (inst >> 9) & 3
        dest = address_by_mode(inst & 63, size)
        by = 1
    else:
        kind = (inst >> 3) & 3
        dest = regs + (inst & 7) * 4 + 4 - size # dn
        if inst & 0x20:
            by = read(1, regs + ((inst >> 9) & 7) * 4 + 3) % 64
        else:
            by = (inst >> 9) & 7

    isleft = bool(inst & 0x100)

    v = False # clear V if msb never changes
    c = False # clear C if shift count is zero

    result = read(size, dest)
    mask = (1 << (size * 8)) - 1
    msb = 1 << (size * 8 - 1)
    numbits = size * 8
    if kind == 0: # asl/asr
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(result & msb) # shifted-out bit
                if newresult & msb != result & msb: v = 1 # set V if sign ever changes
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                newresult |= result & msb # replicate sign bit
                result = newresult
    elif kind == 1: # lsl/lsr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(newresult & (mask + 1)) # shifted-out bit
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                result = newresult
    elif kind == 2: # roxl/roxr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) | x
                x = c = bool(newresult >> numbits)
                result = newresult & mask
        else:
            for i in range(by):
                newresult = (result >> 1) | (x * msb)
                x = c = bool(result & 1)
                result = newresult & mask
    elif kind == 3: # rol/ror
        v = False
        if isleft:
            for i in range(by):
                result = (result << 1) | (result >> (numbits - 1))
                c = bool(result & 1)
        else:
            for i in range(by):
                c = bool(result & 1)
                result = (result << (numbits - 1)) | (result >> 1)

    set_nz(result, size)

    write(size, dest, result)

def lineF(inst):
    1/0 # fail!

def run_m68k_interpreter():
    global pc
    instruction_lines = (line0, line123, line123, line123, line4, line5, line6, line7,
        line8, line9D, lineA, lineB, lineC, line9D, lineE, lineF)

#     import pdb; pdb.set_trace()
    while True: # need a way to bust out of this loop
        inst = read(2, pc); pc += 2; instruction_lines[inst >> 12](inst)

########################################################################
# Resources! At least we can be slow when dealing with them.
########################################################################

import re # the below code could be turned into one giant regex if we were brave

rez_tokens = [
    ((),         r'(\s|//.*?\n|/\*.*?\*/)+'),                                   # 0 whitespace/comment (gets ignored)
    ((1,11),     r'\$"\s*((?:[0-9A-Fa-f]{2}\s*)*)"'),                           # 1 hex data
    ((3,),       r'(data)'),                                                    # 2 start of raw resource
    ((4,),       r"('(?:[^'\\]|\\0x[0-9A-Fa-f]{2}|\\[\\'\\?btrvfn])*')"),       # 3 type
    ((5,),       r'(\()'),                                                      # 4 start of bracketed resource info
    ((6,7,8,9),  r'(-?\d+)'),                                                   # 5 ID
    ((7,8,9),    r',gap("(?:[^"\\]|\\0x[0-9A-Fa-f]{2}|\\[\\"\\?btrvfn])*")'),   # 6 name
    ((9,),       r',gap\$([0-9a-fA-F]{1,2})'),                                  # 7 attribs (hex)
    ((8,9),      r',gap(sysheap|purgeable|locked|protected|preload)'),          # 8 attribs (specific)
    ((10,),      r'(\))'),                                                      # 9 end of bracketed resource info
    ((1,11),     r'(\{)'),                                                      # 10 start of hex block
    ((12,),      r'(\})'),                                                      # 11 end of hex block
    ((2,-1),     r'(;)'),                                                       # 12 the end for real
    ((),         r'(.)'),                                                       # 13 unexpected character (always errors)
]

allowed_to_follow_kind, token_regexen = zip(*rez_tokens)

# The 'gap' hack turns ', sysheap' etc into a single token
gap = r'(?:\s|//.*?\n|/\*.*?\*/)*'
rez_tokenizer = '|'.join(token_regexen).replace('gap', gap).encode('ascii')
rez_tokenizer = re.compile(rez_tokenizer)

def string_surrogate(m):
    m = m.group(0)

    if len(m) == 5: # \0xFF is the most common
        return bytes([int(m[3:], 16)])
    elif m == b'\\"':
        return b'"'
    elif m == b"\\'":
        return b"'"
    elif m == b'\\b':
        return b'\x08' # backspace
    elif m == b'\\t':
        return b'\t'
    elif m == b'\\r':
        return b'\n'
    elif m == b'\\v':
        return b'\x0b' # vertical tab
    elif m == b'\\f':
        return b'\x0c' # form feed
    elif m == b'\\n':
        return b'\r'
    elif m == b'\\?':
        return b'\x7f' # del

def string_literal(string):
    return re.sub(rb'(\\0x..|\\.)', string_surrogate, string[1:-1])

def readrez(path):
    # lifted from my macresources package, but a little bit 'nastier'
    # returns a list of [type, id, name, flags, data]'s
    retval = []

    with open(path, 'rb') as f: from_rezcode = f.read()
    from_rezcode = from_rezcode.replace(b'\r\n', b'\n').replace(b'\r', b'\n')

    # Slightly faster than finditer
    all_tokens = rez_tokenizer.findall(from_rezcode)
    def line_no_for_error(token_idx):
        # Redo all the lexing with finditer, which is slower but
        # gives us Match objects with a byte offset
        work_redoer = rez_tokenizer.finditer(from_rezcode)
        match_obj = next(m for i, m in enumerate(work_redoer) if i == token_idx)
        line_no = from_rezcode[:match_obj.start()].count(ord('\n')) + 1

    allowed_token_kinds = (2,-1)
    for token_idx, token_captures in enumerate(all_tokens):
        # Which single capture is non-empty?
        for token_kind, payload in enumerate(token_captures):
            if payload: break

        # Ignore whitespace
        if not token_kind: continue

        # Unexpected token!
        if token_kind not in allowed_token_kinds:
            raise ValueError('File %r, line %r' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 1:
            hex_accum.append(payload)

        elif token_kind == 2:
            res = [b'type', 9999, None, 0, b'']; retval.append(res)
            hex_accum = []

        elif token_kind == 3:
            res[0] = string_literal(payload)
            if len(res[0]) != 4:
                raise ValueError('File %r, line %r, type not 4 chars' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 5:
            res[1] = int(payload)
            if not (-32768 <= res[1] < 32767):
                raise ValueError('File %r, line %r, ID out of 16-bit range' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 6:
            res[2] = string_literal(payload)
            if len(res[2]) > 255:
                raise ValueError('File %r, line %r, name > 255 chars' % (original_file, line_no_for_error(token_idx)))

        elif token_kind == 7:
            res[3] = int(payload, 16)

        elif token_kind == 8:
            if payload == b'sysheap':
                res[3] |= 0x40
            elif payload == b'purgeable':
                res[3] |= 0x20
            elif payload == b'locked':
                res[3] |= 0x10
            elif payload == b'protected':
                res[3] |= 0x08
            elif payload == b'preload':
                res[3] |= 0x04

        elif token_kind == 12:
            res[4] = bytes.fromhex(b''.join(hex_accum).decode('ascii'))

        allowed_token_kinds = allowed_to_follow_kind[token_kind]

    # Premature EOF
    if -1 not in allowed_token_kinds:
        raise ValueError('File %r, unexpected end of file' % original_file)

    return retval

########################################################################
# The Macintosh Toolbox. Wish me luck...
########################################################################

heap_blocks = {} # addr: size
def tbnewptr(size): # fixed 16b header before all "heap" blocks
    while len(mem) % 16: mem.append(0)
    mem.extend(bytes(16 + size))
    retval = len(mem) - size
    heap_blocks[retval] = size
    return retval

def tbnewhandle(size):
    ptr = tbnewptr(size)
    write(4, ptr - 4, ptr)
    write(4, ptr - 8, 0xFA7B175) # FatBits
    return ptr - 4 # a handle points to its owning pointer

def tbgetresource(rtype, rid, one=False): # always load the resource
    for file in reversed(resource_chain):
        for resource in file:
            thistype, thisid, thisname, thisflags, thisdata, *thishandle = resource
            if thistype == rtype and thisid == rid:
                if thishandle:
                    return thishandle[0]
                else:
                    handle = tbnewhandle(len(thisdata))
                    mem[handle+4:handle+4+len(thisdata)] = thisdata
                    resource.append(handle)
                    return handle

        if one: break

    return 0

def lineA(inst):
    if inst == 0xABFF: # DebugStr
        strstart = pop(4)
        lenbyte = mem[strstart]
        string = mem[strstart+1:strstart+1+lenbyte].decode('mac_roman')
        print('_DebugStr', string, flush=True, file=sys.stderr)
        if string.startswith('python:'): eval(string[7:])

    elif inst == 0xA9FF: # Debugger
        import pdb; pdb.set_trace()

    elif inst == 0xA9F4: # ExitToShell
        sys.exit() # wrong way to do it

    else:
        raise ValueError('Elliot needs to write %04X before you can use it.' % inst)

########################################################################
# Initialise an MPW environment
########################################################################

import struct

# A memory, and some memory-mapped registers
mem = bytearray(0x100000) # plenty of room for globals
regs = 0x80000

def read(numbytes, addr, signed=False):
    return int.from_bytes(mem[addr:addr+numbytes], 'big', signed=signed)

def write(numbytes, addr, val):
    val &= (1 << (numbytes * 8)) - 1
    mem[addr:addr+numbytes] = val.to_bytes(numbytes, 'big')
#     print('write', numbytes, hex(addr), val.to_bytes(numbytes, 'big').hex())

write(4, regs + 8 * 4 + 7 * 4, 0x80000) # stack growing down from registers

import sys
resource_chain = [[], readrez(sys.argv[1] + '.rdump')] # system and app
code0 = next(r for r in resource_chain[1] if r[0] == b'CODE' and r[1] == 0)[-1]

# Make an a5 world
abovea5, belowa5, jtsize, jtoffset = struct.unpack_from('>LLLL', code0)
a5world = tbnewptr(belowa5 + abovea5) + belowa5
write(4, regs + 8 * 4 + 5 * 4, a5world); write(4, 0x904, a5world)
pc = a5world + jtoffset + 2

is_far_model = False
for i in range(0, jtsize, 8):
    words = struct.unpack_from('>HHHH', code0, 16 + i)
    if words[1] == 0xFFFF:
        is_far_model = True
        continue

    if is_far_model:
        raise NotImplementedError('far model not written yet')

    else:
        segmenthandle = tbgetresource(b'CODE', words[2])
        target = segmenthandle + 4 + words[0]

    write(6, a5world + jtoffset + i + 2, (0x4EF9 << 32) | target) # jmp there

run_m68k_interpreter()
