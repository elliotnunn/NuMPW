#!/usr/bin/env python3


import struct

# all sizes (widths) are in bytes


mem = bytearray(0x1000000)
# hell, let's just wire the registers into memory
regs = 0xF00000
pc = 0x1000
x = n = z = v = c = 0

# test program: infinite loop
struct.pack_into('>L', mem, regs + 15*4, regs) # stack under regs
mem[pc:pc+4] = b'\x61\x00\xff\xfe'

def sign_extend(n, size):
    bitsize = size * 8
    n &= (1 << bitsize) - 1 # clip to size
    signbit = 1 << (bitsize - 1)
    if n & (1 << (bitsize - 1)): n -= (1 << bitsize)
    return n

def read(numbytes, addr, signed=False):
    return int.from_bytes(mem[addr:addr+numbytes], 'big', signed=signed)

def write(numbytes, addr, val):
    val &= (1 << numbytes) - 1
    mem[addr:addr+numbytes] = val.to_bytes(numbytes, 'big')

def add_then_set_vc(a, b, size):
    global v, c
    bitsize = size * 8
    signbit = 1 << (bitsize - 1)
    mask = (1 << bitsize) - 1
    a &= mask
    b &= mask
    result = (a + b) & mask
    v = (a & signbit) == (b & signbit) != (result & signbit)
    c = result < a # could use result < b just as easily
    return result

def set_nz(num, size):
    global n, z
    bitsize = size * 8
    n = bool(num & (1 << (bitsize - 1)))
    z = (num == 0)


def get_ccr():
    return (x << 4) | (n << 3) | (z << 2) | (v << 1) | c


def set_ccr(to_byte):
    global x, n, z, v, c
    x = bool(to_byte & 16)
    n = bool(to_byte & 8)
    z = bool(to_byte & 4)
    v = bool(to_byte & 2)
    c = bool(to_byte & 1)


def address_by_mode(mode, size): # mode given by bottom 6 bits
    # side effects: predecrement/postincrement, advance pc to get extension word
    global pc

    if mode >> 3 == 0: # Dn
        ptr = regs + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 1: # An
        ptr = regs + 32 + (mode & 7) * 4 + 4 - size
    elif mode >> 3 == 2: # (An)
        ptr = read(4, regs + 32 + (mode & 7) * 4)
    elif mode >> 3 == 3: # (An)+
        regptr = regs + 32 + (mode & 7) * 4
        newptr = ptr = read(4, regptr)
        newptr += size
        if mode & 7 == 7 and size == 1: newptr += 1
        write(4, regptr, newptr)
    elif mode >> 3 == 4: # -(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, regptr)
        ptr -= size
        if mode & 7 == 7 and size == 1: ptr -= 1
        write(4, regptr, ptr)
    elif mode >> 3 == 5: # d16(An)
        regptr = regs + 32 + (mode & 7) * 4
        ptr = (read(4, ptr) + read(2, pc, signed=True)); pc += 2
    elif mode >> 3 == 6: # d8(An,Xn)
        ptr = regs + 32 + (mode & 7) * 4
        ptr = read(4, ptr) # get An
        #
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 58: # d16(PC)
        ptr = pc + read(2, pc, signed=True); pc += 2
    elif mode == 59: # d8(PC,Xn)
        ptr = pc
        xreg = read(1, pc); pc += 1
        xofs = read(1, pc, signed=True); pc += 1
        whichreg = regs + (xreg >> 4) * 4 # could be D or A
        if xreg & 8: rofs = read(4, whichreg, signed=True)
        else: rofs = read(2, whichreg + 2, signed=True)
        ptr += xofs + rofs
    elif mode == 56: # abs.W
        ptr = read(2, pc); pc += 2
    elif mode == 57: # abs.L
        ptr = read(4, pc); pc += 4
    elif mode == 60: # #imm
        if size == 1:
            ptr = pc + 1; pc += 2
        elif size == 2:
            ptr = pc; pc += 2
        elif size == 4:
            ptr = pc; pc += 4

    return ptr


def test_condition(cond):
    if cond == 0: # T true
        return True
    elif cond == 1: # F false
        return False
    elif cond == 2: # HI higher than
        return not (c or z)
    elif cond == 3: # LS lower or same
        return c or z
    elif cond == 4: # CC carry clear aka HS
        return not c
    elif cond == 5: # CS carry set aka LS
        return c
    elif cond == 6: # NE not equal
        return not z
    elif cond == 7: # EQ equal
        return z
    elif cond == 8: # VC overflow clear
        return not v
    elif cond == 9: # VS overflow set
        return not v
    elif cond == 10: # PL plus
        return not n
    elif cond == 11: # MI minus
        return n
    elif cond == 12: # GE greater or equal
        return n == v
    elif cond == 13: # LT less than
        return not (n == v)
    elif cond == 14: # GT greater than
        return n == v and not z
    elif cond == 15: # LE less than
        return n != v or z




def push(size, data):
    ptr = address_by_mode(39, size) # -(A7)
    write(size, ptr, data)

def pop(size):
    ptr = address_by_mode(31, size) # (A7)+
    return read(size, ptr)


def line0(inst):
    global z
    if inst & 256 or inst >> 9 == 4: # btst,bchg,bclr,bset (or movep)
        if inst & 256: # bit numbered by data register
            if (inst >> 3) & 7 == 1: 1/0 # MOVEP instruction :(
            dn = inst >> 9
            bit = read(4, regs + dn * 4)
        else: # bit numbered by immediate
            bit = read(2, pc); pc += 2

        mode = inst & 63
        if mode >> 3 <= 1: size = 4 # applies to register
        else: size = 1 # applies to memory address

        bit %= size * 8
        mask = 1 << bit

        ptr = address_by_mode(mode, size)
        val = read(size, ptr)
        z = not (val & mask)

        if (inst >> 6) & 3 == 1: # bchg
            val ^= mask
        elif (inst >> 6) & 3 == 2: # bclr
            val &= ~mask
        elif (inst >> 6) & 3 == 3: # bset
            val |= mask
        # ^^ the btst case is already handled by setting z

        write(size, ptr, val)

    else: #ori,andi,subi,addi,eori -- including to SR/CCR
        size = (1,2,4,None)[(inst >> 6) & 3] or 1/0 # illegal %11 size!
        src_ptr = address_by_mode(60, size) # '#imm' mode, advances pc
        imm = read(size, src_ptr)

        # now, are we operating on a special mode?
        dest_mode = inst & 63
        if dest_mode == 60: # '#imm' actually means CCR/SR
            val = get_ccr()
        else:
            dest_ptr = address_by_mode(dest_mode, size)
            val = read(size, dest_ptr)

        if inst >> 9 == 0: # ori
            val |= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 1: # andi
            val &= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 2: # subi
            val = add_then_set_vc(val, -imm, size)
            c = not c
            set_nz(val, size)
        elif inst >> 9 == 3: # addi
            val = add_then_set_vc(val, -imm, size)
            set_nz(val, size)
        elif inst >> 9 == 5: # eori
            val ^= imm
            v = c = 0
            set_nz(val, size)
        elif inst >> 9 == 6: # cmpi: same as subi, but don't set
            fake_val = add_then_set_vc(val, -imm, size)
            c = not c
            set_nz(fake_val, size)

        if dest_mode == 60:
            set_ccr(val)
        else:
            write(size, dest_ptr, val)

def line123(inst): # move, and movea which is a special-ish case
    global v, c
    size = (None, 1, 4, 2)[(inst >> 12) & 3] or 1/0
    dest_mode = ((inst >> 3) & 0x38) | ((inst >> 9) & 7)
    src_mode = inst & 63

    src = address_by_mode(src_mode, size)
    datum = read(size, src, signed=True)

    if dest_mode >> 3 == 1: # movea: sign extend to 32 bits
        size = 4
    else: # non-movea: set condition codes
        v = c = 0
        set_nz(datum, size)

    dest = address_by_mode(dest_mode, size)
    write(size, dest, datum)

def line4(inst): # very,crowded,line
    global x, n, z, v, c
    if (inst >> 6) & 63 == 3: # move from sr
        dest = address_by_mode(inst & 63, 2) # sr is 2 bytes
        write(2, dest, get_ccr())
    elif (inst >> 6) & 63 in (19, 27): # move to sr/ccr
        size = 1 if (inst >> 6) & 63 == 19 else 2 # ccr or sr?
        src = address_by_mode(inst & 63, size)
        set_ccr(read(size, src))
    elif (inst >> 8) & 15 in (2, 4, 6): # negx,neg,not
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)

        if (inst >> 8) & 15 == 2: # negx
            datum = add_then_set_vc(0, -datum-x, size)
            c = not c # because subtraction
            x = c
            set_nz(datum, size)
        elif (inst >> 8) & 15 == 2: # neg
            datum = add_then_set_vc(0, -datum, size)
            c = not c # because subtraction
            x = c
            set_nz(datum, size)
        else: # not
            datum = ~datum
            datum &= (1 << size) - 1 # clip python's bignum
            v = c = False
            set_nz(datum, size)

        write(size, dest, datum)

    elif (inst >> 8) & 15 == 0: # clr
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dest = address_by_mode(inst & 63, size)

        n = False
        z = True
        v = False
        c = False

        write(size, dest, 0)

    elif inst & 0xFB8 == 0x880: # ext
        size = 4 if inst & 64 else 2
        dn = (inst >> 3) & 7
        src = regs + dn * 4 + 4 - size//2
        dest = regs + dn * 4 + 4 - size
        datum = read(size//2, src)
        set_nz(datum, size)
        v = c = False
        write(size, src, datum)

    elif inst & 0xFF8 == 0x840: # swap.w
        dn = (inst >> 3) & 7
        dest = regs + dn * 4
        datum = read(4, dest)
        datum = ((datum >> 16) & 0xFFFF) | ((datum & 0xFFFF) << 16)
        set_nz(datum, 4)
        v = c = False
        write(4, dest, datum)

    elif inst & 0xFC0 == 0x840: # pea -- notice similarity to swap.w
        ea = address_by_mode(inst & 63, 4) # size doesn't matter here
        push(4, ea)

    elif inst & 0xF00 == 0xA00: # tst,tas
        size, is_tas = ((1,0), (2,0), (4,0), (1,1))[(inst >> 6) & 3]
        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        set_nz(datum, size)
        v = c = False
        if is_tas: write(1, dest, datum | 0x80)

    elif inst & 0xFF8 == 0xE50: # link
        an = inst & 7; an_ea = regs + 32 + an * 4
        imm = read(2, pc, signed=True); pc += 2

        push(4, read(4, an_ea)) # move.l a6,-(sp)
        sp = read(4, regs+60)
        write(4, an_ea, sp) # move.l sp,a6
        write(4, regs+60, sp + imm) # add.w #imm,sp

    elif inst & 0xFF8 == 0xE58: # unlk
        an = inst & 7; an_ea = regs + 32 + an * 4

        write(4, regs+60, read(4, an_ea)) # move.l a6,sp
        write(4, an_ea, pop(4)) # move.l (sp)+,a6

    elif inst & 0xFFF == 0xE71: # nop
        pass

    elif inst & 0xFFF == 0xE75: # rts
        pc = pop(4)

    elif inst & 0xFFF == 0xE77: # rtr
        set_ccr(pop(2))
        pc = pop(4)

    elif inst & 0xF80 == 0xE80: # jsr/jmp
        targ = address_by_mode(inst & 63, 4) # any size
        if not inst & 0x40:
            push(4, pc)
        pc = targ

    elif inst & 0xB80 == 0x880: # movem
        size = 4 if inst & 64 else 2
        dir_to_reg = bool(inst & 0x400)
        which = read(2, pc); pc += 2

        if dir_to_reg: which = [r for r in range(16) if which & (1 << r)]
        else: which = [r for r in range(16) if which & (0x8000 >> r)]

        ptr = address_by_mode(inst & 63, len(which) * size)

        for reg in which:
            if dir_to_reg:
                datum = read(size, ptr, signed=True); ptr += size
                write(4, regs+reg*4, datum)
            else:
                datum = read(size, regs + reg * 4 + 4 - size)
                write(size, ptr, datum); ptr += size

    elif inst & 0x1C0 == 0x1C0: # lea
        an = (inst >> 9) & 7
        ea = address_by_mode(inst & 63, 4) # any size
        write(4, regs + 32 + an * 4, ea)

    elif inst & 0x1C0 == 0x180: # chk
        dn = (inst >> 9) & 7
        testee = read(2, regs + 4 * dn + 2, signed=True)
        ea = address_by_mode(inst & 63, 2)
        ubound = read(2, ea, signed=True)
        if not 0 <= testee <= ubound: raise ValueError('chk failed') # raise exception


def line5(inst): # addq,subq,scc,dbcc
    global x, n, z, v, c, pc
    if (inst >> 6) & 3 != 3: # addq,subq
        size = 1 << ((inst >> 6) & 3)
        if size == 2 and (inst >> 3) & 7 == 1: size = 4 # An.w is really An.l

        imm = ((inst >> 9) & 7) + 1
        if inst & 256: imm = -imm # subq, not addq

        dest = address_by_mode(inst & 63, size)
        datum = read(size, dest)
        datum = add_then_set_vc(x, imm, size); x = c
        if inst & 256: c = not c # subq, not addq
        set_nz(datum, size)
        write(size, dest, datum)

    elif (inst >> 3) & 7 == 1: # dbcc
        disp = read(2, pc, signed=True); pc += 2

        # decrement the counter (dn)
        dn = inst & 7
        dest = regs + dn * 4 + 2
        counter = (read(2, dest) - 1) & 0xFFFF
        write(2, dest, counter)
        if counter == 0xFFFF: return # do not take the branch

        cond = (inst >> 8) & 15 # if cond satisfied then DO NOT take loop
        if test_condition(cond): return

        pc += disp - 2

    else: # scc
        dest = address_by_mode(inst & 63, 1)
        cont = (inst >> 8) & 15
        write(1, dest, 0xFF * test_condition(cond))

def line6(inst): # bra,bsr,bcc
    global pc
    disp = sign_extend(inst & 255, 1)
    if disp == 0: # word displacement
        disp = read(2, pc, signed=True); pc += 2

    cond = (inst >> 8) & 15
    if cond > 1 and not test_condition(cond): return # not taken

    if cond == 1: # is bsr
        push(4, pc)

    pc += disp - 2

def line7(inst): # moveq
    global n, z, v, c
    dn = (inst >> 9) & 7
    val = sign_extend(inst & 255, 1)
    n = (val < 0); z = (val == 0); v = c = 0
    write(4, regs + dn * 4, val)

def line8(inst): # divu,divs,sbcd,or
    global n, z, v, c
    if inst & 0x1F0 == 0x100: # sbcd
        1/0
    elif inst & 0x0C0 == 0x0C0: # divu,divs
        signed = bool(inst & 0x100)
        ea = address_by_mode(inst & 63, 2)
        divisor = read(2, ea, signed)
        if divisor == 0: 1/0 # div0 error
        dn = (inst >> 9) & 7
        dividend = read(4, regs + dn * 4, signed)

        quotient = dividend // divisor
        if dividend < 0: quotient = -quotient
        if divisor < 0: quotient = -quotient
        remainder = dividend % divisor
        if dividend < 0: remainder = -remainder

        if signed and not (-0x8000 <= quotient < 0x7FFF):
            v = True
            return

        if not signed and quotient > 0xFFFF:
            v = True
            return

        v = False
        set_nz(quotient, 2)

        write(4, regs + dn * 4, ((quotient & 0xFFFF) << 16) | (remainder & 0xFFFF))

    else: # or
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src

        datum = read(size, src) | read(size, dest)
        write(size, dest, datum)
        set_nz(datum, size)
        v = c = False

def line9D(inst): # sub,subx,suba//add,addx,adda: very compactly encoded
    global x, n, z, v, c
    sign = 1 if inst & 0x4000 else -1
    if inst & 0x0C0 == 0x0C0: # suba
        size = 4 if inst & 0x100 else 2
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = read(4, regs + 32 + an * 4, signed=True) + sign * read(size, ea, signed=True)
        write(4, regs + 32 + an * 4, result)

    elif inst & 0x130 == 0x100: # subx: only two addressing modes allowed
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        mode = 32 if inst & 8 else 0 # either -(Ax),-(Ay) or Dx,Dy
        src = address_by_mode(mode | (inst & 7), size)
        dest = address_by_mode(mode | ((inst >> 9) & 7), size)

        result = add_then_set_vc(read(size, dest), sign * (read(size, src) + x), size)
        write(size, dest, result)
        c = not c
        x = c
        old_z = z; set_nz(result, size); z |= old_z

    else: # sub
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(inst & 63, size)
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size

        if inst & 0x100: src, dest = dest, src # direction bit does a swap
        result = add_then_set_vc(read(size, dest), sign * (read(size, src) + x), size)
        x = c
        set_nz(result, size)
        write(size, dest, result)

def lineA(inst): # macintosh os/toolbox
    pass

def lineB(inst): # cmpa,cmp,cmpm,eor
    global x, n, z, v, c
    if inst & 0x0C0 == 0x0C0: # cmpa
        size = 4 if inst & 0x100 else 2 # size of ea but An is always .L
        ea = address_by_mode(inst & 63, size)
        an = (inst >> 9) & 7
        result = add_then_set_vc(read(4, regs + 32 + an * 4, signed=True), -read(size, ea, signed=True), 4)
        set_nz(result, 4)

    elif inst & 0x100 == 0x000: # cmp
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7
        dest = regs + dn * 4 + 4 - size
        src = address_by_mode(inst & 63, size)
        result = add_then_set_vc(read(size, regs + dn * 4 + 4 - size), -read(size, ea), size)
        set_nz(result, size)

    elif inst & 0x38 == 0x08: # cmpm (Ay)+,(Ax)+
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        src = address_by_mode(24 | (inst & 7)) # (An)+ mode
        dest = address_by_mode(24 | ((inst >> 9) & 7))
        result = add_then_set_vc(read(size, dest), -read(size, src), size)
        set_nz(result, size)

    else: # eor
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7; src = regs + 4 * dn + 4 - size
        dest = address_by_mode(inst & 63, size)

        result = read(size, dest) ^ read(size, src)
        v = c = False
        set_nz(result, size)
        write(size, dest, result)

def lineC(inst):
    if inst & 0xC0 == 0xC0: # mulu,muls
        pass
    elif inst & 0x1F0 == 0x100: # abcd
        1/0 # I don't like BCD instructions
    elif inst & 0x1F8 in (0x140, 0x148, 0x180): # exg
        rx = (inst >> 9) & 7
        ry = inst & 7
        if inst & 0x1F8 == 0x148: # Ax,Ay
            rx |= 8; ry |= 8 # bump the addressing mode from Dn to An
        if inst & 0x1F8 == 0x180: # Dx,Ay
            ry |= 8

        rx = address_by_mode(rx, 4)
        ry = address_by_mode(ry, 4)

        x = read(4, rx)
        y = read(4, ry)
        write(4, rx, y)
        write(4, ry, x)

    else: # and
        size = (1, 2, 4, None)[(inst >> 6) & 3] or 1/0
        dn = (inst >> 9) & 7; dest = address_by_mode(dn, size)
        src = address_by_mode(inst & 63, size)

        if inst & 0x100: src, dest = dest, src # direction bit

        result = read(size, src) & read(size, dest)
        set_nz(result, size)
        v = c = False
        write(size, dest, result)



def lineE(inst):
    global x, n, z, v, c
    size = (1, 2, 4, None)[(inst >> 6) & 3]

    if size is None: # single-bit shift on a memory address
        size = 2
        kind = (inst >> 9) & 3
        dest = address_by_mode(inst & 63, 2)
        by = 1
    else:
        kind = (inst >> 3) & 3
        dest = regs + ((inst >> 9) & 7) * 4 + 2 # dn
        if inst & 0x20:
            by = read(1, regs + ((inst >> 9) & 7) * 4 + 3) % 64
        else:
            by = (inst >> 9) & 7

    isleft = bool(inst & 0x100)

    c = False # clear C if shift count is zero

    result = read(size, dest)
    mask = (0x100 << size) - 1
    msb = 1 << (size * 8 - 1)
    numbits = size * 8
    if kind == 0: # asl/asr
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(newresult & (mask + 1)) # shifted-out bit
                if newresult & msb != result & msb: v = 1 # set V if sign ever changes
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                newresult |= result & msb # replicate sign bit
                result = newresult
    elif kind == 1: # lsl/lsr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) & mask
                x = c = bool(newresult & (mask + 1)) # shifted-out bit
                result = newresult
        else:
            for i in range(by):
                newresult = result >> 1
                x = c = bool(result & 1) # shifted-out bit
                result = newresult
    elif kind == 2: # roxl/roxr
        v = False
        if isleft:
            for i in range(by):
                newresult = (result << 1) | x
                x = c = bool(newresult >> numbits)
                result = newresult & mask
        else:
            for i in range(by):
                newresult = (result >> 1) | (x * msb)
                x = c = bool(result & 1)
                result = newresult & mask
    elif kind == 3: # rol/ror
        v = False
        if isleft:
            for i in range(by):
                result = (result << 1) | (result >> (numbits - 1))
                c = bool(result & 1)
        else:
            for i in range(by):
                c = bool(result & 1)
                result = (result << (numbits - 1)) | (result >> 1)

    set_nz(result, size)

    write(size, dest, result)

def lineF(inst):
    pass




instruction_lines = (line0, line123, line123, line123, line4, line5, line6, line7,
    line8, line9D, lineA, lineB, lineC, line9D, lineE, lineF)

while 1:
    inst = struct.unpack_from('>H', mem, pc)[0]; pc += 2
    instruction_lines[inst >> 12](inst)
    # that's it!
