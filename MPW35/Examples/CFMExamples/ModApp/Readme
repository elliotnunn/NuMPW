Introduction------------ModApp is a “modular” application from Apple’s Developer University group.It serves as a demonstration and test bed for loading external code modulesinto an application. ModApp can load PowerPC modules from the data fork of afile or from a resource, and can load 68K code from a resource.(Note: The terms “tool” and “module” are used interchangeably throughoutthis document.)Some of the things that ModApp demonstrates are:	• Using CFM for conventional shared libraries (GWorldTools)	• Using CFM for custom additions (PowerPC modules)	• Calling 68K code directly	• Using MixedMode for Toolbox callbacks (Apple events support)The code is portable between the PowerPC compilers, Symantec C++ for PowerMacintosh, and Metrowerks CodeWarrior. ModApp can be built in a 68K version,a PowerPC version, or as a “fat binary” which incorporates both. (NeitherSymantec C++ for Macintosh nor Metrowerks CodeWarrior currently support theCFM-68K runtime, so the 68K version must be built with MPW compilers.)Note: The Symantec Rez compiler that is included with Symantec C++ forPower Macintosh 8.0 is not able to compile the “cfrg.r” file. The workaroundis to use ToolServer and the standard MPW Rez compiler to compile “cfrg.r”and adding the resulting resource file to the project. Symantec C++ forMacintosh 7.0 (for 68K development; commonly known as THINK C) cannot beused to compile the 68K version of ModApp because it does not yet supportthe CFM-68K runtime model.Building ModApp---------------ModApp has an MPW make file to build it and all tools. The default makefile builds “fat” versions of the application and all tools.	• Building “all” will build a “fat” version of the app and all tools	• Building “ModApp” creates a “fat” version of the app, while 	  building “ModApp.68K” makes a 68K-only version and building	  “ModApp.PowerPC” creates a PowerPC-only version.	• Building “:Modules:Clock” builds only the clock module, or 	  you can substitute another module name.	  NOTE: The makefile requires 3 subfolders in the ModApp folder:Modules, PowerPC, and 68K. Running the “MakeFolders” script willcreate these for you if they don’t exist already.If you construct your own makefile, or move this to another developmentsystem, note that the “Koch” and “Clock” modules depend on the “GWorldTools”library.The default build has symbols turned *off* and optimization set for *size*. Editing the “SYM” variable at the start of the makefile turns symbolicdebugging on and off, editing “OPT” controls the optimization level (for PowerPC.)These options also can be set from the command line	make ModApp -d SYM=on -d OPT=offbuilds a debugging version. (Note that SYM=on implies OPT=off)Theory of Operation-------------------ModApp is a fairly standard Macintosh application, though it doesn’t print or scroll.The interesting part has to do with how modules are loaded and executed. The reallycrucial information is contained in ToolLoader.c, ToolAPI.h, and the tool filesthemselves.Since ModApp has to support both 68K and PowerPC modules, almost all calls to a moduleare done through Universal Procedure Pointers. When the module’s initialization routineis called, it creates a UPP for each entry point and places these in the “ToolInfoBlock”data structure. (See the ToolStartup routine in Button.c for an example of this.) ModAppthen uses these UniversalProcedurePointers to call the module.(Currently, modules do not call back to the main application, though if they did I wouldprobably implement these callbacks using a similar table mechanism.)The only exception to the “modules are called via Universal Procedure Pointers” rule is the module’s “ToolStartup” routine. This routine may be called directly, or througha UniversalProcPtr -- see “InitializeTool” in ToolLoader.c for details.The structure of a tool-----------------------A 68K module is implemented as a single 'TOOL' (0) resource, and has all of thelimitations of 68K stand-alone code.A PowerPC module may be implemented as either a PEF container in the data fork of themodule’s file, or as a 'TOOL' (1) resource containing a PEF container. (NOTE: In ModApp,the PowerPC resource should not have a routine descriptor at the front, as it will beloaded and called as a native code fragment -- see LoadViaCFM in ToolLoader.c) PowerPCmodules also have to contain a 'cfrg' resource to designate them as native; the typeshould be set to “kIsDropIn” and the location set to either kOnDiskFlat (for the datafork) or kInMem (for a resource).“Fat” modules contain both kinds of code in the appropriate places. Don’t forget the'cfrg' resource!The sample modules------------------ModApp ships with several sample modules, ranging from simple frameworks to a fancyfractal drawing demonstration:	• Simple — a basic do-nothing module, that just draws a black rectangle in the window.	• Button - displays a single push button and beeps when the button is pressed. This	  module demonstrates how a module should handle getting its own resources.	• Clock - A basic analog clock with a sweep-second hand. This demonstrates how a 	  module can install and remove menus and get idle time. Clock uses the “GWorldTools”	  library for off-screen drawing. (supplied)	• Koch - Draws the von Koch “snowflake” fractal over and over, rotating and colorizing	  the result. This is a nice demonstration of Quickdraw’s performance.	  	and finally...		• PowerResource - A really trivial module, but one that shows how to build and load	  PowerPC code resources (without going through Mixed Mode.)