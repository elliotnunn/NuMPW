package main

import (
	"strconv"
	"strings"
)

func tPack6() {
	selector := popw()
	switch selector {
	case 0: // IUDateString
		pushl(0) // zero handle
		fallthrough
	case 14: // IUDatePString
		handle := popl()
		result := popl()
		form := popb()
		secs := popl()

		dateString(secs, form, result, handle)

	case 2: // IUTimeString
		pushl(0) // zero handle
		fallthrough
	case 16: // IUTimePString
		handle := popl()
		result := popl()
		wantSeconds := popb() != 0
		secs := popl()

		timeString(secs, wantSeconds, result, handle)

	case 6: // FUNCTION IUGetIntl(theID: INTEGER): Handle;
		id := popw()
		// now stack points at space for handle return
		pushl(0x69746c30 + uint32(id)) // itl0
		pushw(0)
		call_m68k(executable_atrap(0xada0)) // _GetResource ,autoPop

	case 8: // PROCEDURE IUSetIntl(refNum: INTEGER; theID: INTEGER; intlHandle: Handle);
		handle := popl()
		id := popw()
		refNum := popw()

		prevRefNum := readw(0xa5a)
		writew(0xa5a, refNum)
		defer writew(0xa5a, prevRefNum)

		prevResLoad := readw(0xa5e)
		writew(0xa5e, 0)
		defer writew(0xa5e, prevResLoad)

		writel(a0ptr, handle)
		call_m68k(executable_atrap(0xa9e4)) // _HandAndHand
		handle = readl(a0ptr)

		// Remove existing resource
		pushl(0)          // room for existHandle
		pushl(0x494e544c) // INTL
		pushw(id)
		call_m68k(executable_atrap(0xac1f)) // _Get1Resource ,autoPop
		existHandle := popl()
		if existHandle != 0 {
			pushl(existHandle)
			call_m68k(executable_atrap(0xadad)) // _RmveResource ,autoPop
		}

		pushl(handle)
		pushl(0x494e544c)                   // INTL
		pushw(id)                           // resource id
		pushl(0)                            // no name
		call_m68k(executable_atrap(0xadab)) // _AddResource ,autoPop

		// should make it purgeable too...

		// 	case 4: // IUMetric
		// 	case 10: // IUMagString
		// 	case 12: // IUMagIwstring
		// 	case 16: // IUTimePString
		// 	case 20: // IULDateString
		// 	case 22: // IULTimeString
		// 	case 24: // IUClearCache
		// 	case 26: // IUMagPString
		// 	case 28: // IUMagIDPString
		// 	case 30: // IUScriptOrder
		// 	case 32: // IULangOrder
		// 	case 34: // IUTextOrder
		// 	case 36: // IUGetItlTable
	default:
		panic(selector)
	}
}

func dateString(secs uint32, form uint8, resultPtr uint32, intl uint32) {
	if intl == 0 { // No intl table supplied, so must find one
		pushl(0) // for handle
		if form == 0 {
			pushl(0x69746c30) // itl0
		} else {
			pushl(0x69746c31) // itl1
		}
		pushw(0)
		call_m68k(executable_atrap(0xada0)) // _GetResource ,autoPop
		intl = popl()

		if intl == 0 {
			panic("no itl0/1 resource")
		}
	}

	if readl(intl) == 0 {
		pushl(intl)
		call_m68k(executable_atrap(0xada2)) // _LoadResource ,autoPop
	}

	intl = readl(intl) // handle to pointer

	str := ""

	if form == 0 {
		y, m, d := secs2ymd(secs)

		dateOrder := readb(intl + 7)
		century := readb(intl+8)&0x80 != 0
		monLeadZero := readb(intl+8)&0x40 != 0
		dayLeadZero := readb(intl+8)&0x20 != 0
		slash := readb(intl + 9)

		for _, which := range []string{"mdy", "dmy", "ymd", "myd", "dym", "ydm"}[dateOrder] {
			str += string([]byte{slash})
			switch which {
			case 'y':
				if century {
					str += strconv.Itoa(int(y))
				} else {
					str += strconv.Itoa(int(y) % 100)
				}
			case 'm':
				if monLeadZero && m < 10 {
					str += "0"
				}
				str += strconv.Itoa(int(m))
			case 'd':
				if dayLeadZero && d < 10 {
					str += "0"
				}
				str += strconv.Itoa(int(d))
			}
		}
		str = str[1:]
	} else { // long or abbrev form
		y, m, d := secs2ymd(secs)
		w := secs2dow(secs)

		dowName := string(readPstring(intl + 16*(uint32(w+6)%7)))
		monthName := string(readPstring(intl + 112 + 16*(uint32(m)-1)))

		suppress := readb(intl + 304)
		lngDateFmt := readb(intl + 305)
		dayLeading0 := readb(intl+306) != 0
		abbrLen := readb(intl + 307)

		// Convert "old style" value to a bit mask
		if suppress == 0xff {
			suppress = 2 // suppress day
		}

		// Abbreviate strings
		if form == 2 {
			dowName = dowName[:abbrLen]
			monthName = monthName[:abbrLen]
		}

		// Get the five 4b separator strings
		separator := make([]string, 5)
		for i := range separator {
			raw := mem[intl+308+4*uint32(i):][:4]
			separator[i] = strings.TrimRight(string(raw), "\x00")
		}

		// Convert "old style" order to a bit mask
		if lngDateFmt == 0 {
			lngDateFmt = 0xe1 // wdmy
		} else if lngDateFmt == 0xff {
			lngDateFmt = 0xc9 // wmdy
		}

		// Mix the fields in order
		str = separator[0]
		for i := 0; i < 4; i++ {
			field := (lngDateFmt >> (i * 2)) & 3

			if suppress&(1<<field) != 0 {
				continue
			}

			switch field {
			case 0: // day
				if dayLeading0 && d < 10 {
					str += "0"
				}
				str += strconv.Itoa(int(d))
			case 1: // dow
				str += dowName
			case 2: // month
				str += monthName
			case 3: // year
				str += strconv.Itoa(int(y))
			}

			str += separator[i+1]
		}
	}

	writePstring(resultPtr, macstring(str))
}

func timeString(secs uint32, wantSeconds bool, resultPtr uint32, intl uint32) {
	if intl == 0 { // No intl table supplied, so must find one
		pushl(0)          // for handle
		pushl(0x69746c30) // itl0
		pushw(0)
		call_m68k(executable_atrap(0xada0)) // _GetResource ,autoPop
		intl = popl()

		if intl == 0 {
			panic("no itl0 resource")
		}
	}

	if readl(intl) == 0 {
		pushl(intl)
		call_m68k(executable_atrap(0xada2)) // _LoadResource ,autoPop
	}

	intl = readl(intl) // handle to pointer

	h, m, s := secs2hms(secs)

	timeCycle := readb(intl + 10)
	timeFmt := readb(intl + 11)
	timeSep := string([]byte{readb(intl + 20)})

	// Get am/pm/uhr marker
	ampmPtr := intl + 12
	if h >= 12 {
		ampmPtr += 4
	}
	if timeCycle == 0 { // 24hr
		ampmPtr += 9
	}
	ampm := strings.TrimRight(string(mem[ampmPtr:][:4]), "\x00")

	// Adjust am/pm cycle if not on 24-hour time
	if timeCycle != 0 {
		if h >= 12 {
			h -= 12
		}
		if timeCycle&0x80 != 0 && h == 0 {
			h = 12
		}
	}

	numbers := []uint16{h, m, s}
	if !wantSeconds {
		numbers = numbers[:2]
	}

	str := ""
	for i, n := range numbers {
		str += timeSep
		if timeFmt&(0x80>>i) != 0 && n < 10 {
			str += "0"
		}
		str += strconv.Itoa(int(n))
	}
	str += ampm
	str = str[1:]

	writePstring(resultPtr, macstring(str))
}

// Resources that main() puts in the System file...

var itl0 = []byte{
	0x2e, 0x2c, 0x3b, 0x24, 0x00, 0x00, 0xd0, 0x00, 0x00, 0x2f, 0xff, 0x60, 0x20, 0x41, 0x4d, 0x00,
	0x20, 0x50, 0x4d, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
}

var itl1 = []byte{
	0x06, 0x53, 0x75, 0x6e, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x4d, 0x6f, 0x6e, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x07, 0x54, 0x75, 0x65, 0x73, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x57, 0x65, 0x64, 0x6e, 0x65, 0x73, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x54, 0x68, 0x75, 0x72, 0x73, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x46, 0x72, 0x69, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x53, 0x61, 0x74, 0x75, 0x72, 0x64, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x07, 0x4a, 0x61, 0x6e, 0x75, 0x61, 0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x46, 0x65, 0x62, 0x72, 0x75, 0x61, 0x72, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x4d, 0x61, 0x72, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x41, 0x70, 0x72, 0x69, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x4d, 0x61, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x4a, 0x75, 0x6e, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x04, 0x4a, 0x75, 0x6c, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x06, 0x41, 0x75, 0x67, 0x75, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x09, 0x53, 0x65, 0x70, 0x74, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x07, 0x4f, 0x63, 0x74, 0x6f, 0x62, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x4e, 0x6f, 0x76, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x44, 0x65, 0x63, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xff, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x20, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
	0x2c, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xa8, 0x9f, 0x07, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x7a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x01, 0x7c, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x01, 0x7e, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x01, 0x9c, 0x00, 0x00,
	0x00, 0x32, 0x00, 0x00, 0x01, 0xce, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
	0x03, 0x53, 0x75, 0x6e, 0x03, 0x4d, 0x6f, 0x6e, 0x03, 0x54, 0x75, 0x65, 0x03, 0x57, 0x65, 0x64,
	0x03, 0x54, 0x68, 0x75, 0x03, 0x46, 0x72, 0x69, 0x03, 0x53, 0x61, 0x74, 0x00, 0x0c, 0x03, 0x4a,
	0x61, 0x6e, 0x03, 0x46, 0x65, 0x62, 0x03, 0x4d, 0x61, 0x72, 0x03, 0x41, 0x70, 0x72, 0x03, 0x4d,
	0x61, 0x79, 0x03, 0x4a, 0x75, 0x6e, 0x03, 0x4a, 0x75, 0x6c, 0x03, 0x41, 0x75, 0x67, 0x03, 0x53,
	0x65, 0x70, 0x03, 0x4f, 0x63, 0x74, 0x03, 0x4e, 0x6f, 0x76, 0x03, 0x44, 0x65, 0x63, 0x00, 0x02,
	0x01, 0x2d, 0x01, 0x2e,
}
