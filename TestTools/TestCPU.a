    opt     o-,a+ ; disable optimisations BUT keep pc-relative pea's etc

    macro   DebugStr
    pea     LengthByte\@
    dc.w    $ABFF
    bra.s   Skip\@
LengthByte\@
    dc.b    StrEnd\@-StrStart\@
StrStart\@
    dc.b    \1
StrEnd\@
    even
Skip\@
    endm

    macro   n0
    bpl.s   Dont\@
    DebugStr 'BAD: n=1'
Dont\@
    endm

    macro   n1
    bmi.s   Dont\@
    DebugStr 'BAD: n=0'
Dont\@
    endm

    macro   z0
    bne.s   Dont\@
    DebugStr 'BAD: z=1'
Dont\@
    endm

    macro   z1
    beq.s   Dont\@
    DebugStr 'BAD: z=0'
Dont\@
    endm

    macro   v0
    bvc.s   Dont\@
    DebugStr 'BAD: v=1'
Dont\@
    endm

    macro   v1
    bvs.s   Dont\@
    DebugStr 'BAD: v=0'
Dont\@
    endm

    macro   c0
    bcc.s   Dont\@
    DebugStr 'BAD: c=1'
Dont\@
    endm

    macro   c1
    bcs.s   Dont\@
    DebugStr 'BAD: c=0'
Dont\@
    endm

    macro   x0 ; sets z to !x
    move    sr,-(sp)
    btst.b  #4,1(sp)
    addq    #2,sp
    beq.s   Dont\@
    DebugStr 'BAD: x=1'
Dont\@
    endm

    macro   x1 ; sets z to !x
    move    sr,-(sp)
    btst.b  #4,1(sp)
    addq    #2,sp
    bne.s   Dont\@
    DebugStr 'BAD: x=0'
Dont\@
    endm

ApplScratch equ $A78


    DebugStr 'Test: add dn,dn'
    move.w  #$8000,d3
    move.w  #$8000,d4
    add.w   d3,d4
    n0
    z1
    v1
    c1
    x1

    DebugStr 'Test: add an,dn'
    movea.w #$3288,a3
    move.w  #$8968,d3
    add.w   a3,d3
    n1
    z0
    v0
    c0
    x0
    cmp.w   #$bbf0,d3
    z1

    DebugStr 'Test: add (an),dn'
    movea.w #ApplScratch,a3
    move.w  #$9963,(a3)
    move.w  #$4404,d5
    add.w   (a3),d5
    n1
    z0
    v0
    c0
    x0

    DebugStr 'Test: add (an)+,dn'
    movea.w #ApplScratch,a3
    move.w  #$4aa0,(a3)
    move.w  #$4f66,d5
    add.w   (a3)+,d5
    n1
    z0
    v1
    c0
    x0

    DebugStr 'Test: add -(an),dn'
    movea.w #ApplScratch,a3
    move.w  #$d056,(a3)+
    move.w  #$9b8d,d5
    add.w   -(a3),d5
    n0
    z0
    v1
    c1
    x1

    DebugStr 'Test: add d(an),dn'
    movea.w #ApplScratch,a3
    move.w  #$ace9,ApplScratch+10
    move.w  #$139a,d5
    add.w   10(a3),d5
    n1
    z0
    v0
    c0
    x0

    DebugStr 'Test: add d(an,dn),dn'
    movea.w #ApplScratch,a3
    move.w  #10,d0
    move.w  #$cfe0,ApplScratch+20
    move.w  #$3e58,d5
    add.w   10(a3,d0),d5
    n0
    z0
    v0
    c1
    x1

    DebugStr 'Test: add pcrel,dn'
    bra.s   .skip
.x  dc.w    $8f8c
.skip
    move.w  #$fe38,d1
    add.w   (pc,.x),d1
    n1
    z0
    v0
    c1
    x1

    DebugStr 'Test: add pcrel(xn),dn'
    bra.s   .skip
.x  dc.w    $0,$0,$0,$9b56
.skip
    move.w  #6,d0
    move.w  #$bbc5,d1
    add.w   (pc,.x,d0),d1
    n0
    z0
    v1
    c1
    x1

    DebugStr 'Test: add abs.w,dn'
    move.w  #$7ae8,ApplScratch
    move.w  #$e73a,d7
    add.w   (ApplScratch).w,d7
    n0
    z0
    v0
    c1
    x1

    DebugStr 'Test: add abs.l,dn'
    move.w  #$61ba,ApplScratch
    move.w  #$f028,d7
    add.w   (ApplScratch).l,d7
    n0
    z0
    v0
    c1
    x1

    DebugStr 'Test: add #imm,dn'
    move.w  #$fa4e,d7
    add.w   #$8771,d7
    n1
    z0
    v0
    c1
    x1

    DebugStr 'Test: add dn,abs.w'
    move.w  #$2c7e,(ApplScratch).w
    move.w  #$743e,d7
    add.w   d7,(ApplScratch).w
    n1
    z0
    v1
    c0
    x0
    cmp.w   #$A0BC,(ApplScratch).w
    z1

    DebugStr 'Test: addi #imm,dn'
    move.w  #$e27c,d7
    add.w   #$9a70,d7
    n0
    z0
    v1
    c1
    x1

    DebugStr 'Test: addi #imm,abs.w'
    move.w  #$2c21,ApplScratch
    add.w   #$b2aa,(ApplScratch).w
    n0
    z0
    v0
    c0
    x0

    DebugStr 'Test: addq #imm,dn'
    move.w  #$7ffc,d7
    addq.w  #8,d7
    n1
    z0
    v1
    c0
    x0

    DebugStr 'Test: addq #imm,abs.w'
    move.w  #$ffff,ApplScratch
    addq.w  #1,(ApplScratch).w
    n0
    z1
    v0
    c1
    x1

    DebugStr 'Test: addx dn,dn'
    ori     #$10,ccr ; set x bit
    move.l  #$fffffffe,d0
    move.l  #1,d1
    addx.l  d1,d0
    n0
    z0 ; should be preserved from before addx
    v0
    c1
    x1
    tst.l   d0
    z1

    DebugStr 'Test: addx -(an),-(an)'
    lea     ApplScratch+4,a2
    lea     ApplScratch+8,a3
    move.l  #$670ee7f1,-4(a2)
    move.l  #$e800422a,-4(a3)
    move    #$04,ccr ; x=0,z=1
    addx.b  -(a2),-(a3)
    addx.b  -(a2),-(a3)
    addx.b  -(a2),-(a3)
    addx.b  -(a2),-(a3)
    n0
    z0 ; gets cleared if any addx is nonzero
    v0
    c1
    x1
    cmp.l   #$4f0f2a1b,(a3)
    z1

    DebugStr 'Test: and abs.w,dn'
    ori     #$1f,ccr
    move.w  #$9288,d3
    move.w  #$d878,ApplScratch
    and.w   (ApplScratch).w,d3
    n1
    z0
    v0
    c0
    x1 ; untouched
    cmp.w   #$9008,d3
    z1

    DebugStr 'Test: and dn,abs.w'
    andi    #0,ccr
    move.w  #$a11f,d3
    move.w  #$5ee0,ApplScratch ; its inverse
    and.w   d3,(ApplScratch).w
    n0
    z1
    v0
    c0
    x0 ; untouched

    DebugStr 'Test: andi #imm,abs.w'
    andi    #0,ccr
    move.l  #$16dc3b11,ApplScratch
    andi.l  #$3127441d,(ApplScratch).w
    n0
    z0
    v0
    c0
    x0 ; untouched
    cmp.l   #$10040011,ApplScratch
    z1

    DebugStr 'Test: asl dn,dn'
    move.w  #$1003,d0
    move.w  #$5555,d1
    asl.w   d0,d1
    n1
    z0
    v1 ; msb changed in any iteration
    c0
    x0
    cmp.w   #$aaa8,d1
    z1
    asl.w   d0,d1
    n0
    z0
    v1
    c1
    x1
    move.w  #$0000,d1
    asl.w   d0,d1
    v0 ; msb never changed

    DebugStr 'Test: asr dn,dn'
    move    #$02,ccr ; set v only, to confirm it is cleared
    move.w  #$0002,d0
    move.w  #$8002,d1
    asr.w   d0,d1
    n1
    z0
    v0 ; msb changed in any iteration
    c1
    x1

    DebugStr 'Test: asl #imm,dn'
    move.l  #$695f0ebd,d0
    asl.l   #5,d0
    cmp.l   #$2be1d7a0,d0
    z1

    DebugStr 'Test: asr #imm,dn'
    move.l  #$5d10831b,d0
    asr.l   #2,d0
    cmp.l   #$174420c6,d0 ; no sign extension, behold
    z1

    DebugStr 'Test: asr abs.w'
    move.w  #$2244,ApplScratch
    asr.w   (ApplScratch).w
    cmp.w   #$1122,ApplScratch
    z1

    DebugStr 'Test: asl abs.w'
    move.w  #$2244,ApplScratch
    asl.w   (ApplScratch).w
    cmp.w   #$4488,ApplScratch
    z1

    DebugStr 'Test: bchg dn,abs.w'
    move.w  #44,d4
    move.b  #$10,ApplScratch
    bchg.b  d4,ApplScratch.w
    z0
    bchg.b  d4,ApplScratch.w
    z1
    bchg.b  d4,ApplScratch.w
    z0

    DebugStr 'Test: bchg #imm,abs.w'
    move.b  #$10,ApplScratch
    move    #$1f,ccr
    bchg.b  #3,ApplScratch.w
    z1
    bchg.b  #3,ApplScratch.w
    z0
    bchg.b  #3,ApplScratch.w
    z1
    n1 ; all these bits should be untouched...
    v1
    c1
    x1

    DebugStr 'Test: bclr dn,abs.w'
    move.w  #44,d4
    move.b  #$10,ApplScratch
    bclr.b  d4,ApplScratch.w
    z0
    bclr.b  d4,ApplScratch.w
    z1
    bclr.b  d4,ApplScratch.w
    z1

    DebugStr 'Test: bclr #imm,abs.w'
    move.b  #$10,ApplScratch
    bclr.b  #3,ApplScratch.w
    z1
    bclr.b  #3,ApplScratch.w
    z1
    bclr.b  #3,ApplScratch.w
    z1

    DebugStr 'Test: bset dn,abs.w'
    move.w  #44,d4
    move.b  #$10,ApplScratch
    bset.b  d4,ApplScratch.w
    z0
    bset.b  d4,ApplScratch.w
    z0
    bset.b  d4,ApplScratch.w
    z0

    DebugStr 'Test: bset #imm,abs.w'
    move.b  #$10,ApplScratch
    bset.b  #3,ApplScratch.w
    z1
    bset.b  #3,ApplScratch.w
    z0
    bset.b  #3,ApplScratch.w
    z0

    DebugStr 'Test: btst dn,abs.w'
    move.w  #44,d4
    move.b  #$10,ApplScratch
    btst.b  d4,ApplScratch.w
    z0
    btst.b  d4,ApplScratch.w
    z0
    btst.b  d4,ApplScratch.w
    z0

    DebugStr 'Test: btst #imm,abs.w'
    move.b  #$10,ApplScratch
    btst.b  #3,ApplScratch.w
    z1
    btst.b  #3,ApplScratch.w
    z1
    btst.b  #3,ApplScratch.w
    z1

    DebugStr 'Test: chk #imm,dn'
    move.w  #10,d0 ; lame test
    chk     #10,d0

    DebugStr 'Test: clr abs.w'
    move.w  #-1,ApplScratch.w
    tst.w   ApplScratch.w
    z0
    clr.w   ApplScratch.w
    n0
    z1
    v0
    c0
    tst.w   ApplScratch.w
    z1

    DebugStr 'Test: cmp #imm,dn'
    move    #$1f,ccr
    move.w  #$c000,d0
    cmp.w   #$c000,d0
    n0
    z1
    v0
    c0
    x1 ; because we set it above
    cmp.w   #$bfff,d0
    n0
    z0
    v0
    c0
    x1 ; because we set it above
    cmp.w   #$c001,d0
    n1
    z0
    v0
    c1
    x1 ; because we set it above

    DebugStr 'Test: cmpa #imm,an' ; lifted from cmp tests
    move    #$1f,ccr
    move.l  #$ffffc000,a0
    cmpa.w  #$c000,a0
    n0
    z1
    v0
    c0
    x1 ; because we set it above
    cmpa.w  #$bfff,a0
    n0
    z0
    v0
    c0
    x1 ; because we set it above
    cmpa.w  #$c001,a0
    n1
    z0
    v0
    c1
    x1 ; because we set it above

    DebugStr 'Test: cmpi #imm,(an)' ; lifted from cmp tests
    move    #$1f,ccr
    lea     ApplScratch,a0
    move.w  #$c000,(a0)
    cmpi.w  #$c000,(a0)
    n0
    z1
    v0
    c0
    x1 ; because we set it above
    cmpi.w  #$bfff,(a0)
    n0
    z0
    v0
    c0
    x1 ; because we set it above
    cmpi.w  #$c001,(a0)
    n1
    z0
    v0
    c1
    x1 ; because we set it above

    DebugStr 'Test: cmpm (an)+,(an)+'
    move    #$1f,ccr
    lea     ApplScratch,a0
    lea     ApplScratch+2,a1
    move.l  #$01010100,(a0)
    cmpm.b  (a0)+,(a1)+
    n0
    z1
    v0
    c0
    x1 ; because we set it above
    cmpm.b  (a0)+,(a1)+
    n1
    z0
    v0
    c1
    x1 ; because we set it above

    DebugStr 'Test: dbf dn,targ'
    clr.l   d3
    move.l  #$1000f,d0 ; top should be ignored, do 16 iterations
.lp addq.l  #1,d3
    dbf     d0,.lp
    cmp.l   #$10,d3
    z1
    cmp.l   #$0001ffff,d0
    z1

    DebugStr 'Test: dbeq dn,targ'
    clr.l   d3
    move.l  #$1000f,d0 ; top should be ignored, do 16 iterations
.lp addq.l  #1,d3
    cmp.w   #8,d3 ; only do half the iterations
    dbeq    d0,.lp
    cmp.l   #$8,d3 ; did the right number of iterations?
    z1
    cmp.l   #$00010007,d0 ; would pick up where we left off and do the other half
    z1

    DebugStr 'Test: divu #imm,dn'
    move.l  #10,d0
    divu    #3,d0
    n0
    z0
    v0
    c0
    cmp.l   #$00010003,d0
    z1

    DebugStr 'Test: divs #imm,dn'
    move.l  #10,d0
    divu    #3,d0
    n0
    z0
    v0
    c0
    cmp.l   #$00010003,d0 ; q3 r1
    z1

    move.l  #10,d0
    divs    #-3,d0
    n1
    z0
    v0
    c0
    cmp.l   #$0001fffd,d0 ; q-3 r1
    z1

    move.l  #-10,d0
    divs    #3,d0
    n1
    z0
    v0
    c0
    cmp.l   #$fffffffd,d0 ; q-3 r-1
    z1

    move.l  #-10,d0
    divs    #-3,d0
    n0
    z0
    v0
    c0
    cmp.l   #$ffff0003,d0 ; q3 r-1
    z1

    DebugStr 'Test: eor dn,abs.w'
    move    #$03,ccr
    move.l  #$4328736d,ApplScratch
    move.l  #$cbcca890,d0
    eor.l   d0,ApplScratch.w
    n1
    z0
    v0
    c0
    cmp.l   #$88e4dbfd,ApplScratch
    z1

    DebugStr 'Test: eori #imm,abs.w'
    move    #$03,ccr
    move.l  #$bf1f5142,ApplScratch
    eori.l  #$e626941d,ApplScratch.w
    n0
    z0
    v0
    c0
    cmp.l   #$5939c55f,ApplScratch
    z1

    DebugStr 'Test: eori #imm,ccr'
    move    #$00,ccr
    eori    #$1f,ccr
    move    sr,d0
    cmpi.b  #$1f,d0
    z1

    DebugStr 'Test: exg dn,dn'
    move.l  #-1,d0
    move.l  #1,d1
    exg     d0,d1
    cmp.l   #1,d0
    z1
    cmp.l   #-1,d1
    z1

    DebugStr 'Test: exg an,dn'
    move.l  #-1,d0
    move.l  #1,a1
    exg     d0,a1
    cmp.l   #1,d0
    z1
    cmp.l   #-1,a1
    z1

    DebugStr 'Test: exg an,an'
    move.l  #-1,a0
    move.l  #1,a1
    exg     a0,a1
    cmp.l   #1,a0
    z1
    cmp.l   #-1,a1
    z1

    DebugStr 'Test: ext.l dn'
    move.l  #$736f8c72,d4
    ext.l   d4
    n1
    z0
    v0
    c0
    cmp.l   #$ffff8c72,d4
    z1

    DebugStr 'Test: ext.w dn'
    move.l  #$736f8c72,d4
    ext.w   d4
    n0
    z0
    v0
    c0
    cmp.l   #$736f0072,d4
    z1

    DebugStr 'Test: ext.w dn'
    move.l  #$736f8c72,d4
    ext.w   d4
    n0
    z0
    v0
    c0
    cmp.l   #$736f0072,d4
    z1

    DebugStr 'Test: jmp (d,pc,xn)'
    move.l  #$1111fffc,a0
    jmp     (pc,jmpx+4,a0.w)
    DebugStr 'BAD: fell short'
jmpx
    bra.s   jmpy
    DebugStr 'BAD: fell long'
jmpy

    DebugStr 'Test: jsr (d,pc)'
    jsr     jsrx
    bra.s   jsry
jsrx
    rts
jsry

    DebugStr 'Test: lea d(an),an'
    move.l  #$00014000,a0
    lea     -$8000(a0),a1
    cmp.l   #$0000c000,a1
    z1

    DebugStr 'Test: link a6,#imm'
    move.l  #$12345678,a6
    lea     -4(sp),a0
    move.l  a6,a1
    lea     -14(sp),a2
    link    a6,#-10
    cmp.l   a6,a0
    z1
    cmp.l   (a6),a1
    z1
    cmp.l   sp,a2
    z1
    add.w   #14,sp

    DebugStr 'Test: lsr dn'
    move.w  #$8111,d0
    move    #$02,ccr ; set v to see it cleared
    lsr.w   d0
    n0
    z0
    v0
    c1
    x1
    cmp.w   #$4088,d0
    z1

    DebugStr 'Test: lsl dn'
    move.w  #$c111,d0
    move    #$02,ccr ; set v to see it cleared
    lsl.w   d0
    n1
    z0
    v0
    c1
    x1
    cmp.w   #$8222,d0
    z1

; Useful: prints data regs
;    DebugStr 'python: print(mem[regs:][:32].hex())'


    DebugStr 'finished tests'
    dc.w    $A9F4
