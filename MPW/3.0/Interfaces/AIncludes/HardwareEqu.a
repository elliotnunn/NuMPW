; Version: 1.04
; Created: Tuesday, August 2, 1988 at 9:29:09 PM
;
; File: HardwareEqu.a
;
; Assembler Interface to the Macintosh Libraries
; Copyright Apple Computer, Inc. 1984-1988
; All Rights Reserved
;
;--------------------------------------------------------------------
;
; The following information was formerly in "private" files that were
; not released to the general developer community.
;
; The information in this file is not needed for normal application
; development. These equates and macros were necessary for development
; of the Macintosh ToolBox and Operating System, and are likely to be
; dependent on their current implementation. Use of any information
; in this file is likely to cause your software to fail on future
; versions of Macintosh system software or hardware.
;
; Apple Developer Support will not support any use of the following
; information.
;
; In order to prevent any "accidental" use of this information, it has
; been disabled using the conditional-assembly variable, HWNonPortable,
; defined below. If you change this to a non-zero value, you're on your
; own. Since this gives hardware specific equates, we must also define
; which type of Mac we are assembling for. Define the following variable:
;
;			onMac if for 128K, 512K, 512Ke, or Mac+
;			onMacPP if for MacSE
;			onNuMac if for Macintosh II
;
; Hardware Equates -- This file defines the low-level equates for the
; Macintosh hardware interface.
;--------------------------------------------------------------------

; If HWNonPortable is defined to be non-zero, Then a machine type must be specified!
				IF			(&TYPE('HWNonPortable') = 'UNDEFINED') THEN
HWNonPortable	EQU 		0
				ENDIF

				IF			HWNonPortable THEN

				IF			(&TYPE('onMac') = 'UNDEFINED') THEN 
onMac			EQU 		1
				ENDIF

				IF			(&TYPE('onMacPP') = 'UNDEFINED') THEN
onMacPP 		EQU 		0
				ENDIF

				IF			(&TYPE('onNuMac') = 'UNDEFINED') THEN
onNuMac 		EQU 		0
				ENDIF

; Machine Configuration

				IF			onMac THEN				; ----- Mac -----

machine 		EQU 		0
rom85Bits		EQU 		$7F 					; New ROMs, No Power Off.

				ELSEIF		onNuMac THEN			; ----- NuMac -----
machine 		EQU 		1
rom85Bits		EQU 		$3F 					; New ROMs, Power Off ability.

				ELSEIF		onMacPP THEN			; ----- MacPP -----
machine 		EQU 		2
rom85Bits		EQU 		$7F 					; New ROMs, No Power Off.

				ENDIF
DiagROM 		EQU 		$F80000 				; Alternate ROM - initial vector
DiagROM1		EQU 		$F80080 				; Alternate ROM - memory sizing vector
DiagROM2		EQU 		$F80088 				; Alternate ROM - init I/O vector
PhaseRead		EQU 		$F00000 				; Phase read address (StartMain)


;----------
; Processor Interrupt Masks
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
hiIntMask		EQU 		$0300
loIntMask		EQU 		$0100
viaIntMask		EQU 		$0100					; mask for VIA (and VBL) interrupts
sccEnblMask 	EQU 		$F9FF					; mask to enable SCC interrupts
sccIntMask		EQU 		$200					; SCC interrupt vector

				ELSEIF		onNuMac THEN			; ----- NuMac -----
hiIntMask		EQU 		$0700					; mask for all interrupts
sccIntMask		EQU 		$0400					; SCC interrupt vector
via2IntMask 	EQU 		$0200					; VIA2 interrupt vector
slotIntMask 	EQU 		via2IntMask 			; slot's interrupt vector
viaIntMask		EQU 		$0100					; VIA interrupt vector
loIntMask		EQU 		$0100
sccEnblMask 	EQU 		$FBFF					; mask to enable SCC interrupts
pwrOffEnbl		EQU 		$2500					; mask to allow poweroff interrupts

				ELSEIF		onMacXL THEN			; ----- MacXL -----
hiIntMask		EQU 		$0600					; mask for all interrupts (except NMI)
loIntMask		EQU 		$0100
				ENDIF


;----------
; Timing constants
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
oneSec			EQU 		95528					; looptimes
halfSec 		EQU 		oneSec/2
oneSecTicks 	EQU 		60						; ticks, of course
stlDelay		EQU 		$30 					; default bus settle delay

				ELSEIF		onNuMac THEN			; ----- NuMac -----
oneSec			EQU 		382112					; looptimes
halfSec 		EQU 		oneSec/2
oneSecTicks 	EQU 		60						; ticks, of course
stlDelay		EQU 		$30 					; default bus settle delay
				ENDIF


;----------
; Toolbox Trap Table equates
;----------

numOsTrap		EQU 		256 					; number of os traps

				IF			onMac THEN				; ----- Mac -----
ToolTable		EQU 		$0C00					; start of toolbox trap table

				ELSE								; ----- Everyone Else -----
ToolTable		EQU 		$0E00					; start of toolbox trap table
				ENDIF

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
numTbTrap		EQU 		512 					; number of toolbox traps
numTrapMask 	EQU 		$01FF					; mask for number of tb traps

				ELSEIF		onNuMac THEN			; ----- NuMac -----
numTbTrap		EQU 		1024					; number of toolbox traps
numTrapMask 	EQU 		$03FF					; mask for number of tb traps
				ENDIF


;----------
; Screen, Sound, ROM, RAM addresses
;----------

ramChk			EQU 		1024					; Amount of memory tested for stack.
OvlyRAM 		EQU 		$600000 				; low RAM address when overlay is on
OvlyScreen		EQU 		$67A700 				; top of screen with overlay


				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
SoundLow		EQU 		$3FFD00 				; sound buffer start address
PWMBuffer		EQU 		$3FFD01 				; PWM bytes are low bytes
ROMStart		EQU 		$400000 				; starting address of ROM code
ScreenLow		EQU 		$3FA700 				; top of screen screen address
SERegs			EQU 		$3FFC80 				; Sys Error Regs w/o Overlay
SEScrnNum		EQU 		$3FD3DD 				; Sys Error Number Screen address =$7CB5E+64*34 - 1
; "vaguely centered" plus 34 scanlines -1 for extra digit
SEScrnInc		EQU 		$3FD5DF 				; address to diddle below death number
SEScrnIcon		EQU 		$3FCB5E 				; centered screen addr for Mac icons
SEScrnFace		EQU 		$3FCCDF 				; screen addr for face
SEScrnI2		EQU 		$3FCF1F 				; screen addr for boot icon overlay

				ELSEIF		onNuMac THEN			; ----- NuMac -----
ROMStart		EQU 		$40800000				; starting address of final ROM code
ROM_hi			EQU 		$40 					; high byte of ROM address
MaxAdr			EQU 		$800000 				; max RAM search address (8 MB)
ramSiz			EQU 		$40 					; VIA2 bits setting to control RAM size
SERegs			EQU 		$0C30					; offset to Sys Error Regs w/o Overlay
SEOvlyRegs		EQU 		SERegs					; no overlay space for NuMac

; offsets to various screen locations (tied to base address of screen)

SEScrnNum		EQU 		$57A7					; Sys Error Number Screen address = $46A8+(128*34) - 1
; "vaguely centered" plus 34 scanlines -1 for extra digit
SEScrnInc		EQU 		$4AAA					; address to diddle below death number=$46A8+(128*8)+2
SEScrnIcon		EQU 		$46A8					; centered screen addr for NuMac icons
SEScrnFace		EQU 		$49A9					; screen addr for face = $46A8+(128*6)+1
SEScrnI2		EQU 		$4E29					; screen addr for boot icon overlay=$46A8+(128*15)+1
				ENDIF

				IF			onMac THEN				; ----- Mac -----
ROMDoEject		EQU 		$40001E 				; jump to DoEject utility
HeapStart		EQU 		$1400					; Mac Plus starting point
defSysHeap		EQU 		$B700					; Default size of the system heap
nDfltStackSize	EQU 		$2000					; Default stack size
				ENDIF

				IF			onMacPP THEN			; ----- MacPP -----
ROMDoEject		EQU 		$40001E 				; jump to DoEject utility
HeapStart		EQU 		$1600					; Aladdin starting point
defSysHeap		EQU 		$18000					; Default size of the system heap
nDfltStackSize	EQU 		$2000					; Default stack size
				ENDIF

				IF			onNuMac THEN			; ----- NuMac -----
ROMDoEject		EQU 		$4080001E				; jump to DoEject utility
HeapStart		EQU 		$1E00					; need extra lomem for color quickdraw
defSysHeap		EQU 		$18000					; Default size of the system heap
nDfltStackSize	EQU 		$6000					; Default stack size
				ENDIF


;----------
; Screen, sound, ROM, RAM constants & offsets
;----------

; Following should be defined for only Mac &
; MacPP, but this info not in video ROMS yet...
scrnHorRes		EQU 		72						; number of dots per inch horizontally
scrnVertRes 	EQU 		72						; number of dots per inch vertically
pwm2MemTop		EQU 		$2FF					; PWMBuffer to MemTop
snd2MemTop		EQU 		$300					; SoundLow to Memtop
sndBufWLen		EQU 		$0172					; sound/disk buffer word length

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
scrn2MemTop 	EQU 		$5900					; ScreenBase to Memtop
scrnRowB		EQU 		64						; bytes per scan line
maxX			EQU 		512 					; number of pixels horizontally
maxY			EQU 		342 					; number of pixels vertically
screenWidth 	EQU 		maxX					; screen width
screenHeight	EQU 		maxY					; screen height
scrnBytes		EQU 		21888					; scrnRowB*maxY
bufWorldSize	EQU 		scrn2MemTop 			; total size of the BufPtr world

				ELSEIF		onNuMac THEN			; ----- NuMac -----
bufWorldSize	EQU 		snd2MemTop				; total size of the BufPtr world
				ENDIF

				IF			onMac THEN				; ----- Mac -----
romWSize		EQU 		$10000					; 64K words in present ROM
romBSize		EQU 		$20000					; 128K bytes in present ROM

				ELSEIF		onNuMac|onMacPP THEN	; ----- NuMac, MacPP -----
romWSize		EQU 		$20000					; 128K words in present ROM
romBSize		EQU 		$40000					; 256K bytes in present ROM
				ENDIF


;----------
; Deep Shit Rectangle info
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
dsRectTL		EQU 		$00400020				; top left = 64,32
dsRectBR		EQU 		$00BE01E0				; bottom right = 190,480

				ELSEIF		onNuMac THEN
													; ----- NuMac -----
dsRectTL		EQU 		$00400020				; top left = 64,32
dsRectBR		EQU 		$00BE01E0				; bottom right = 190,480
dsRectHei		EQU 		(dsRectBR**$FFFF0000)-(dsRectTL**$FFFF0000)>>16
dsRectLen		EQU 		(dsRectBR**$FFFF)-(dsRectTL**$FFFF)
				ENDIF


;----------
; System Error, ROM Based Debugger Nub, MicroBug Equates
;----------

				IF			onMac|onMacPP|onNuMac THEN
														; ----- Mac, MacPP, NuMac -----

SEVars			EQU 		SERegs					; start of system error data space (wrap city)
seVSize 		EQU 		128 					; # of bytes in space
SED0			EQU 		SEVars					; loc of saved reg D0
SEA0			EQU 		SED0+32 				; loc of saved reg A0
SEA7			EQU 		SEA0+28 				; loc of saved reg A7
SEPC			EQU 		SEA7+4					; loc of saved PC
SESR			EQU 		SEPC+4					; loc of saved SR
SEAccess		EQU 		SESR+2					; PC address during bus/address error
SECmdSize		EQU 		SEAccess+4				; # of bytes of parameters passed in _debugger call
SE000BE 		EQU 		SECmdSize+2 			; 8 bytes of bus error info for 68000
SELastVar		EQU 		SE000BE+8				; last var in System Error data space


;-----
; ROM based debugger nub
;-----

rdPort			EQU 		SELastVar				; Number of port currently in use (0 => no link, 1 => A, 2 => B)
rdCode			EQU 		rdPort+2				; Ptr to code download buffer.
rdAtrap 		EQU 		rdCode+4				; Saved Rom Atrap handler
rdLowTrap		EQU 		rdAtrap+4				; low value for trap handling
rdHiTrap		EQU 		rdLowTrap+2 			; high value for trap handling
rdResult		EQU 		rdHiTrap+2				; result of executing down-loaded code, etc. (16 bytes)
rdEnd			EQU 		rdResult+16 			; end of vars


;-----
; Microbug
;-----

; NOTE: Keep mbDotAddr immediately before mBlocAddr

mbBufSize		EQU 		34
mbBuffer		EQU 		SELastVar				; buffer for input
mbSign			EQU 		mbBuffer+mbBufSize		; ST => negative sign during conversion
mbDotAddr		EQU 		mbSign+2				; saved address
mBlocAddr		EQU 		mbDotAddr+4 			; saved location
				ENDIF


;----------
; VIA (6522) interface chip addresses
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
VBase			EQU 		$EFE1FE 				; base address
AVBufB			EQU 		$EFE1FE 				; buffer B
AVBufA			EQU 		$EFFFFE 				; buffer A
AVBufM			EQU 		$EFE1FE 				; buffer with mouse button bit
AVIFR			EQU 		$EFFBFE 				; interrupt flag register
AVIER			EQU 		$EFFDFE 				; interrupt enable register

				ELSEIF		onNuMac THEN	; ----- NuMac -----
VBase			EQU 		$50F00000				; base address
AVBufB			EQU 		VBase					; buffer B
AVBufA			EQU 		$50F01E00				; buffer A
AVBufM			EQU 		VBase					; buffer with mouse button bit
AVIFR			EQU 		$50F01A00				; interrupt flag register
AVIER			EQU 		$50F01C00				; interrupt enable register
VBase2			EQU 		$50F02000				; base for 2nd VIA
				ENDIF


;----------
; VIA offsets
;----------

				IF			onMac|onMacPP|onNuMac THEN
														; ----- Mac, MacPP, NuMac -----
vBufB			EQU 		0						; BUFFER B
vBufAH			EQU 		$200					; buffer a (with handshake) [ Dont use! ]
vDIRB			EQU 		$400					; DIRECTION B
vDIRA			EQU 		$600					; DIRECTION A
vT1C			EQU 		$800					; TIMER 1 COUNTER (L.O.)
vT1CH			EQU 		$A00					; timer 1 counter (high order)
vT1L			EQU 		$C00					; TIMER 1 LATCH (L.O.)
vT1LH			EQU 		$E00					; timer 1 latch (high order)
vT2C			EQU 		$1000					; TIMER 2 LATCH (L.O.)
vT2CH			EQU 		$1200					; timer 2 counter (high order)
vSR 			EQU 		$1400					; SHIFT REGISTER
vACR			EQU 		$1600					; AUX. CONTROL REG.
vPCR			EQU 		$1800					; PERIPH. CONTROL REG.
vIFR			EQU 		$1A00					; INT. FLAG REG.
vIER			EQU 		$1C00					; INT. ENABLE REG.
vBufA			EQU 		$1E00					; BUFFER A
vBufD			EQU 		$1E00					; disk head select buffer
				ENDIF

				IF			onMac THEN				; ----- Mac -----
; === BUFFER A ===
vAOut			EQU 		$7F 					; VBufA output bits
vAInit			EQU 		$69 					; VBufA initial values (low volume)
vSound			EQU 		$7						; sound volume bits
vSndPg2 		EQU 		3						; select sound page 2 if 0
vOverlay		EQU 		4						; overlay bit (overlay when 1)
vHeadSel		EQU 		5
vPage2			EQU 		6						; select video page 2 if 0
vSCCWrReq		EQU 		7						; SCC write/request line

; === BUFFER B ===
vBOut			EQU 		$87 					; VBufB output bits
vBInit			EQU 		$87 					; VBufB initial values
rtcData 		EQU 		0
rtcClk			EQU 		1
rtcEnb			EQU 		2						; enabled when 0
vSW 			EQU 		3						; mouse switch (0 when down)
vX2 			EQU 		4						; mouse X level
vY2 			EQU 		5						; mouse Y level
vH4 			EQU 		6						; horizontal sync
vSndEnb 		EQU 		7						; /sound enable (reset when 1)

				ELSEIF		onMacPP THEN			; ----- MacPP -----
; === BUFFER A ===
vAOut			EQU 		$7F 					; VBufA output bits
vAInit			EQU 		$69 					; VBufA initial values (low volume)
vSound			EQU 		$7						; sound volume bits
vSndPg2 		EQU 		3						; select sound page 2 if 0
vDriveSel		EQU 		4						; int drive select (lower drive when 1)
vHeadSel		EQU 		5
vPage2			EQU 		6						; select video page 2 if 0
vSCCWrReq		EQU 		7						; SCC write/request line

; === BUFFER B ===
vBOut			EQU 		$C7 					; VBufB output bits
vBInit			EQU 		$C7 					; VBufB initial values
rtcData 		EQU 		0
rtcClk			EQU 		1
rtcEnb			EQU 		2						; enabled when 0
vFDBInt 		EQU 		3						; Front Desk bus interrupt
vFDesk1 		EQU 		4						; bit for front desk bus
vFDesk2 		EQU 		5						; and another
vH4 			EQU 		6						; SCSI IRQ mask (was horiz. sync)
vSndEnb 		EQU 		7						; /sound enable (reset when 1)

; ELSE ; ----- NuMac -----
				ELSEIF		onNuMac THEN			; ----- NuMac -----

; === VIA1 BUFFER A ===
vAOut			EQU 		$3F 					; VBufA output bits
vAInit			EQU 		$01 					; VBufA initial values (low volume)
vSound			EQU 		$7						; sound volume bits (1..3)
vSync			EQU 		3						; Synchronous modem
vOverlay		EQU 		4						; overlay bit (overlay when 1)
vHeadSel		EQU 		5						; head select line for Sony
vRev8Bd 		EQU 		6						; =0 for rev 8 board
vSCCWrReq		EQU 		7						; SCC write/request line

; === VIA1 BUFFER B ===
vBOut			EQU 		$87 					; VBufB output bits
vBInit			EQU 		$07 					; VBufB initial values
vRTCData		EQU 		0						; real time clock data
vRTCClk 		EQU 		1						; real time clock clock pulses
vRTCEnb 		EQU 		2						; clock enable (0 for enable)
vFDBInt 		EQU 		3						; Front Desk bus interrupt
vFDesk1 		EQU 		4						; bit for front desk bus
vFDesk2 		EQU 		5						; and another

; === VIA1 IFR bits ===
ifCA2			EQU 		0						; CA2, ONESEC interrupt
ifCA1			EQU 		1						; CA1, VBL signal
ifSR			EQU 		2						; SR done, Serial i/o to Servo
ifCB2			EQU 		3						; CB2, Clock data
ifCB1			EQU 		4						; CB1, for clock pulse
ifT2			EQU 		5						; T2, INDEX pulse counter (VBL ctr)
ifT1			EQU 		6						; T1, (unused as interrupt)
ifIRQ			EQU 		7						; any interrupt

; === VIA2 BUFFER A ===
v2AOut			EQU 		$C0 					; V2BufA output bits
v2AInit 		EQU 		$00 					; V2BufA initial values
v2RAMS			EQU 		$C						; RAM size bits (6,7)
v2IRQ1			EQU 		0						; slot 1 interrupt
v2IRQ2			EQU 		1						; slot 2 interrupt
v2IRQ3			EQU 		2						; slot 3 interrupt
v2IRQ4			EQU 		3						; slot 4 interrupt
v2IRQ5			EQU 		4						; slot 5 interrupt
v2IRQ6			EQU 		5						; slot 6 interrupt
v2RAM0			EQU 		6						; RAM size bit 0
v2RAM1			EQU 		7						; RAM size bit 1

; === VIA2 BUFFER B ===
v2BOut			EQU 		$80 					; V2BufB output bits
v2BInit 		EQU 		$05 					; V2BufB initial values
v2CDis			EQU 		0						; cache disable (when 0)
v2BusLk 		EQU 		1						; Bus lockout
v2PowerOff		EQU 		2						; soft power off signal (when 0)
vFC3			EQU 		3						; PMMU FC3 indicator
v2TM1A			EQU 		4						; bit for NUBus
v2TM0A			EQU 		5						; and another
v2SCSIRQ		EQU 		6						; SCSI interrupt request
v2VBL			EQU 		7						; pseudo VBL signal
; ENDIF ; {onOldNu}
				ENDIF								; {onNuMac}


;----------
; Timing constants
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
ticksPr100		EQU 		78						; timer 1 setting for 100 usec intervals
oneSecConst 	EQU 		2						; gets converted to $20000 for oneSec constant
flashDly		EQU 		4						; icon flash delay count
nTicks			EQU 		780 					; 780 ticks per msec

				ELSEIF		onNuMac THEN			; ----- NuMac -----
ticksPr100		EQU 		78						; timer 1 setting for 100 usec intervals
oneSecConst 	EQU 		8						; gets converted to $80000 for oneSec constant
flashDly		EQU 		8						; icon flash delay count
onemsDBRA		EQU 		$0A3C					; about 1ms DBRA loop for Mac ][ (same as TimeDBRA)
nTicks			EQU 		780 					; 780 ticks per msec
				ENDIF


;----------
; SCC Serial Chip Addresses
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
SCCRBase		EQU 		$9FFFF8 				; SCC base read address
SCCWBase		EQU 		$BFFFF9 				; SCC base write address

				ELSEIF		onNuMac THEN			; ----- NuMac -----
SCCRBase		EQU 		$50F04000				; SCC base read address
SCCWBase		EQU 		$50F04000				; SCC base write address
				ENDIF


;----------
; SCC Offsets
;----------

aData			EQU 		6						; offset for A channel data
aCtl			EQU 		2						; offset for A channel control
bData			EQU 		4						; offset for B channel data
bCtl			EQU 		0						; offset for B channel control
sccData 		EQU 		4						; general offset for data from control
rxBF			EQU 		0						; SCC receive buffer full
txBE			EQU 		2						; SCC transmit buffer empty


				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
sccWrite		EQU 		$200001 				; general offset for write from read

				ELSEIF		onNuMac THEN			; ----- NuMac -----
sccWrite		EQU 		$0						; general offset for write from read
				ENDIF


;----------
; SCC Clock Rates, Baud Rate Constants
;----------

macClock		EQU 		36707					; in Hz * 100
midMacClock 	EQU 		39168
nuMacClock		EQU 		36864
lisaAClock		EQU 		40000					; port A clock
lisaBCLock		EQU 		36864					; port B clock
macConst		EQU 		114709					; in Hz/32
midMacConst 	EQU 		122400
nuMacConst		EQU 		115200
lisaAConst		EQU 		125000
lisaBConst		EQU 		115200


;----------
; IWM Chip Addresses
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
DBase			EQU 		$DFE1FF 				; disk address base
DPh0L			EQU 		$DFE1FF 				; phase 0 low
DPh0H			EQU 		$DFE3FF 				; phase 0 high
DMtrOff 		EQU 		$DFF1FF 				; IWM Motor off
DMtrOn			EQU 		$DFF3FF 				; IWM Motor on
DiskQ6L 		EQU 		$DFF9FF 				; shift register
DiskQ6H 		EQU 		$DFFBFF
DiskQ7L 		EQU 		$DFFDFF
DiskQ7H 		EQU 		$DFFFFF

				ELSEIF		onNuMac THEN			; ----- NuMac -----
OldIWMBase		EQU 		$50F1C000				; old disk address base
NewIWMBase		EQU 		$50F16000				; new disk address base
				ENDIF


;----------
; IWM Offsets
;----------

ph0L			EQU 		0						; disk address offsets from base
ph0H			EQU 		$200
ph1L			EQU 		$400
ph1H			EQU 		$600
ph2L			EQU 		$800
ph2H			EQU 		$A00
ph3L			EQU 		$C00
ph3H			EQU 		$E00
mtrOff			EQU 		$1000
mtrOn			EQU 		$1200
intDrive		EQU 		$1400					; enable internal drive address
extDrive		EQU 		$1600					; enable external drive address
q6L 			EQU 		$1800
q6H 			EQU 		$1A00
q7L 			EQU 		$1C00
q7H 			EQU 		$1E00


;----------
; Interrupt Auto-vector and Exception Definitions
;----------

Line1010		EQU 		$28 					; 1010 emulator trap (system routines)
Line1111		EQU 		$2C 					; 1111 emulator trap (reserved)
FmtErrVect		EQU 		$38 					; format error vector for 68010/68020
AutoInt1		EQU 		$64 					; level 1 auto-vector
AutoInt2		EQU 		$68 					; level 2 auto-vector
AutoInt3		EQU 		$6C 					; level 3 auto-vector
AutoInt4		EQU 		$70 					; level 4 auto-vector
AutoInt5		EQU 		$74 					; level 5 auto-vector
AutoInt6		EQU 		$78 					; level 6 auto-vector
AutoInt7		EQU 		$7C 					; level 7 auto-vector


;----------
; 53C80 SCSI Chip Addresses
;----------

				IF			onMac THEN				; ----- Mac -----

SCSIRd			EQU 		$580000 				; base addr SCSI interface - READ
SCSIWr			EQU 		$580001 				; base addr SCSI interface - WRITE
wrOffs			EQU 		1						; write addrs are +1 to the read base

				ELSEIF		onMacPP THEN			; ----- MacPP -----
SCSIRd			EQU 		$5FF000 				; base addr SCSI interface - READ
SCSIWr			EQU 		$5FF001 				; base addr SCSI interface - WRITE
MacSCSIBase 	EQU 		$5FF000 				; base addr SCSI READ interface
MacSCSIDMA		EQU 		$5FF200 				; base addr SCSI DMA
MacSCSIHsk		EQU 		$5FF200 				; base addr SCSI handshake
wrOffs			EQU 		1						; write addrs are +1 to the read base
TimeSCSIDB		EQU 		$0B24					; DBRAs & SCSI access per millisecond

				ELSEIF		onNuMac THEN			; ----- NuMac -----
OldSCSIBase 	EQU 		$50F10000				; base addr SCSI interface
OldSCSIDMA		EQU 		$50F14000				; base addr SCSI DMA
OldSCSIHsk		EQU 		$50F08000				; base addr handshake
NewSCSIBase 	EQU 		$50F10000				; rev8 base addr SCSI interface
NewSCSIDMA		EQU 		$50F12000				; rev8 base addr SCSI DMA (corrected)
NewSCSIHsk		EQU 		$50F06000				; rev8 base addr SCSI handshake
wrOffs			EQU 		0						; write addrs are same as read base
SCSIVct 		EQU 		AutoInt3				; SCSI int at level 3
TimeSCSIDB		EQU 		$0DA6					; DBRAs & SCSI access per millisecond

				ENDIF


;----------
; 53C80 Register Defs, Offsets
;----------

				IF			onMac|onMacPP THEN		; ----- Mac, MacPP -----
;(these are handshaking on MacPP)
dACKRd			EQU 		$200					; offset of psuedo-DMA - READ
dACKWr			EQU 		$200					; offset of psuedo-DMA - WRITE
				ENDIF


sCDR			EQU 		$00 					; Current SCSI Read Data
sODR			EQU 		$00 					; Output data register
sICR			EQU 		$10 					; Initiator Command Register - READ/WRITE
iRST			EQU 		$80 					; *RST asserted
iAIP			EQU 		$40 					; arbitration in progress (read)
bAIP			EQU 		6						; bit test for arbitration in progress
aTMD			EQU 		$40 					; assert Test Mode (write)
iLA 			EQU 		$20 					; Lost arbitration (read)
bLA 			EQU 		5						; bit test for Lost Arbitration
aDIFF			EQU 		$20 					; assert Differential enable (write)
iACK			EQU 		$10 					; *ACK is asserted
iBSY			EQU 		$08 					; *BSY is asserted
iSEL			EQU 		$04 					; *SEL is asserted
iATN			EQU 		$02 					; *ATN is asserted
iDB 			EQU 		$01 					; Data bus is asserted
sMR 			EQU 		$20 					; Mode Register - READ/WRITE
iBDMA			EQU 		$80 					; Block Mode DMA
iTGT			EQU 		$40 					; Target Mode
iPTY			EQU 		$20 					; Enable Parity Checking
iIPTY			EQU 		$10 					; Enable Parity interrupt
iIEOP			EQU 		$08 					; Enable EOP interrupt
iMBSY			EQU 		$04 					; Monitor BSY
iDMA			EQU 		$02 					; DMA Mode
iARB			EQU 		$01 					; Arbitration
sTCR			EQU 		$30 					; Target Command Register - READ/WRITE
iREQ			EQU 		$08 					; Assert *REQ
iMSG			EQU 		$04 					; Assert *MSG
iCD 			EQU 		$02 					; Assert C/*D
iIO 			EQU 		$01 					; Assert I/*O
sCSR			EQU 		$40 					; Current SCSI Bus Status (READ)
aRST			EQU 		$80 					; *RST
aBSY			EQU 		$40 					; *BSY
bBSY			EQU 		6						; bit test for *BSY
aREQ			EQU 		$20 					; *REQ
bREQ			EQU 		5						; bit test for *REQ
aMSG			EQU 		$10 					; *MSG
bMSG			EQU 		4						; bit test for *MSG
aCD 			EQU 		$08 					; C/*D
bCD 			EQU 		3						; bit test for C/*D
aIO 			EQU 		$04 					; I/*O
bIO 			EQU 		2						; bit test for I/*O
aSEL			EQU 		$02 					; *SEL
bSEL			EQU 		1						; bit test for *SEL
aDBP			EQU 		$01 					; *DBP
sSER			EQU 		$40 					; Select Enable Register (WRITE)
sBSR			EQU 		$50 					; Bus & Status Register (READ)
iEDMA			EQU 		$80 					; End of DMA
bEDMA			EQU 		7						; bit test for end of DMA
iDMAR			EQU 		$40 					; DMA Request
bDMAR			EQU 		6						; bit test for DMA Req
iPERR			EQU 		$20 					; Parity Error
iIREQ			EQU 		$10 					; Interrupt Request
bIREQ			EQU 		4						; bit test for interrupt
iPM 			EQU 		$08 					; Phase Match
bPM 			EQU 		3						; bit test for Phase Match
iBERR			EQU 		$04 					; Bus Error
ATN 			EQU 		$02 					; *ATN
ACK 			EQU 		$01 					; *ACK
bACK			EQU 		0						; bit test for ACK
sDMAtx			EQU 		$50 					; DMA Transmit Start (WRITE)
sIDR			EQU 		$60 					; Data input register (READ)
sTDMArx 		EQU 		$60 					; Start Target DMA receive (WRITE)
sRESET			EQU 		$70 					; Reset Parity/Interrupt (READ)
sIDMArx 		EQU 		$70 					; Start Initiator DMA receive (WRITE)



;----------
; Apple Sound Chip Addresses
;----------

				IF			onNuMac THEN			; ----- NuMac -----
;SoundChip EQU $50F18000 ; Base of sound chip's address space
OldSndBase		EQU 		$50F18000				; old sound chip's base address
NewSndBase		EQU 		$50F14000				; rev8 sound chip's base address
				ENDIF


;----------
; Hardware configuration bits.
;----------

;the following goes with hwCfgFlags 

hwCbSCSI		EQU 		15						; SCSI port present
hwCbClock		EQU 		14						; New clock chip present
hwCbExPRAM		EQU 		13						; Extra Parameter Ram valid.
hwCbFPU 		EQU 		12						; FPU chip present.
hwCbMMU 		EQU 		11						; Some kind of MMU present (see MMUType for what kind).
hwCbADB 		EQU 		10						; Apple Desktop Bus present.
hwCmSCSI		EQU 		(1 << hwCbSCSI)
hwCmClock		EQU 		(1 << hwCbClock)
hwCmExPRAM		EQU 		(1 << hwCbExPRAM)
hwCmFPU 		EQU 		(1 << hwCbFPU)
hwCmMMU 		EQU 		(1 << hwCbMMU)
hwCmADB 		EQU 		(1 << hwCbADB)
fpuIn			EQU 		12						; bit 12 - FPU chip installed

				IF			onMac THEN
hwCfgBits		EQU 		hwCmSCSI++hwCmClock
				ELSEIF		onMacPP THEN
hwCfgBits		EQU 		hwCmSCSI++hwCmClock++hwCmADB
				ELSEIF		onNuMac THEN
hwCfgBits		EQU 		hwCmSCSI++hwCmClock++hwCmFPU++hwCmMMU++hwCmADB
				ELSE
				AERROR		'WARNING: Unknown machine type (hwCfgBits).'
				ENDIF


; Screen, Sound, ROM, RAM Constants
				IF			onMac|onMacPP THEN
dVertRRate		EQU 		60
				ENDIF



				ENDIF
