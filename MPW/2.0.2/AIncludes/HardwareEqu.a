; File: HardwareEqu.a
;
; Copyright Apple Computer, Inc. 1984-1987
; All Rights Reserved


;--------------------------------------------------------------------
;
; The following information was formerly in "private" files that were
; not released to the general developer community.
;
; The information in this file is not needed for normal application
; development. These equates and macros were necessary for development
; of the Macintosh ToolBox and Operating System, and are likely to be
; dependent on their current implementation. Use of any information
; in this file is likely to cause your software to fail on future
; versions of Macintosh system software or hardware.
;
; Apple Developer Support will not support any use of the following
; information.
;
; In order to prevent any "accidental" use of this information, it has
; been disabled using the conditional-assembly variable, HWNonPortable,
; defined below. If you change this to a non-zero value, you're on your
; own. Since this gives hardware specific equates, we must also define
; which type of Mac we are assembling for. Define the following variable:
;
;		onMac	if for 128K, 512K, 512Ke, or Mac+
;		onMacPP	if for Freeport
;		onNuMac	if for Paris
;
;
; Hardware Equates -- This file defines the low-level equates for the
;	Macintosh hardware interface.
;
;_______________________________________________________________________


; If HWNonPortable is defined to be non-zero, Then a machine type must be specified!

	IF (&TYPE('HWNonPortable') = 'UNDEFINED') THEN
HWNonPortable EQU 0
	ENDIF

	IF (&TYPE('onMac') = 'UNDEFINED') THEN	
onMac	EQU 1 
	ENDIF
	IF (&TYPE('onMacXL') = 'UNDEFINED') THEN
onMacXL	EQU 0 
	ENDIF
	IF (&TYPE('onMacPP') = 'UNDEFINED') THEN
onMacPP	EQU 0 
	ENDIF
	IF (&TYPE('onNuMac') = 'UNDEFINED') THEN
onNuMac	EQU 0 
	ENDIF
	IF (&TYPE('onOldNu') = 'UNDEFINED') THEN
onOldNu	EQU	0 
	ENDIF

	IF HWNonPortable THEN



ramChk			EQU		1024				; Amount of memory tested for stack.

; ((( -------------------- Macintosh --------------------
				IF	 onMac THEN
machine			EQU		0
rom85Bits		EQU		$7F					; New ROMs, No Power Off.
				ENDIF
; ))) -------------------- Macintosh --------------------


; ((( -------------------- NuMac --------------------
				IF	 onNuMac THEN
machine			EQU		1
rom85Bits		EQU		$3F					; New ROMs, Power Off ability.
				ENDIF
; ))) -------------------- NuMac --------------------


; ((( -------------------- Mac++ --------------------
				IF	 onMacPP THEN
machine			EQU		2
rom85Bits		EQU		$7F					; New ROMs, No Power Off.
				ENDIF
; ))) -------------------- Mac++ --------------------

DiagROM 		EQU 	$F80000 			; Alternate ROM - initial vector
DiagROM1		EQU 	$F80080 			; Alternate ROM - memory sizing vector
DiagROM2		EQU 	$F80088 			; Alternate ROM - init I/O vector
PhaseRead		EQU 	$F00000 			; Phase read address (StartMain)

				IF	 onMac|onMacPP THEN
hiIntMask		EQU 	$0300
loIntMask		EQU 	$0100
vIAIntMask		EQU 	$0100				; mask for VIA (and VBL) interrupts
sCCEnblMask 	EQU 	$F9FF				; mask to enable SCC interrupts 
				ENDIF

				IF	  onNuMac THEN
hiIntMask		EQU 	$0700				; mask for all interrupts
sCCIntMask		EQU 	$0400				; SCC interrupt vector
vIA2IntMask 	EQU 	$0200				; VIA2 interrupt vector
vIAIntMask		EQU 	$0100				; VIA interrupt vector
loIntMask		EQU 	$0100
sCCEnblMask 	EQU 	$FBFF				; mask to enable SCC interrupts
				ENDIF

				IF	  onMacXL THEN
hiIntMask		EQU 	$0600				; mask for all interrupts (except NMI)
loIntMask		EQU 	$0100
				ENDIF


ovlyRAM 		EQU  $600000 ; low RAM address when overlay is on
ovlyScreen		EQU  $67A700 ; top of screen with overlay

;________________________________;
;
; Screen, Sound, ROM, RAM addresses
;________________________________;

				IF	 onMac|onMacPP THEN
SoundLow		EQU 	 $3FFD00			; sound buffer start address
PWMBuffer		EQU 	 $3FFD01			; PWM bytes are low bytes
;ovlyRAM		.EQU	 $600000			; low RAM address when overlay is on
;ovlyScreen 	.EQU	 $7FA700			; top of screen with overlay
ROMStart		EQU 	 $400000			; starting address of ROM code
ScreenLow		EQU 	 $3FA700			; top of screen screen address
;SEOvlyRegs 	.EQU	 $7FFC80			; Sys Error Regs w. Overlay
SERegs			EQU 	 $3FFC80			; Sys Error Regs w/o Overlay

SEScrnNum		EQU 	 $3FD3DD			; Sys Error Number Screen address =$7CB5E+64*34 - 1
											; "vaguely centered" plus 34 scanlines -1 for extra digit
SEScrnInc		EQU 	 $3FD5DF			; address to diddle below death number
SEScrnIcon		EQU 	 $3FCB5E			; centered screen addr for Mac icons
SEScrnFace		EQU 	 $3FCCDF			; screen addr for face
SEScrnI2		EQU 	 $3FCF1F			; screen addr for boot icon overlay
				ENDIF			

				IF	 onNuMac THEN
ROMStart		EQU 	$40800000 			; starting address of final ROM code
ROM_hi			EQU 	$40 				; high byte of ROM address
MaxAdr			EQU 	$800000 			; max RAM search address (8 MB)
RamSiz			EQU 	$40 				; setting for VIA2 bits that control RAM size

SERegs			EQU 	$0C30				; offset to Sys Error Regs w/o Overlay
SEOvlyRegs		EQU 	SERegs				; no overlay space for NuMac

; offsets to various screen locations (tied to base address of screen)

SEScrnNum		EQU 	$57A7				; Sys Error Number Screen address = $46A8+(128*34) - 1
											; "vaguely centered" plus 34 scanlines -1 for extra digit
SEScrnInc		EQU 	$4AAA				; address to diddle below death number=$46A8+(128*8)+2
SEScrnIcon		EQU 	$46A8				; centered screen addr for NuMac icons
SEScrnFace		EQU 	$49A9				; screen addr for face = $46A8+(128*6)+1
SEScrnI2		EQU 	$4E29				; screen addr for boot icon overlay=$46A8+(128*15)+1
				ENDIF			

; New system error equates

SEVars			EQU 	SERegs				; start of system error data space (wrap city)
SEVSize 		EQU 	128 				; # of bytes in space

SED0			EQU 	SEVars				; loc of saved reg D0
SEA0			EQU 	SED0+32 			; loc of saved reg A0
SEA7			EQU 	SEA0+28 			; loc of saved reg A7
SEPC			EQU 	SEA7+4				; loc of saved PC
SESR			EQU 	SEPC+4				; loc of saved SR
SEAccess		EQU 	SESR+2				; PC address during bus/address error
SECmdSize		EQU 	SEAccess+4			; # of bytes of parameters passed in _debugger call
SE000BE 		EQU 	SECmdSize+2 		; 8 bytes of bus error info for 68000
SELastVar		EQU 	SE000BE+8			; last var in System Error data space

; Rom-based debugger nub equates

RDport			EQU 	SELastVar		; Number of port currently in use (0 => no link, 1 => A, 2 => B)
RDcode			EQU 	RDport+2		; Ptr to code download buffer.
RDAtrap 		EQU 	RDcode+4		; Saved Rom Atrap handler
RDlowTrap		EQU 	RDAtrap+4		; low value for trap handling
RDhiTrap		EQU 	RDlowTrap+2 	; high value for trap handling
RDresult		EQU 	RDhiTrap+2		; result of executing down-loaded code, etc. (16 bytes)
RDend			EQU 	RDresult+16 	; end of vars

; MicroBug Equates
; NOTE: Keep MBdotAddr immediately before MBlocAddr

MBbufSize		EQU 	34

MBbuffer		EQU 	SELastVar			; buffer for input
MBSign			EQU 	MBbuffer+MBbufSize	; ST => negative sign during conversion
MBdotAddr		EQU 	MBSign+2			; saved address
MBlocAddr		EQU 	MBdotAddr+4 		; saved location

				IF	 onMac|onMacPP THEN
dSrectTL		EQU 	$00400020			; top left = 64,32
dSrectBR		EQU 	$00BE01E0			; bottom right = 190,480
				ENDIF


				IF	 onNuMac THEN
dSrectTL		EQU 	$0078003C			; top left = 120,60
dSrectBR		EQU 	$01180244			; bottom right = 280,580
ctrDiff 		EQU 	$00450040			; coord diff from Mac screen center
dSRectHei		EQU		(DSrectBR**$FFFF0000)-(DSrectTL**$FFFF0000)>>16
dSRectLen		EQU		(DSrectBR**$FFFF)-(DSrectTL**$FFFF)
				ENDIF

; Screen, Sound, ROM, RAM  Constants

PWM2MemTop		EQU 	$2FF		; PWMBuffer to MemTop
Snd2MemTop		EQU 	$300		; SoundLow to Memtop
sndBufWLen		EQU 	$0172		; sound/disk buffer word length

				IF		onMac THEN
romWSize		EQU 	$10000					; 64K words in present ROM
romBSize		EQU 	$20000					; 128K bytes in present ROM
				ELSEIF	onNuMac|onMacPP THEN
romWSize		EQU 	$20000					; 128K words in present ROM
romBSize		EQU 	$40000					; 256K bytes in present ROM
				ENDIF

				IF	 onMac|onMacPP THEN
Scrn2MemTop 	EQU 	$5900		; ScreenBase to Memtop
scrnRowB		EQU 	64			; bytes per scan line
maxX			EQU 	512			; number of pixels horizontally
maxY			EQU 	342			; number of pixels vertically
screenWidth 	EQU 	maxX		; screen width
screenHeight	EQU 	maxY		; screen height
scrnBytes		EQU 	21888		; scrnRowB*maxY
BufWorldSize	EQU		Scrn2MemTop	; total size of the BufPtr world
				ELSEIF	onNuMac	THEN
BufWorldSize	EQU		Snd2MemTop	; total size of the BufPtr world
				ENDIF

; @@@ The following two should really be defined only for Mac and MacPP,
; @@@ but this info is not in the Video ROMs yet...
scrnHorRes		EQU		72			; number of dots per inch horizontally
scrnVertRes		EQU		72			; number of dots per inch vertically


;________________________________;
;
; VIA (6522) interface chip
;________________________________;


				IF	 onMac|onMacPP THEN
VBase			EQU 	 $EFE1FE	; base address
AVBufB			EQU 	 $EFE1FE	; buffer B
AVBufA			EQU 	 $EFFFFE	; buffer A
AVBufM			EQU 	 $EFE1FE	; buffer with mouse button bit
AVIFR			EQU 	 $EFFBFE	; interrupt flag register
AVIER			EQU 	 $EFFDFE	; interrupt enable register
				ENDIF

				IF	 onNuMac THEN
VBase			EQU 	 $50F00000	; base address
AVBufB			EQU 	 VBase		; buffer B
AVBufA			EQU 	 $50F01E00	; buffer A
AVBufM			EQU 	 VBase		; buffer with mouse button bit
AVIFR			EQU 	 $50F01A00	; interrupt flag register
AVIER			EQU 	 $50F01C00	; interrupt enable register

VBase2			EQU 	 $50F02000	; base for 2nd VIA
				ENDIF

; VIA Offsets

vBufB			EQU 	 0			; BUFFER B
vBufAH			EQU 	 $200		; buffer a (with handshake) [ Dont use! ]
vDIRB			EQU 	 $400		; DIRECTION B
vDIRA			EQU 	 $600		; DIRECTION A
vT1C			EQU 	 $800		; TIMER 1 COUNTER (L.O.)
vT1CH			EQU 	 $A00		; timer 1 counter (high order)
vT1L			EQU 	 $C00		; TIMER 1 LATCH (L.O.)
vT1LH			EQU 	 $E00		; timer 1 latch (high order)
vT2C			EQU 	 $1000		; TIMER 2 LATCH (L.O.)
vT2CH			EQU 	 $1200		; timer 2 counter (high order)
vSR 			EQU 	 $1400		; SHIFT REGISTER
vACR			EQU 	 $1600		; AUX. CONTROL REG.
vPCR			EQU 	 $1800		; PERIPH. CONTROL REG.
vIFR			EQU 	 $1A00		; INT. FLAG REG.
vIER			EQU 	 $1C00		; INT. ENABLE REG.
vBufA			EQU 	 $1E00		; BUFFER A

vBufD			EQU 	 $1E00		; disk head select buffer

				IF	 onMac THEN
; Buffer A:

vAOut			EQU 	 $7F		; VBufA output bits
vAInit			EQU 	 $69		; VBufA initial values (low volume)
vSound			EQU 	 $7 		; sound volume bits
vSndPg2 		EQU 	 3			; select sound page 2 if 0
vOverlay		EQU 	 4			; overlay bit (overlay when 1)
vHeadSel		EQU 	 5
vPage2			EQU 	 6			; select video page 2 if 0
vSCCWrReq		EQU 	 7			; SCC write/request line
				ENDIF

				IF	 onMacPP THEN
; Buffer A:

vAOut			EQU 	 $7F		; VBufA output bits
vAInit			EQU 	 $69		; VBufA initial values (low volume)
vSound			EQU 	 $7 		; sound volume bits
vSndPg2 		EQU 	 3			; select sound page 2 if 0
vDriveSel		EQU 	 4			; int drive select (lower drive when 1)
vHeadSel		EQU 	 5
vPage2			EQU 	 6			; select video page 2 if 0
vSCCWrReq		EQU 	 7			; SCC write/request line
				ENDIF

				IF	 onMac THEN

; Buffer B:

vBOut			EQU 	 $87		; VBufB output bits
vBInit			EQU 	 $87		; VBufB initial values
rtcData 		EQU 	 0
rtcClk			EQU 	 1
rtcEnb			EQU 	 2			; enabled when 0
vSW 			EQU 	 3			; mouse switch (0 when down)
vX2 			EQU 	 4			; mouse X level
vY2 			EQU 	 5			; mouse Y level
vH4 			EQU 	 6			; horizontal sync
vSndEnb 		EQU 	 7			; /sound enable (reset when 1)
				ENDIF

				IF	 onMacPP THEN
; Buffer B:

vBOut			EQU 	$C7			; VBufB output bits
vBInit			EQU 	$C7			; VBufB initial values
rtcData			EQU		0
rtcClk			EQU		1
rtcEnb			EQU		2			; enabled when 0
vFDBInt			EQU		3			; Front Desk bus interrupt
vFDesk1			EQU		4			; bit for front desk bus
vFDesk2			EQU		5			; and another
vH4				EQU		6			; SCSI IRQ mask	(was horiz. sync)
vSndEnb			EQU		7			; /sound enable (reset when 1)
				ENDIF

				IF	 onNuMac THEN
				IF	 onOldNu THEN
; VIA1 Buffer A:

vAOut			EQU 	 $3F		; VBufA output bits
vAInit			EQU 	 $01		; VBufA initial values (low volume)
vSound			EQU 	 $F 		; sound volume bits (0..3)
vOverlay		EQU 	 4			; overlay bit (overlay when 1)
vHeadSel		EQU 	 5			; head select line for Sony
vSCCWrReq		EQU 	 7			; SCC write/request line

; VIA1 Buffer B:

vBOut			EQU		$84			; VBufB output bits
vBInit			EQU		$0C			; VBufB initial values
vSync			EQU		0			; Synchronous modem
vFC3			EQU		1			; PMMU FC3 indicator
vRTCEnb 		EQU		2			; clock enable (0 for enable)
vSW 			EQU		3			; mouse switch (0 when down)
vTM1A			EQU		4			; bit for NUBus
vTM0A			EQU		5			; and another
vSndInt			EQU		6			; Sound chip interrupt
vSndRes 		EQU		7			; Sound Reset (reset when 1)

; VIA1 IFR bits:

ifCA2			EQU 	0			; CA2, ONESEC interrupt
ifCA1			EQU 	1			; CA1, VBL signal
ifSR			EQU 	2			; SR done, Serial i/o to Servo
ifCB2			EQU 	3			; CB2, Clock data
ifCB1			EQU 	4			; CB1, for clock pulse
ifT2			EQU 	5			; T2, INDEX pulse counter (VBL ctr)
ifT1			EQU 	6			; T1, (unused as interrupt)
ifIRQ			EQU 	7			; any interrupt

; VIA2 Buffer A:

v2AOut			EQU 	 $C0		; V2BufA output bits
v2AInit 		EQU 	 $00		; V2BufA initial values
v2RAMS			EQU 	 $C 		; RAM size bits (6,7)
v2IRQ1			EQU 	 0			; slot 1 interrupt
v2IRQ2			EQU 	 1			; slot 2 interrupt
v2IRQ3			EQU 	 2			; slot 3 interrupt
v2IRQ4			EQU 	 3			; slot 4 interrupt
v2IRQ5			EQU 	 4			; slot 5 interrupt
v2IRQ6			EQU 	 5			; slot 6 interrupt
v2RAM0			EQU 	 6			; RAM size bit 0
v2RAM1			EQU 	 7			; RAM size bit 1

; VIA2 Buffer B:

v2BOut			EQU 	 $80		; V2BufB output bits						
v2BInit 		EQU 	 $05		; V2BufB initial values
v2CDis			EQU 	 0			; cache disable (when 0)
v2BusLk 		EQU 	 1			; Bus lockout
v2PowerOff		EQU 	 2			; soft power off signal (when 0)
v2FDBInt		EQU 	 3			; Front Desk bus interrupt
v2FDesk1		EQU 	 4			; bit for front desk bus
v2FDesk2		EQU 	 5			; and another
v2SCSIRQ		EQU 	 6			; SCSI interrupt request
v2VBL			EQU 	 7			; pseudo VBL signal

				ELSE
				
; VIA1 Buffer A:

vAOut			EQU 	 $3F		; VBufA output bits
vAInit			EQU 	 $01		; VBufA initial values (low volume)
vSound			EQU 	 $7 		; sound volume bits (1..3)
vSync			EQU		 3			; Synchronous modem
vOverlay		EQU 	 4			; overlay bit (overlay when 1)
vHeadSel		EQU 	 5			; head select line for Sony
vRev8Bd			EQU		 6			; =0 for rev 8 board
vSCCWrReq		EQU 	 7			; SCC write/request line

; VIA1 Buffer B:

vBOut			EQU		$87			; VBufB output bits
vBInit			EQU		$07			; VBufB initial values
vrtcData 		EQU 	0			; real time clock data
vrtcClk			EQU 	1			; real time clock clock pulses
vRTCEnb 		EQU		2			; clock enable (0 for enable)
vFDBInt			EQU 	3			; Front Desk bus interrupt
vFDesk1			EQU 	4			; bit for front desk bus
vFDesk2			EQU 	5			; and another

; VIA1 IFR bits:

ifCA2			EQU 	0			; CA2, ONESEC interrupt
ifCA1			EQU 	1			; CA1, VBL signal
ifSR			EQU 	2			; SR done, Serial i/o to Servo
ifCB2			EQU 	3			; CB2, Clock data
ifCB1			EQU 	4			; CB1, for clock pulse
ifT2			EQU 	5			; T2, INDEX pulse counter (VBL ctr)
ifT1			EQU 	6			; T1, (unused as interrupt)
ifIRQ			EQU 	7			; any interrupt

; VIA2 Buffer A:

v2AOut			EQU 	 $C0		; V2BufA output bits
v2AInit 		EQU 	 $00		; V2BufA initial values
v2RAMS			EQU 	 $C 		; RAM size bits (6,7)
v2IRQ1			EQU 	 0			; slot 1 interrupt
v2IRQ2			EQU 	 1			; slot 2 interrupt
v2IRQ3			EQU 	 2			; slot 3 interrupt
v2IRQ4			EQU 	 3			; slot 4 interrupt
v2IRQ5			EQU 	 4			; slot 5 interrupt
v2IRQ6			EQU 	 5			; slot 6 interrupt
v2RAM0			EQU 	 6			; RAM size bit 0
v2RAM1			EQU 	 7			; RAM size bit 1

; VIA2 Buffer B:

v2BOut			EQU 	 $80		; V2BufB output bits						
v2BInit 		EQU 	 $05		; V2BufB initial values
v2CDis			EQU 	 0			; cache disable (when 0)
v2BusLk 		EQU 	 1			; Bus lockout
v2PowerOff		EQU 	 2			; soft power off signal (when 0)
vFC3			EQU		 3			; PMMU FC3 indicator
v2TM1A			EQU		 4			; bit for NUBus
v2TM0A			EQU		 5			; and another
v2SCSIRQ		EQU 	 6			; SCSI interrupt request
v2VBL			EQU 	 7			; pseudo VBL signal
				ENDIF				; {onOldNu}
				ENDIF				; {onNuMac}

; timing constants

				IF	 onMac|onMacPP THEN
ticksPr100		EQU 	78			; timer 1 setting for 100 usec intervals
oneSecConst 	EQU 	2			; gets converted to $20000 for onesec constant
flashDly		EQU 	4			; icon flash delay count
				ENDIF

				IF	 onNuMac THEN
ticksPr100		EQU 	78			; timer 1 setting for 100 usec intervals
oneSecConst 	EQU 	8			; gets converted to $80000 for onesec constant
flashDly		EQU 	8			; icon flash delay count						
				ENDIF


;________________________________;
;
; SCC Serial Chip Addresses
;________________________________;

				IF	 onMac|onMacPP THEN
SCCRBase		EQU 	 $9FFFF8	; SCC base read address
SCCWBase		EQU 	 $BFFFF9	; SCC base write address
				ENDIF

				IF	 onNuMac THEN
SCCRBase		EQU 	 $50F04000	; SCC base read address
SCCWBase		EQU 	 $50F04000	; SCC base write address
				ENDIF

; SCC Offsets

aData			EQU 	 6			; offset for A channel data
aCtl			EQU 	 2			; offset for A channel control
bData			EQU 	 4			; offset for B channel data
bCtl			EQU 	 0			; offset for B channel control

sccData 		EQU 	 4			; general offset for data from control

				IF	 onMac|onMacPP THEN
sccWrite		EQU 	 $200001	; general offset for write from read
				ENDIF

				IF	 onNuMac THEN
sccWrite		EQU 	 $0 		; general offset for write from read
				ENDIF

rxBF			EQU 	 0			; SCC receive buffer full
txBE			EQU 	 2			; SCC transmit buffer empty

; SCC clock rates

macClock		EQU 	36707		; in Hz * 100
midMacClock 	EQU     39168
nuMacClock		EQU 	36864
lisaAClock		EQU 	40000		; port A clock
lisaBCLock		EQU 	36864		; port B clock

; SCC baud rate constants

macConst		EQU 	114709		; in Hz/32
midMacConst 	EQU     122400
nuMacConst		EQU 	115200
lisaAConst		EQU 	125000
lisaBConst		EQU 	115200

;________________________________;
;
; IWM Chip Addresses
;________________________________;


				IF	 onMac|onMacPP THEN
DBase			EQU 	 $DFE1FF	; disk address base
DPh0L			EQU 	 $DFE1FF	; phase 0 low
DPh0H			EQU 	 $DFE3FF	; phase 0 high
DMtrOff 		EQU 	 $DFF1FF	; IWM Motor off
DMtrOn			EQU 	 $DFF3FF	; IWM Motor on
DiskQ6L 		EQU 	 $DFF9FF	; shift register
DiskQ6H 		EQU 	 $DFFBFF
DiskQ7L 		EQU 	 $DFFDFF
DiskQ7H 		EQU 	 $DFFFFF
				ENDIF

				IF	 onNuMac THEN
oldIWMBase		EQU 	 $50F1C000	; old disk address base
newIWMBase		EQU 	 $50F16000	; new disk address base

;DBase			EQU 	 $50F1C000	; old disk address base
;DPh0L			EQU 	 $50F1C000	; phase 0 low
;DPh0H			EQU 	 $50F1C200	; phase 0 high
;DMtrOff 		EQU 	 $50F1D000	; IWM Motor off
;DMtrOn			EQU 	 $50F1D200	; IWM Motor on
;DiskQ6L 		EQU 	 $50F1D800	; shift register
;DiskQ6H 		EQU 	 $50F1DA00
;DiskQ7L 		EQU 	 $50F1DC00
;DiskQ7H 		EQU 	 $50F1DE00
				ENDIF

; IWM Offsets

ph0L			EQU 	 0			; disk address offsets from base
ph0H			EQU 	 $200
ph1L			EQU 	 $400
ph1H			EQU 	 $600
ph2L			EQU 	 $800
ph2H			EQU 	 $A00
ph3L			EQU 	 $C00
ph3H			EQU 	 $E00
mtrOff			EQU 	 $1000
mtrOn			EQU 	 $1200
intDrive		EQU 	 $1400		; enable internal drive address
extDrive		EQU 	 $1600		; enable external drive address
q6L 			EQU 	 $1800
q6H 			EQU 	 $1A00
q7L 			EQU 	 $1C00
q7H 			EQU 	 $1E00


;  Interrupt Auto-vector and Exception Definitions

Line1010		EQU  $28	 ; 1010 emulator trap (system routines)
Line1111		EQU  $2C	 ; 1111 emulator trap (reserved)
AutoInt1		EQU  $64	 ; level 1 auto-vector
AutoInt2		EQU  $68	 ; level 2 auto-vector
AutoInt3		EQU  $6C	 ; level 3 auto-vector
AutoInt4		EQU  $70	 ; level 4 auto-vector
AutoInt5		EQU  $74	 ; level 5 auto-vector
AutoInt6		EQU  $78	 ; level 6 auto-vector
AutoInt7		EQU  $7C	 ; level 7 auto-vector
FmtErrVect		EQU  $38	 ; format error vector for 68010/68020


			IF		onMac THEN			; SCSI addresses
;
;	base address for SCSI Port for MAC+
;
SCSIRd		EQU 		$580000 			; base address of SCSI interface - READ
SCSIWr		EQU 		$580001 			; base address of SCSI interface - WRITE

WrOffs		EQU			1					; write addresses are +1 to the read base
			ENDIF
			
			IF		onMacPP THEN			; SCSI addresses
;
;	base address for SCSI Port for MAC++
;
SCSIRd		EQU 		$5FF000 			; base address of SCSI interface - READ
SCSIWr		EQU 		$5FF001 			; base address of SCSI interface - WRITE
MacSCSIBase	EQU 		$5FF000 			; base address of SCSI READ interface
MacSCSIDMA	EQU 		$5FF200 			; base address of SCSI DMA
MacSCSIHsk	EQU 		$5FF200 			; base address of SCSI handshake

WrOffs		EQU			1					; write addresses are +1 to the read base
			ENDIF
			
			IF	 onNuMac THEN
;	base address for SCSI Port for 020Mac

;SCSIRd		EQU 		$50F10000			; base address of SCSI interface - READ
;SCSIWr		EQU 		$50F10000			; base address of SCSI interface - WRITE
;SCSIHndShk	EQU 		$50F08000			; SCSI pseudo-DMA handshaking READ/WRITE

WrOffs		EQU			0					; write addresses are same as read base

OldSCSIBase	EQU			$50F10000			; base address of SCSI interface
OldSCSIDMA	EQU			$50F14000			; base address of SCSI DMA
OldSCSIHsk	EQU			$50F08000			; base address of SCSI handshake

NewSCSIBase	EQU			$50F10000			; rev8 base address of SCSI interface
NewSCSIDMA	EQU			$50F12000			; rev8 base address of SCSI DMA (corrected)
NewSCSIHsk	EQU			$50F06000			; rev8 base address of SCSI handshake

SCSIVct 	EQU 		AutoInt3			; SCSI int at level 3
			ENDIF

;
;	5380 Register Defs - Offsets
;
			IF		onMac|onMacPP THEN		; address offsets (handshaking on MacPP)
dACKRd		EQU 		$200				; offset of psuedo-DMA - READ
dACKWr		EQU 		$200				; offset of psuedo-DMA - WRITE
			ENDIF


			;	Removed DACKRd and DACKWr offsets for NuMac <C406/12Nov86>


sCDR	   EQU 		   $00 					; Current SCSI Read Data
sODR	   EQU 		   $00 					; Output data register

sICR	   EQU 		   $10 					; Initiator Command Register - READ/WRITE
iRST	   EQU 		   $80 				   	; *RST asserted
iAIP	   EQU		   $40				   	; arbitration in progress (read)
bAIP	   EQU		   6				   	;   bit test for arbitration in progress
aTMD	   EQU		   $40				  	; assert Test Mode (write)
iLA 	   EQU		   $20				  	; Lost arbitration (read)
bLA 	   EQU		   5				   	;   bit test for Lost Arbitration
aDIFF	   EQU		   $20				   	; assert Differential enable (write)
iACK	   EQU		   $10				   	; *ACK is asserted
iBSY	   EQU		   $08				   	; *BSY is asserted
iSEL	   EQU		   $04				   	; *SEL is asserted
iATN	   EQU		   $02				   	; *ATN is asserted
iDB 	   EQU		   $01				   	; Data bus is asserted
	
sMR 	   EQU 		   $20 				   	; Mode Register - READ/WRITE
iBDMA	   EQU		   $80				   	; Block Mode DMA
iTGT	   EQU		   $40				   	; Target Mode
iPTY	   EQU		   $20				   	; Enable Parity Checking
iIPTY	   EQU		   $10				   	; Enable Parity interrupt
iIEOP	   EQU		   $08				   	; Enable EOP interrupt
iMBSY	   EQU		   $04				   	; Monitor BSY
iDMA	   EQU		   $02				   	; DMA Mode
iARB	   EQU		   $01				   	; Arbitration

sTCR	   EQU 		   $30 				   	; Target Command Register - READ/WRITE
iREQ	   EQU		   $08				   	; Assert *REQ
iMSG	   EQU		   $04				   	; Assert *MSG
iCD 	   EQU		   $02				   	; Assert C/*D
iIO 	   EQU		   $01				   	; Assert I/*O

sCSR	   EQU 		   $40 				   	; Current SCSI Bus Status (READ)
aRST	   EQU		   $80				   	; *RST
aBSY	   EQU		   $40				   	; *BSY
bBSY	   EQU		   6				   	;  bit test for *BSY
aREQ	   EQU		   $20				   	; *REQ
bREQ	   EQU		   5				   	;  bit test for *REQ
aMSG	   EQU		   $10				   	; *MSG
bMSG	   EQU		   4				   	;  bit test for *MSG
aCD 	   EQU		   $08				   	; C/*D
bCD 	   EQU		   3				   	;  bit test for C/*D
aIO 	   EQU		   $04				   	; I/*O
bIO 	   EQU		   2				   	;  bit test for I/*O
aSEL	   EQU		   $02				   	; *SEL
bSEL	   EQU		   1				   	;  bit test for *SEL
aDBP	   EQU		   $01				   	; *DBP

sSER	   EQU 		   $40 				   	; Select Enable Register (WRITE)

sBSR	   EQU		   $50 				   	; Bus & Status Register (READ)
iEDMA	   EQU		   $80				   	; End of DMA
bEDMA	   EQU		   7				   	; bit test for end of DMA
iDMAR	   EQU		   $40				   	; DMA Request
bDMAR	   EQU		   6				   	; bit test for DMA Req
iPERR	   EQU		   $20				   	; Parity Error
iIREQ	   EQU		   $10				   	; Interrupt Request
bIREQ	   EQU		   4				   	; bit test for interrupt
iPM 	   EQU		   $08				   	; Phase Match
bPM 	   EQU		   3				   	;  bit test for Phase Match
iBERR	   EQU		   $04				   	; Bus Error
ATN 	   EQU		   $02				   	; *ATN
ACK 	   EQU		   $01				   	; *ACK
bACK	   EQU		   0				   	; bit test for ACK

sDMAtx	   EQU 		   $50 					; DMA Transmit Start (WRITE)
sIDR	   EQU 		   $60 					; Data input register (READ)
sTDMArx    EQU 		   $60 					; Start Target DMA receive (WRITE)
sRESET	   EQU 		   $70 					; Reset Parity/Interrupt (READ)
sIDMArx    EQU 		   $70 					; Start Initiator DMA receive (WRITE)

			IF	 onMac|onMacPP THEN
onesec		EQU 	95528					; looptimes
halfsec 	EQU 	onesec/2
oneSecTicks EQU 	60						; ticks, of course
stlDelay	EQU 	$30 					; default bus settle delay
			ENDIF

			IF	 onNuMac THEN
onesec		EQU 	382112					; looptimes
halfsec 	EQU 	onesec/2
oneSecTicks EQU 	60						; ticks, of course
stlDelay	EQU 	$30 					; default bus settle delay

;  slot equates

Slot1Adr	EQU 	$F9900000				; slot 1 base address
Slot2Adr	EQU 	$FAA00000				; slot 2 base address
Slot3Adr	EQU 	$FBB00000				; slot 3 base address
Slot4Adr	EQU 	$FCC00000				; slot 4 base address
Slot5Adr	EQU 	$FDD00000				; slot 5 base address
Slot6Adr	EQU 	$FEE00000				; slot 6 base address

slotOfst	EQU 	$01100000				; address offset to next slot

slotSize	EQU 	24						; bytes for slot dispatch table
											;  (long word per slot)

; Configuration ROM offsets

CnfgROMOfst EQU 	$000FFE00				; offset to base addr of 128 byte config ROM
sResType	EQU 	$100					; resource type
sIDByte 	EQU 	$104					; ID byte
sROMFrmt	EQU 	$10C					; ROM format
sROMFlgs	EQU 	$110					; ROM flags
sBrdType	EQU 	$184					; Board type
sVidOfst	EQU 	$194					; offset to video params
sROMSize	EQU 	$1B4					; actual config ROM size

; Video parameter offsets

vWidth		EQU 	0						; pixel screen width
vHeigth 	EQU 	$8						; pixel screen heigth
vRowBytes	EQU 	$10 					; screen row bytes (visible)
vVBLRate	EQU 	$18 					; vertical blanking rate
vVidSize	EQU 	$1C 					; size of video mem in bytes

; Video card control register

sCtlRegOfst EQU 	$00080003				; offset to ctl reg on video card
iIRQ		EQU 	$08 					; Vsync interrupt
bIRQ		EQU 	3						; bit test for IRQ
iVPage		EQU 	$04 					; set video page
bVSync		EQU 	2						; bit test for VSync

			ENDIF

; equates for the expanded toolbox trap tables

			IF	onNuMac|onMacPP THEN
ToolTable	EQU 	$0E00					; start of toolbox trap table
			ELSE
ToolTable	EQU 	$0C00					; start of toolbox trap table
			ENDIF

			IF	onNuMac	THEN				; make a variable # of tb traps
numTbTrap   EQU		1024					; number of toolbox traps
numTrapMask EQU		$03FF					; mask for number of tb traps
			ELSE
numTbTrap   EQU		512						; number of toolbox traps
numTrapMask EQU		$01FF					; mask for number of tb traps
			ENDIF
numOsTrap   EQU		256						; number of os traps

; misc equates

			IF	 onMac THEN
ROMDoEject	EQU 	$40001E 				; jump to DoEject utility
HeapStart	EQU 	$1400					; Mac Plus starting point
defSysHeap	EQU		$B700					; Default size of the system heap
nDfltStackSize	EQU	$2000					; Default stack size
			ENDIF

			IF	 onMacPP THEN
ROMDoEject	EQU 	$40001E 				; jump to DoEject utility
HeapStart	EQU 	$1600					; Aladdin starting point
defSysHeap	EQU		$18000					; Default size of the system heap
nDfltStackSize	EQU	$2000					; Default stack size
			ENDIF

			IF	 onNuMac THEN
ROMDoEject	EQU 	$4080001E 				; jump to DoEject utility
HeapStart	EQU 	$1E00					; need extra lomem for color quickdraw
defSysHeap	EQU		$18000					; Default size of the system heap
nDfltStackSize	EQU	$6000					; Default stack size
			ENDIF


			IF	onNuMac	THEN
;SoundChip	EQU		$50F18000				; Base of the sound chip's address space
OldSndBase	EQU		$50F18000				; old sound chip's base address
NewSndBase	EQU		$50F14000				; rev8 sound chip's base address
			ENDIF


; Hardware Equates -- This file defines the low-level equates for the
;	Macintosh hardware interface.


;------------------------------
; Hardware configuration bits.
;------------------------------
;the following goes with HWCfgFlags	

hwCbSCSI	EQU		15					; SCSI port present
hwCbClock	EQU		14					; New clock chip present
hwCbExPRAM	EQU		13					; Extra Parameter Ram valid.
hwCbFPU		EQU		12					; FPU chip present.
hwCbMMU		EQU		11					; Some kind of MMU present (see MMUType for what kind).
hwCbADB		EQU		10					; Apple Desktop Bus present.

hwCmSCSI	EQU		(1 << hwCbSCSI)
hwCmClock	EQU		(1 << hwCbClock)
hwCmExPRAM	EQU		(1 << hwCbExPRAM)
hwCmFPU		EQU		(1 << hwCbFPU)
hwCmMMU		EQU		(1 << hwCbMMU)
hwCmADB		EQU		(1 << hwCbADB)

FPUIn		EQU		12					; bit 12 - FPU chip installed

			IF		onMac	THEN
hwCfgBits	EQU		hwCmSCSI++hwCmClock
			ELSEIF	onMacPP	THEN
hwCfgBits	EQU		hwCmSCSI++hwCmClock++hwCmADB
			ELSEIF	onNuMac	THEN
hwCfgBits	EQU		hwCmSCSI++hwCmClock++hwCmFPU++hwCmMMU++hwCmADB
			ELSE
			AERROR	'WARNING: Unknown machine type (hwCfgBits).'
			ENDIF


; Screen, Sound, ROM, RAM  Constants

			IF	 onMac|onMacPP THEN
dVertRRate	EQU	60
			ENDIF
			
			ENDIF	;end exclusion of private information
			
