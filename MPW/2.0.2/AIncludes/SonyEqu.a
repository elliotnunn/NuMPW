; File: SonyEqu.a
;
; Copyright Apple Computer, Inc. 1984-1987
; All Rights Reserved
;
;--------------------------------------------------------------------
;
; The following information was formerly in "private" files that were
; not released to the general developer community.
;
; The information in this file is not needed for normal application
; development. These equates and macros were necessary for development
; of the Macintosh ToolBox and Operating System, and are likely to be
; dependent on their current implementation. Use of any information
; in this file is likely to cause your software to fail on future
; versions of Macintosh system software or hardware.
;
; Apple Developer Support will not support any use of the following
; information.
;
; In order to prevent any "accidental" use of this information, it has
; been disabled using the conditional-assembly variable defined below.
; If you change this to a non-zero value, you're on your own.


	IF (&TYPE('SonyNonPortable') = 'UNDEFINED') THEN
SonyNonPortable EQU 0
	ENDIF

	IF SonyNonPortable THEN

; SonyVars Data Structure (offsets):
;	(1) Driver local vars.
;	(2) Drive-specific vars.
;	(3) More driver local vars.
;	(4) Direct-connect driver locals.
;
; Drive Constants:
;	(1) Floppy drive constants (tuneable).
;	(2) Floppy drive sense/control constants.
;	(3) Floppy drive formatting constants.
;	(4) Direct-connect drive constants.
;
; Driver Constants:
;	(1) Driver Control codes.
;
; Driver Vectors:
;	(1) Location of disk routine vectors.
;
;_______________________________________________________________________

;_______________________________________;
;						;
; SonyVars Data Structure (offsets):	;
;_______________________________________;

;_______________________________________;
;
; (1) Driver local vars.				; * = known to be used in a copy-
										;  protection scheme.
diskUnitPtr EQU    0					; pointer to device control entry
diskQVE 	EQU    diskUnitPtr+4		; disk VBL task control block
drive		EQU    diskQVE+14			; * 0001 = int drive, 0002 = ext drive
wait		EQU    drive+2				; extra wait time for speed changes

sideTrack	EQU    wait+2				; destination side/track
oneToOne	EQU    sideTrack+2			; open up rupts flg (no longer used)
active		EQU    oneToOne+1			; * non-zero when driver is active
timeOut 	EQU    active+1 			; * power time out

diskBuffer	EQU    timeOut+2			; pointer to track data buffer
firstSect	EQU    diskBuffer+4 		; low sector number needed on a track
sectMap 	EQU    firstSect+2			; bit map of sectors needed on a track
firstFSeq	EQU    sectMap+4			; first file seq # for current r/w request
fBlksDone	EQU    firstFSeq+2			; file blocks done previous to this track

readErrInit EQU    fBlksDone+2			; init value, read error countdown cntr
readErrCnt	EQU    readErrInit+1		; read error countdown cntr
recalInit	EQU    readErrCnt+1 		; init value, recal count
recalCnt	EQU    recalInit+1			; recal count
wrgSectInit EQU    recalCnt+1			; init value, wrong sector countdown cnt
wrgSectCnt	EQU    wrgSectInit+1		; wrong sector countdown cnt
badSpdInit	EQU    wrgSectCnt+1 		; init value, bad speed
badSpdCnt	EQU    badSpdInit+1 		; bad speed countdown value

command 	EQU    badSpdCnt+1			; I/O command

headSettle	EQU    command+2			; disk head settle time (@100usec)
spdChgTime	EQU    headSettle+2 	   ; motor speed change time (@100usec)
pwrOnTime	EQU    spdChgTime+2 	   ; * power-on wait time (@100usec)
pwrOffTime	EQU    pwrOnTime+2			; * power down time (@1/2sec)
seekTime	EQU    pwrOffTime+2 	   ; seek wait time (@100usec)
sectTime	EQU    seekTime+2			; * sector time (@100usec)
dskVBLTime	EQU    sectTime+2			; VBL task time (@16ms)
ejectTime	EQU    dskVBLTime+2 	   ; Eject time (@100usec)
ckDelta 	EQU    ejectTime+2			; delta time before speed recheck
ejectWait	EQU    ckDelta+4			; VBL times after eject to ignore DIP

; Format/Verify code reuses some of these fields as follows:

gapSync 	EQU    sectMap			; (2) start with 7 groups of intersector sync
twoSided	EQU    command			; (1) set non-zero for 2-sided format
sectSave	EQU    firstSect			; (2) SectMpSave must follow
sectMapSave EQU    sectMap			; (8) uses SectMap, FirstFSeq, FBlksDone
sectCnt 	EQU    firstSect			; (2) loop counter . . .

;_______________________________________;
;
; (2) Drive-specific vars.

drvLclLth	EQU    66
drive1		EQU    ejectWait+2			; * internal drive variables
drive2		EQU    drive1+drvLclLth    ; * external drive variables

track		EQU    0				; current track location (used for spd)
writeProt	EQU    2				; * bit7=1=write-protected
diskInPlace EQU    3				; * $FC-$FF= just ejected,
										;	0=no disk in place,1=DIP,2=clamped
installed	EQU    4				; * 0=don't know, 1=inst., $FF=not inst.
sides		EQU    5				; * bit7=0=1 sided
dqel		EQU    6				; drive queue element for this drive
driveQLink	EQU    6
driveQVers	EQU    10
driveSize	EQU    18				; drive block size (DCD only!)
twoSideFmt	EQU    18				; * non-zero if 2-sided format
newIntf 	EQU    19				; $FF if new interface, $00 for old 
driveErrs	EQU    20				; drive soft errs

driveS1 	EQU    20				; drive block size (high word)
driveType	EQU    22				; old OffSpeed (no longer supported)
driveManf	EQU    24
driveChar	EQU    26
driveMisc	EQU    27

spdAdjCnt	EQU    24				; speed adjust count this drive
trkSpeedTbl EQU    26				; 5-entry track speed table

tSTblCode	EQU    0				; first is speed code
tSTblDelta	EQU    2				; 2% speed code delta
tSTblTicks	EQU    4				; longword last time checked tick cnt
trkSTEnd	EQU    66				; end of drive vars

;_______________________________________;
;
; (3) More driver local vars.

wakeTimeCnt EQU    drive2+drvLclLth    ; WakeUp remainder count
saveRegs	EQU    wakeTimeCnt+2	   ; * wakeup routine saves D3-D7,A3-A6 here

tagBufPtr	EQU    saveRegs+36			; if non-zero, pointer to separate
										;  buffer for file tags . . .
tagBufOS	EQU    tagBufPtr+4			; temp offset into buffer
diskErrs	EQU    tagBufOS+2			; global soft errors
passThru	EQU    diskErrs+2			; 0 if pass thru on external port
sonyExtra	EQU    passThru+1			; extra byte
curSector	EQU    sonyExtra+1			; current sector being read/written 

tcRdEnable	EQU    curSector+2			; (byte) set non-zero to activate reads into cache
tcInstalled EQU    tcRdEnable+1 	   ; (byte) non-zero when caching is installed and on
tcDrive 	EQU    tcInstalled+1	   ; (word) drive number of cache blks (zero to inval)
tcSideTrack EQU    tcDrive+2			; (word) side/track of cache blocks 		
tcSectMap	EQU    tcSideTrack+2	   ; (long) bitmap of sectors currently cached	
tcBuffer	EQU    tcSectMap+4			; (long) pointer to track cache buffer (512+12)*12
tcNumCached EQU    tcBuffer+4			; (word) number read into cache 			
tcNumUsed	EQU    tcNumCached+2	   ; (word actual number used			

lastDrive	EQU    tcNumUsed+2			; (word) set at CkDrvNum to previous value of Drive
timeOutDrive EQU   lastDrive+4			; (word) set at PowerDown to value of Drive 
										; Above value should have been +2 since lastDrive is a word.
timeQEl 	EQU    timeOutDrive+2	   ; a time queue element
nextGZProc	EQU    timeQEl+$C		   ; (long) saved old GZ proc		
										; Above had been +tmQSize, but that changed from $C to $E.
sonyVarEnd	EQU    nextGZProc+4 	   ; end of sony vars excluding DCD 

			IF	 onMac=1 THEN				;					
;_______________________________________;
;
; (4) Direct-connect driver locals.

TagSize 	EQU    20				; 20 bytes tags/block

dcdLclLth	EQU    28				; (use fields through DriveMisc)
drive3		EQU    sonyVarEnd			; first DCD 			
drive4		EQU    drive3+dcdLclLth    ; second DCD
drive5		EQU    drive4+dcdLclLth    ; third DCD
drive6		EQU    drive5+dcdLclLth    ; fourth DCD

stsRtnAddr	EQU    drive6+dcdLclLth    ; DCD status call return address

dcdCmd		EQU    stsRtnAddr+4 	   ; command byte to DCD
response	EQU    dcdCmd			; response byte (command+$80)
seqNum		EQU    response+1			; mb sequence number (sys commands only)
status		EQU    seqNum+1 			; returned status bytes
startBlock	EQU    status				; starting block # (in commands)
driveOut	EQU    startBlock+3 		; we send drive number in this field
driveIn 	EQU    status+2 			; low 6 bits
tagBytes	EQU    status+4 			; tag bytes get stuffed here temporarily
devType		EQU    tagBytes 			; first 20 bytes of status are written
devManufctr EQU    devType+2			;  in the 20-byte tag buffer
devChar 	EQU    devManufctr+2
devBlks 	EQU    devChar				; low 3 bytes of this longword
devSpares	EQU    devChar+4
devBadBlks	EQU    devSpares+2
devMisc 	EQU    devBadBlks+2 		; 8 bytes misc
bufSize 	EQU    tagBytes+tagSize 	; number of bytes/block
lastStatus	EQU    bufSize+4			; last status returned
lastResult	EQU    lastStatus+4 		; error type
dcdFlags	EQU    lastResult+1 		; flag of whether we've done a reset
chkTime 	EQU    dcdFlags+1			; 100usec check ready count
maxTime 	EQU    chkTime+2			; maximum number of checks
stsBuffer	EQU    maxTime+2			; 512 bytes of status
devReserve	EQU    stsBuffer
devIcon 	EQU    devReserve+44
devFiller	EQU    devIcon+256			; 32 bytes for optional name

diskVarLth	EQU    devFiller+32

stsBufSize	EQU    diskVarLth-stsBuffer

			ELSE				;					
diskVarLth	EQU    sonyVarEnd			;					
			ENDIF				;					

; device characteristics byte:

devChEject	EQU    4				; ejectable if 1
devChWP 	EQU    3				; write protected if 1
devChIcon	EQU    2				; icon available if 1


;_______________________________________;
;						;
; Drive Constants:				;
;_______________________________________;


dqSides 	EQU    -1				; Bit 7 of this byte: 0=single-sided Sony, 1=double sided
dqInstall	EQU    -2				; 0=unknown, 1=installed, FF=no disk
dqDIP		EQU    -3				; $FC-$FF = disk just ejected,
										;		0 = no disk in place
										;		1 = disk in place
										;		2 = disk has been read
										;	   >8 = non-ejectable disk
dqWrPrt 	EQU    -4				; Bit 7 of this byte: 1=disk is write protected.

;_______________________________________;
;
; (1) Floppy drive constants (tuneable).

kSeekTime	EQU    120				; 12 ms trk-to-trk
kHdSetTime	EQU    300				; 30 ms head settle time
kEjectTime	EQU    7500 		; .75 seconds eject time
kEjectWait	EQU    -4				; - number of VBL calls after eject before dip check
kSectTime	EQU    100				; minimum sector time in 100 us increments (10 ms)
kPowerOn	EQU    4000 		; read/write powerup time in 100 us increments
kRWPOff 	EQU    5				; read/write power off time (in 1/2 seconds)
kDskVBLTime EQU    30				; happens every 1/2 second
kSpdChgTime EQU    1500 		; speed change wait time = 150ms
kCkDelta	EQU    14400			; speed check delta time (in 1/60 sec) (4 min)

;_______________________________________;
;
; (2) Floppy drive sense/control constants.
;	 (ca1-ca0-sel-ca2).

dirLAdr 	EQU    0				; dirtn low
dirHAdr 	EQU    1
rdDtaAdr	EQU    1				; side 0 read data
rdDta1Adr	EQU    3				; side 1 read data
stepLAdr	EQU    4				; step low and step sense address
stepHAdr	EQU    5
mtrOnAdr	EQU    8
mtrOffAdr	EQU    9
ejectLAdr	EQU    12
ejectHAdr	EQU    13

dipAdr		EQU    2				; disk in place sense address
wrProtAdr	EQU    6				; write protect sense address
sidesAdr	EQU    9				; sense for number of sides
tk0Adr		EQU    10				; track 0 sense address
readyAdr	EQU    11				; /Ready sense address
drvExstAdr	EQU    13				; sense=0 when a drive is connected
tachAdr 	EQU    14				; tach feedback sense address
newIntfAdr	EQU    15				; implements ready handshake if 1	

;_______________________________________;
;
; (3) Floppy drive formatting constants.

fmtByte 	EQU    $02				; 2-1 interleave, single-sided
fmt2Byte	EQU    $22				; 2-1 interleave, double-sided

mustFindCt	EQU    1500
minSync 	EQU    4				; min number of inter-sector sync groups

			IF	 onMac=1 THEN				;				
;_______________________________________;
;
; (4) Direct-connect drive constants.

;This variable has been renamed SONYRetry and placed in Privates
;RetryCount  EQU	5				; Number of HardReset/retries allowed

blkSize 	EQU    512				; 512 bytes data/block
syncByte	EQU    $AA				; Sync byte for start of transmission

noError 	EQU    0				; resultTypes
nonZerStat	EQU    1
comErr		EQU    2

; New HD20 error codes

wrtHsLw 		EQU   $10			; HSHK low before starting
wrtHSLwTO		EQU   $11			; Time out waiting for HSHK to go low
wrtHSHighTO 	EQU   $13			; Time out waiting for HSHK to go high
rdHsHi			EQU   $20			; HSHK high before starting
rdSyncTO		EQU   $21			; Time out waiting for sync ($AA) bye
rdGroupTO		EQU   $22			; Time out waiting for group
rdHoffSyncTO	EQU   $24			; Time out waiting for sync after holdoff
rdHsHiTO		EQU   $25			; Time out waiting for HSHK high
rdChksumErr 	EQU   $26			; Checksum error on response packet
invalidResp 	EQU   $30			; First byte in response packet was wrong
sqncNumErr		EQU   $31			; Sequence number in response packet was wrong
dNumberErr		EQU   $32			; Drive number in response packet was wrong
noResp			EQU   $40			; No response packet ever received

; LastStatus

opFailed	EQU    24				; bit to test for operation failed
bChksum 	EQU    30				; bit number for checksum error

; DCDFlags

resetonce	EQU    0
retryonce	EQU    1

maxTries	EQU    4				; max # times to try command
tSeekChk	EQU    10				; check during a seek every 1 ms
tSeekMax	EQU    10000			; max time for seek = 10 secs
tStsChk 	EQU    10				; check during a status every 1 ms
tStsMax 	EQU    10000			; max time for status = 10 secs
tQuickTime	EQU    100
tNextChk	EQU    7				; check for next block after 700 µsec
tNextMax	EQU    10000			; max time for next block = 7 secs
tFVChk		EQU    100				; check during fmt/vfy every 10 ms
tFVMax		EQU    18000			; max time for fmt/vfy = 3 minutes
tRstAssert	EQU    1000 		; assert reset for 100 msec
tRstSettle	EQU    20000			; 2 sec wait for busy to settle
tRstChk 	EQU    100				; check during reset every 10 ms
tRstMax 	EQU    1600 		; max time for reset = 16 seconds

; DCD sense/cntl addr (ca1-ca0-sel-ca2)

dcdExist	EQU    5				; /Exist (/Sides=/DrvIn=1 also)
dcdReset	EQU    1				; for 1ms resets DCD controller
			ENDIF				;				

;_______________________________________;
;						;
; Driver Constants: 			;
;_______________________________________;

;_______________________________________;
;
; (1) Driver Control codes.

verifyCC	EQU    5				; 'verify' control code
formatCC	EQU    6				; 'format' control code
tagBufCC	EQU    8				; 'set tag buffer' control code
TCacheCC	EQU    9				; 'track cache' control 			
iconIDCC	EQU    20				; 'get icon id' control code
iconCC		EQU    21				; 'get icon' control code

;_______________________________________;
;						;
; Driver Vectors:				;
;_______________________________________;

;_______________________________________;
;
; (1) Location of disk routine vectors.

jFigTrkSpd	EQU    diskVars
jDiskPrime	EQU    jFigTrkSpd+4
jRdAddr 	EQU    jDiskPrime+4
jRdData 	EQU    jRdAddr+4

jWrData 	EQU    jRdData+4
jSeek		EQU    jWrData+4
jSetUpPoll	EQU    jSeek+4
jRecal		EQU    jSetUpPoll+4

jControl	EQU    jRecal+4
jWakeUp 	EQU    jControl+4
jReSeek 	EQU    jWakeUp+4
jMakeSpdTbl EQU    jReSeek+4

jAdrDisk	EQU    jMakeSpdTbl+4
jSetSpeed	EQU    jAdrDisk+4
niblTbl 	EQU    jSetSpeed+4

jDiskSel	EQU    $B40 		; (long) vector to .Sony DiskSelect routine 
jSendCmd	EQU    $B44 		; (long) vector to .Sony DCD SendCmd routine
jDCDReset	EQU    $B48 		; (long) vector to .Sony DCD DCDReset routine

;************** NEW SONY DRIVER EQUATES *************/

; Sony Driver Equates 


jDoEject		EQU    4*($F7)+$0400  ; Sony Driver jump vectors


	ENDIF	;end exclusion of private information
	
