* File Sample.a
* Copyright Apple Computer, Inc. 1985-1987
* All rights reserved.

* Sample -- A small sample application written in MPW Assembler.  It displays
* single, fixed-size window in which the user can enter and edit text.

* This is a translation of the Pascal version of Sample shown in the Inside
* Macintosh documentaion.  Some changes were made to illustrate some of the
* features of the MPW Assembler, but most comments and the order of the code is
* the same as the Pascal example.

				TITLE			'Sample - A small sample application'
				BLANKS			OFF 	; allow comments without semicolons

* The PRINT directive turns off listing (if a listing is being generated using
* -l command line option) of the standard include files.  The INCLUDEs bring in
* the equate and trap definitions needed by Sample.  We could use the LOAD/DUMP
* facilities on these includes if we intended to assemble this program over and
* over again, but that would confuse the example here.

				PRINT			OFF
				INCLUDE 		'Traps.a'
				INCLUDE 		'ToolEqu.a'
				INCLUDE 		'QuickEqu.a'
				INCLUDE 		'SysEqu.a'
				PRINT			ON

* A small macro definition to illustrate some of the macro processor's power.
* In the code we need to do "case" statements to process the Edit menu items,
* the main event loop event cases, and the mouse down event cases. The following
* macro is used to generate a branch based on an index value in a D-register.
* The branch is through a table of relative addresses also generated by this
* macro.  The macro is called in one of two forms as follows:

*  {Form #1}	Case#			(Dreg,Default),case0,case1,...caseN
*  {Form #2}	Case#.<size>	(Dreg,IF),(cst0,case0),...,(cstN,caseN)

* The "Dreg" is a D-register with a value from 0 to N.	In Form #1, the
* "Default" specifies a label for any omitted case labels not specified
* explicitly. The "case0", "case1",..."caseN" are case labels identifying the
* various cases to be processed.  A case label may be omitted, in which case
* the "Default" is used. The "Default" may also be omitted, but in that case all
* case labels must be specified. If there are fewer case labels than there are
* cases, but there are N possible values for the case index, the proper number
* of trailing commas must be supplied to generate the defaults.

* In Form #2, the default is specified as the word "IF".  In this form the macro
* generates a set of compares (CMPI's) and branches (BEQ) for each specified
* case (there is no implicit default).	Each case is a constant/label pair.
* The constant is compared (CMPI.W) and an branch is done (BEQ) to the case if
* the Dreg equals the constant.  A size may be specified for all the branches
* as a <size> attribute to the Case# call itself.  This must either be an "S"
* or "W" to generate BEQ.S's or BEQ.W's.  The default is for "S".

				MACRO
				Case#.&Size 	&IdxDef
				PRINT			Push,NoMDir 	Only list generated code
				LCLA			&i				Index to macro parameters
				LCLA			&n				Total number of macro parameters
				LCLC			&Dreg,&Def		The Dreg and Default parameters
				LCLC			&sz 			The <size> value
.*
&Dreg			SETC			&IdxDef[1]		Pick off 1st opnd of sublist
&Def			SETC			&IdxDef[2]		Pick off 2nd opnd of sublist
&n				SETA			&Nbr(&Syslist)	Done for efficiency
&i				SETA			2				Cases start at 2nd parameter
.*
	  IF &UpCase(&Def) <> 'IF' THEN
.*
				ADD 			&Dreg,&Dreg
				MOVE			Case&SysNdx(&Dreg),&Dreg
				JMP 			Case&SysNdx(&Dreg)
Case&SysNdx
.*
		WHILE &i <= &n DO		Process each case label
		  IF &SysList[&i] <> '' THEN
.*
				DC.W			&SysList[&i]-Case&SysNdx
.*
		  ELSE
.*
				DC.W			&Def-Case&SysNdx
.*
		  ENDIF
		  &i: SETA &i+1 		Count off parameter
		ENDWHILE
	  ELSE						Process (Cst,lbl) pairs
		&Sz: SETC &Default(&Size, 'S') Setup size attribute
		WHILE &i <= &n DO		Process each (Cst,lbl) pair
.*
				CMPI			#&SysList[&i,1],&Dreg
				BEQ.&Sz 		&SysList[&i,2]
.*
		&i: SETA &i+1			Count off parameter
		ENDWHILE
	  ENDIF
.*
				PRINT			Pop 			Restore original print status
				ENDM

				TITLE			'Global Declarations for Sample'

*************
* Constants *
*************

appleID 		EQU 			128 		Resource IDs/menu IDs for Apple,
fileID			EQU 			129 			File, and Edit menus
editID			EQU 			130

menuCount		EQU 			3			Total number of menus

windowID		EQU 			128 		Resource ID for application'w window

undoCommand 	EQU 			1			Menu item numbers identifying
cutCommand		EQU 			3				commands in Edit menu
copyCommand 	EQU 			4
pasteCommand	EQU 			5
clearCommand	EQU 			6

aboutMeDLOG 	EQU 			128 		Resource ID for the "about" dialog

authorItem		EQU 			2			"About sample" dialog item numbers
languageItem	EQU 			3


*********
* Types *
*********

* To illustrate how the template type feature works the following templates are
* declared and used instead of the simple offsets defined in the equate files.
* By using these, the Assember source appromixates very closely the Pascal
* source for referencing the corresponding information.  Perhaps someday we will
* have a set of "equate" files that define types just like Pascal USES units do!

Point			RECORD			0			Point = RECORD CASE INTEGER OF
v				DS.W			1					  1: (v: INTEGER;
h				DS.W			1						  h: INTEGER);
				ORG 			v					  2: (vh: ARRAY[1..2]
vh				DS.W			h								 OF INTEGER)
				ENDR								END;

Rect			RECORD			0			Rect  = RECORD CASE INTEGER OF
top 			DS.W			1					  1: (top:	  INTEGER;
left			DS.W			1						  left:   INTEGER;
bottom			DS.W			1						  bottom: INTEGER;
right			DS.W			1						  right:  INTEGER);
				ORG 			top
topLeft 		DS.L			Point				  2:  (topLeft:  Point;
botRight		DS.L			Point				  3:  (botRight: Point)
				ENDR								END;

BitMap			RECORD			0			BitMap = RECORD
baseAddr		DS.L			1					  baseAddr: QDPtr;
rowBytes		DS.W			1					  rowBytes: INTEGER;
bounds			DS.L			Rect				  bounds:	 Rect
				ENDR								END;

EventRecord 	RECORD			0			EventRecord = RECORD
what			DS.W			1					  what:    INTEGER;
message 		DS.L			1					  message:	 LONGINT;
when			DS.L			1					  when:    LONGINT;
where			DS.L			Point				  where:	   Point;
modifiers		DS.W			1					  modifiers: INTEGER
				ENDR								END;

				EJECT

***********************
* QuickDraw's Globals *
***********************

* The following data module is used to define the QuickDraw global data area.
*				-----------

QuickDraw		RECORD			,DECREMENT
thePort 		DS.L			1
white			DS.B			8
black			DS.B			8
gray			DS.B			8
ltGray			DS.B			8
dkGray			DS.B			8
arrow			DS.B			cursRec
screenBits		DS.B			BitMap
randSeed		DS.L			1
				ORG 			-grafSize
				ENDR


**************************
* Global Data for Sample *
**************************

* This is the global data used by Sample.  Both these and the QuickDraw data
* above are referenced through a WITH statetment at the beginning of the procs
* that use this data. Since the Assembler knows when it is referencing data
* in a data module (since they must be declared before they are accessed),
* and since such data can only be accessed based on A5, there is no need to
* explicitly specify A5 in any code which references the data (unless indexing
* is used).  Thus, in this program we have omitted all A5 references when
* referencing the data.

GlobalData		RECORD
appleMenuH		DS.L			1				Handle to the Apple menu
fileMenuH		DS.L			1				Handle to the File menu
editMenuH		DS.L			1				Handle to the Edit menu
dragRect		DS.L			Rect			Drag limits
txRect			DS.L			Rect			TextEdit's limits
doneFlag		DS.B			1				True if Quit command processed
myEvent 		DS.L			EventRecord 	Current event info
wRecord 		DS.B			windowSize		The application window record
myWindow		DS.L			1				Ptr to the application window
whichWindow 	DS.L			1				Current event's window
textH			DS.L			1				TextEdit's text handle
mousePt 		DS.L			Point			Used to get current mouse point
iBeamHdl		DS.L			1				Handle to the iBeam cursor
				ENDR


				TITLE			'SetupMenus - Set up menus and menu bar'

******************************************
* SetUpMenus - Set up menus and menu bar *
******************************************

* This is a code module used only during initialization.  Note, just as in the
* Pascal version, this is a distinct code module.  Also, since SetUpMenus is
* only called during initialization, there is no need to keep it loaded.  So
* we will place SetUpMenus in its own segment (called "Initialize") and unload
* it after SetUpMenus returns.

				SEG 			'Init'			This illustrates segmenting!
SetUpMenus		PROC
				WITH			GlobalData
				SUBQ			#4,A7			Read Apple menu from resource
				MOVE			#appleID,-(A7)		file
				_GetRMenu		;				appleMenuH := GetMenu(appleID);
				MOVE.L			(A7),appleMenuH Leave extra copy of handle on
				MOVE.L			(A7),-(A7)			stack for _AddResMenu
				CLR 			-(A7)			Install Apple menu in menu bar
				_InsertMenu 	;				InsertMenu(appleMenuH, 0);
				MOVE.L			#'DRVR',-(A7)	Add DA names to Apple menu
				_AddResMenu 	;				AddResMenu(appleMenuH, 'DRVR');

				SUBQ			#4,A7			Read File menu from resource
				MOVE			#fileID,-(A7)		file
				_GetRMenu		;				fileMenuH := GetMenu(fileID);
				MOVE.L			(A7),fileMenuH
				CLR 			-(A7)			Install File menu in menu bar
				_InsertMenu 	;				InsertMenu(fileMenuH, 0);

				SUBQ			#4,A7			Read Edit menu from resource
				MOVE			#editID,-(A7)		file
				_GetRMenu		;				editMenuH := GetMenu(editID);
				MOVE.L			(A7),editMenuH
				CLR 			-(A7)			Install Edit menu in menu bar
				_InsertMenu 	;				InsertMenu(editMenuH, 0);

				_DrawMenuBar	;				Draw the menu bar
				RTS 							Exit
				ENDP


				TITLE			'ShowAboutMeDialog - Display the "About"...'

**********************************************
* ShowAboutMeDialog - Display the "About"... *
**********************************************

* This procedure is called from DoCommand when item #1 is selected from the
* apple menu list.	It sets up a dialog box indicating the author and language
* of this sample program.  The box remains until the user clicks the mouse on
* the continue button.

				SEG 			;				Undo SEG done above
ShowAboutMeDialog PROC

StackFrame		RECORD			{A6Link},DECR	Stack frame for some locals
RetAddr 		DS.L			1				Return address
A6Link			DS.L			1				Caller's A6

savePort		DS.L			1				Port at the time of call
itemType		DS.W			1				Returned by _GetDItem (not used)
itemHdl 		DS.L			1				Handle to the item
itemRect		DS.W			Rect			Returned by _GetDItem (not used)
itemHit 		DS.W			1				Part code

LocalSize		EQU 			*				Size of the local stack frame
				ENDR

theDialog		EQU 			A3				Dialog pointer

				WITH			StackFrame		Cover our local stack frame
*
* Start here: create new stack frame, save regs, current grafPort, and allocate
* space for the dialog box
*
				LINK			A6,#LocalSize	Allocate our local stack frame
				MOVE.L			A3,-(A7)		We need another register here
				PEA 			savePort(A6)	Remember the current grafPort
				_GetPort		;				across this routine
				SUBQ.W			#4,A7			Create a new dialog
				MOVE.W			#aboutMeDLOG,-(A7) Dialog is defined as a resource
				CLR.L			-(A7)			Dialog mgr will allocate space
				PEA 			-1				Dialog box will be top window
				_GetNewDialog
				MOVE.L			(A7),theDialog	theDialog holds ptr to dialog info
				_SetPort		;				Set the current grafPort
*
* Fill in the dialog box with the proper author and language
*
				MOVE.L			theDialog,-(A7) Get dialog's author item info
				MOVE.W			#authorItem,-(A7)
				PEA 			itemType(A6)
				PEA 			itemHdl(A6) 	Only interested in itemHdl
				PEA 			itemRect(A6)
				_GetDItem
				MOVE.L			itemHdl(A6),-(A7)
				PEA 			#'Nebur L. Ari' Note use of literal here
				_SetIText		;				Update the author item

				MOVE.L			theDialog,-(A7) Get dialog's language info
				MOVE.W			#languageItem,-(A7)
				PEA 			itemType(A6)
				PEA 			itemHdl(A6) 	Still only interested in itemHdl
				PEA 			itemRect(A6)
				_GetDItem
				MOVE.L			itemHdl(A6),-(A7)
				PEA 			#'Assembler'	Note use of literal here
				_SetIText		;				Update the language item
*
* Wait for user to click the continue button
*
WaitForOk		CLR.L			-(A7)			Wait for the click...
				PEA 			itemHit(A6)
				_ModalDialog
				CMPI.W			#okButton,itemHit(A6)
				BNE.S			WaitForOk		Loop until continue clicked
*
* User is now satisfied -- let's get out of here!
*
				MOVE.L			A3,-(A7)		Close the dialog box
				_CloseDialog
				MOVE.L			savePort(A6),-(A7)
				_SetPort		;				Put original grafPort back

				MOVE.L			(A7)+,theDialog Restore the saved register
				UNLK			A6				Unlink our local stack frame
				RTS 							Exit
				ENDP


				TITLE			'DoCommand - Execute a menu command'

***********************************************************************
* DoCommand - Execute command specified by the result of a MenuSelect *
***********************************************************************

* This is another code module which takes as a parameter the MenuSelect return
* value.  It is next to the top of the stack just before the return address.

DoCommand		PROC
return			EQU 			A6				The return address will be in A6
mResult 		EQU 			D3				mResult will be kept in D3
theItem 		EQU 			mResult 		LoWord(mResult) is mResult
*													treated as a word

* The following defines some local data known only to this proc.
				DATA			;				Switch into local data section
name			DS.B			256 			Desk accessory name string
				CODE							Switch back to code section

				WITH			GlobalData
				MOVEA.L 		(A7)+,return	Pop return into A6
				MOVE.L			(A7)+,mResult	Pop mResult parameter

				MOVE.L			mResult,D0		Case on menu ID in
				SWAP			D0					high-order word of mResult
				Case#			(D0,IF),(appleID,appleMenu), \	Continued
										(fileID, fileMenu),  \	Lines
										(editID, editMenu)
				BRA.S			Exit
*
* Apple menu processing
*
appleMenu		MOVE.L			appleMenuH,-(A7) Call Menu Manager to get DA
				MOVE			theItem,-(A7)		name
				PEA 			name
				_GetItem		;				GetItem(appleMenuH, theItem, name);
				CMPI.W			#1,theItem
				BNE.S			assumeDeskAcc
				JSR 			ShowAboutMeDialog
				BRA.S			itworks
assumeDeskAcc
				SUBQ			#2,A7			Call Desk Manager to open DA
				PEA 			name
				_OpenDeskAcc	;				OpenDeskAcc(name);
				ADDQ			#2,A7			(OpenDeskAcc result not used)
itworks
				MOVE.L			myWindow,-(A7)	Call QuickDraw to restore application
				_SetPort		;					window as grafPort
				BRA.S			Exit			Exit
*
* File menu processing
*
fileMenu		ST				doneFlag		Set flag to Quit (caller tests)
				BRA.S			Exit			Exit
*
* Edit menu processing
*
editMenu		SUBQ			#2,A7			Call Desk Manager to handle editing command
				MOVE			theItem,D1		if DA window is the active window
				SUBQ			#1,D1			SystemEdit requires item adjustment
				MOVE			D1,-(A7)		since theItem is 1 high for it
				_SysEdit		;				SystemEdit(theItem-1);
				MOVE.B			(A7)+,D0		If SystemEdit returns TRUE
				BNE.S			Exit				just exit, there is nothing to do
								;				Case on menu item (command) number
				Case#			(theItem,IF),(cutCommand,	Cut),	\ These
											 (copyCommand,	Copy),	\	are
											 (pasteCommand, Paste), \	 continued
											 (clearCommand, Klear)
				BRA.S			Exit
Cut
				MOVE.L			textH,-(A7) 	TECut(textH);
				_TECut
				BRA.S			Exit
Copy
				MOVE.L			textH,-(A7) 	TECopy(textH);
				_TECopy
				BRA.S			Exit
Paste
				MOVE.L			textH,-(A7) 	TEPaste(textH);
				_TEPaste
				BRA.S			Exit
Klear
				MOVE.L			textH,-(A7) 	TEDelete(textH);
				_TEDelete
Exit							;				To indicate completion of
				CLR.W			-(A7)			command, call Menu Manager
				_HiliteMenu 	;				to unhighlight menu title
				JMP 			(return)		HiliteMenu(0); {highlighted by MenuSelect}
				ENDP


				TITLE			'Sample - Main Program'

***********************************************
* Sample Main Program - Execution starts here *
***********************************************

* This is another code module.	It is declared as the main code module which
* means execution will start here.

Sample			MAIN
				WITH			QuickDraw,GlobalData  Cover our data areas
*
* Initialization
*
				PEA 			thePort 		Initialize QuickDraw
				_InitGraf
				_InitFonts		;				Initialize Font Manager
				MOVE.L			#$0000FFFF,D0	Discard any previous events
				_FlushEvents	;				FlushEvents(EventEvent, 0);
				_InitWindows	;				Initialize Window Manager
				_InitMenus		;				Initialize Menu Manager
				_TEInit 		;				Initialize TextEdit
				CLR.L			-(A7)			Initialize Dialog Manager
				_InitDialogs	;				InitDialogs(NIL);
				_InitCursor 	;				Make cursor an arrow

				SUBQ.W			#4,A7			Get the iBeam cursor handle to
				MOVE.W			#iBeamCursor,-(A7) use in the main ctl loop when
				_GetCursor		;				cursor is in the window
				MOVE.L			(A7)+,iBeamHdl	iBeamHdl:=GetCursor(iBeamCursor);

				JSR 			SetUpMenus		Set up menus and menu bar
				PEA 			SetUpMenus		Unload the SetUpMenus segment
				_UnLoadSeg		;				Since we will never call it again

				WITH			screenBits.bounds
				PEA 			dragRect		Call QuickDraw to set dragging
				MOVE			#4,-(A7)		boundaries; ensure at least
				MOVE			#24,-(A7)		4 by 4 pixels will remain visible
				MOVE			right,D0
				SUBQ			#4,D0
				MOVE			D0,-(A7)
				MOVE			bottom,D0
				SUBQ			#4,D0
				MOVE			D0,-(A7)
				_SetRect		;				SetRect(dragRect, 4, 24,
				ENDWITH 		;					right-4, bottom-4);

				CLR.B			doneFlag		Flag to detect Quit command

				SUBQ			#4,A7			Put up application window
				MOVE			#windowID,-(A7)
				PEA 			wRecord
				MOVE.L			#-1,-(A7)
				_GetNewWindow	;				myWindow := GetNewWindow(windowID,
				MOVE.L			(A7),myWindow		 @wRecord, Ptr(-1));
				_SetPort		;				Set current grafPort to this window
				MOVE.L			thePort,A0		Rectangle for text in window
				MOVE.L			portRect+topLeft(A0),txRect.topLeft
				MOVE.L			portRect+botRight(A0),txRect.botRight
				PEA 			txRect			Call QuickDraw to bring it in 4
				MOVE			#4,-(A7)		pixels from left and right edges
				CLR 			-(A7)			of window
				_InSetRect		;				InsetRect(txRect, 4, 0);
				SUBQ			#4,A7			Call TextEdit to prepare
				PEA 			txRect				for receiving text
				PEA 			txRect
				_TENew			;				textH := TENew(txRect, txRect);
				MOVE.L			(A7)+,textH

				EJECT
*
* Main Event Loop
*
MainEventLoop					;				Call Desk Manager to perform periodic
				_SystemTask 	;					actions defined for DAs

				SUBQ.W			#4,A7			Get ptr to the front window
				_FrontWindow
				MOVE.L			(A7)+,D0
				CMP.L			myWindow,D0 	Is the front window my mindow ?
				BNE.S			@3				No
				PEA 			mousePt 		Yes
				_GetMouse		;				Is mouse pointing in my window ?
				SUBQ.W			#2,A7
				MOVE.L			mousePt,-(A7)
				MOVEA.L 		myWindow,A0
				PEA 			portRect(A0)
				_PtInRect		;				PtInRect(mousePt, myWindow^.portRect);
				TST.B			(A7)+			Does mouse point into the window ?
				BEQ.S			@1				No, use the arrow cursor
				MOVE.L			iBeamHdl,A0 	Yes, use the iBeam cursor
				MOVE.L			(A0),-(A7)
				BRA.S			@2
@1
				PEA 			arrow			Arrow cursor if not inside window
@2
				_SetCursor		;				Set cursor to arrow or iBeam

				MOVE.L			textH,-(A7) 	Call TextEdit to make vertical bar blink
				_TEIdle 		;				TEIdle(textH);
@3
				SUBQ			#2,A7			Call ToolBox Event Manager to get
				MOVE			#everyEvent,-(A7)	get the next event that the
				PEA 			myEvent 			application should handle
				_GetNextEvent	;				GetNextEvent(everyEvent, myEvent);
				MOVE.B			(A7)+,D0
				BEQ.S			MainEventLoop	If not event, just loop

				MOVE			myEvent.what,D0 Fetch the event number
				Case#			(D0,MainEventLoop), \
									,			\	  0: Null
									mouseDown,	\	  1: Mouse down
									,			\	  2: Mouse up (not used)
									keyDown,	\	  3: Key down
									,			\	  4: Key up (not used)
									autoKey,	\	  5: Auto key
									update, 	\	  6: Update
									,			\	  7: Disk inserted (not used)
									activate,	\	  8: Activate
									,,,,,,		;  9-15: (not used)
*
* Mouse down event processing
*
mouseDown		SUBQ			#2,A7			Mouse button down:
				MOVE.L			myEvent.where,-(A7) Call Window Manager to learn
				PEA 			whichWindow 		where
				_FindWindow 	;				FindWindow(myEvent.where, whichWindow);
				MOVE			(A7)+,D0		Case on window region
				Case#			(D0,IF),(inMenuBar,  MenuBar),	 \
										(inSysWindow,SysWindow), \
										(inContent,  Content),	 \
										(inDrag,	 Drag)
				BRA 			MainEventLoop
MenuBar
				SUBQ			#4,A7			Menu bar:
				MOVE.L			myEvent.where,-(A7) Call Menu Manager to learn
				_MenuSelect 	;					which command
				JSR 			DoCommand		DoCommand(MenuSelect(myEvent.where, ));
				TST.B			doneFlag		Did we process the Quit command ?
				BEQ 			MainEventLoop	No, keep looping
				RTS 							Yes, exit program
SysWindow
				PEA 			myEvent 		Desk accessory window:
				MOVE.L			whichWindow,-(A7)	Call Desk Manager to handle it
				_SystemClick	;				SystemClick(myEvent, whichWindow);
				BRA 			MainEventLoop	Keep looping
Drag
				MOVE.L			whichWindow,-(A7) Title bar:
				MOVE.L			myEvent.where,-(A7) Call Window Manager to drag
				PEA 			dragRect
				_DragWindow 	;				DragWindow(whichWindow,myEvent.where,dragRect);
				BRA 			MainEventLoop	Keep looping
Content
				SUBQ			#4,A7			Body of application window:
				_FrontWindow	;				Call Window Manager to check whether
				MOVE.L			(A7)+,D0		it's the active window and make it
				CMP.L			whichWindow,D0	active if not
				BEQ.S			@1				If app window is active, hop
				MOVE.L			whichWindow,-(A7)
				_SelectWindow	;				If new window, select it
				BRA 			MainEventLoop	Keep looping
@1
				PEA 			myEvent.where	App window already active:
				_GlobalToLocal	;					Call QuickDraw to convert window
				MOVE.L			myEvent.where,-(A7) 	coordinates for REClick
				MOVE			myEvent.modifiers,D0
				BTST			#shiftKey,D0
				SNE 			-(A7)			Indicate if shift key is down
				MOVE.L			textH,-(A7) 	Call TextEdit to process the event
				_TEClick		;				TEClick(muEvent.where, extended, textH);
				BRA 			MainEventLoop	Keep looping
*
* Key down and Auto key event processing
*
keyDown
autoKey 						;				Key pressed
				BTST			#CmdKey,myEvent.modifiers
				BEQ.S			@1				If command key down, call Menu
				SUBQ			#4,A7			Manager to learn which command
				MOVE			myEvent.message+2,-(A7)
				_MenuKey
				JSR 			DoCommand		DoCommand(MenuKey(Chr(myEvent.message+2)));
				TST.B			doneFlag		Did we process the Quit command ?
				BEQ 			MainEventLoop	No, keep looping
				RTS 							Yes, exit program
@1
				MOVE			myEvent.message+2,-(A7) Pass char to TextEdit
				MOVE.L			textH,-(A7)
				_TEKey			;				TeKey(Chr(myEvent.message+2), textH);
				BRA 			MainEventLoop	Keep looping
*
* Activate/deactivate event processing
*
activate		MOVE			myEvent.modifiers,D0 App window status changed
				BTST			#activeFlag,D0	Is window becoming active ?
				BEQ.S			deactivate		No, some other window is
				MOVE.L			textH,-(A7) 	App window is becoming active
				_TEActivate 	;				Call TextEdit to highlight selection
				MOVE.L			editMenuH,-(A7) Call Menu Manager to disable Undo
				MOVE			#undoCommand,-(A7)
				_DisableItem	;				DisableItem(editMenuH, undoCommand);
				BRA 			MainEventLoop	Keep looping
deactivate
				MOVE.L			textH,-(A7) 	App window is becoming inactive
				_TEDeactivate	;				Unhighlight selection
				MOVE.L			editMenuH,-(A7) Enable Undo since desc. acc. may
				MOVE			#undoCommand,-(A7) support it
				_EnableItem 	;				EnableItem(editMenuH, undoCommand);
				BRA 			MainEventLoop	Keep looping
*
* Update event processing
*
update			MOVE.L			myEvent.message,-(A7) Window appearance needs updating
				_BeginUpDate	;				Call Window Manager to begin update
				MOVEA.L 		thePort,A3		We need thePort^.portRect
				PEA 			portRect(A3)
				_EraseRect		;				Call QuickDraw to erase text area
				PEA 			portRect(A3)
				MOVE.L			textH,-(A7)
				_TEUpdate		;				Call TextEdit to update the text
				MOVE.L			myEvent.message,-(A7)
				_EndUpDate		;				Call Window Manager to end update
				BRA 			MainEventLoop	Keep looping

				END 			;				of Sample
