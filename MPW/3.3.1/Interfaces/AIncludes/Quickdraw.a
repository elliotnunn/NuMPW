;	File:		Quickdraw.a
;
;	Copyright:	© 1983-1993 by Apple Computer, Inc.
;				All rights reserved.
;
;	Version:	System 7.1• for ETO #13
;	Created:	Tuesday, March 30, 1993 18:00
;	Modified:	Tue, Nov 30, 1993 11:37:47
;
;___________________________________________________________________________

	IF &TYPE('__INCLUDINGQUICKDRAW__') = 'UNDEFINED' THEN
__INCLUDINGQUICKDRAW__	SET	1

	IF &TYPE('__INCLUDINGSYSEQU__') = 'UNDEFINED' THEN
 INCLUDE 'SysEqu.a'
 	ENDIF

; Transfer modes

srcCopy   		EQU 		0
srcOr 			EQU 		1
srcXor			EQU 		2
srcBic			EQU 		3
notSrcCopy		EQU 		4
notSrcOr  		EQU 		5
notSrcXor 		EQU 		6
notSrcBic 		EQU 		7
patCopy   		EQU 		8
patOr 			EQU 		9
patXor			EQU 		10
patBic			EQU 		11
notPatCopy		EQU 		12
notPatOr  		EQU 		13
notPatXor 		EQU 		14
notPatBic 		EQU 		15

; Arithmetic transfer modes
blend 			EQU 		32
addPin			EQU 		33
addOver   		EQU 		34
subPin			EQU 		35
adMax 			EQU 		37
subOver   		EQU 		38
adMin 			EQU 		39

; Special text mode
grayishTextOr	EQU			49

ditherCopy		EQU			64						;promote source to 32-bit and then dither down

; Flags passed to DeviceLoop

singleDevicesBit	EQU		0
dontMatchSeedsBit	EQU		1
allDevicesBit		EQU		2

singleDevices		EQU		1
dontMatchSeeds		EQU		2
allDevices			EQU		4

; Definitions for Font Style Bits (right to left)

boldBit   		EQU 		0

; Transparent mode constant
transparent   	EQU 		36
italicBit 		EQU 		1
ulineBit  		EQU 		2
outlineBit		EQU 		3
shadowBit 		EQU 		4
condenseBit   	EQU 		5
extendBit 		EQU 		6


; FontInfo record

ascent			EQU 		0         				; ascent [word]
descent   		EQU 		2         				; descent [word]
widMax			EQU 		4         				; maximum width [word]
leading   		EQU 		6         				; leading [word]

FontInfo             RECORD  0
ascent               DS.W    1            ; short
descent              DS.W    1            ; short
widMax               DS.W    1            ; short
leading              DS.W    1            ; short
size                 EQU     *
                     ENDR


; Point structure

v 				EQU 		0         				; vertical coordinate [word]
h 				EQU 		2         				; horizontal coordinate [word]


; Rectangle structure

topLeft   		EQU 		0         				; upper left corner [point]
botRight  		EQU 		4         				; lower right corner [point]
top   			EQU 		0         				; top coordinate [word]
left  			EQU 		2         				; left coordinate [word]
bottom			EQU 		4         				; bottom coordinate [word]
right 			EQU 		6         				; right coordinate [word]

; Bitmap Structure

baseAddr  		EQU 		0         				; bitmap base address [pointer]
rowBytes  		EQU 		4         				; row bytes (must be even) [word]
bounds			EQU 		6         				; bounding box [rectangle]
bitmapRec 		EQU 		14        				; size of a bitmap

BitMapRecord         RECORD  0
baseAddr             DS.L    1            ; Ptr
rowBytes             DS.W    1            ; short
bounds               DS      Rect
size                 EQU     *
                     ENDR


; Cursor Structure

data  			EQU 		0         				; visible bits [32 bytes]
mask  			EQU 		$20       				; mask bits [32 bytes]
hotSpot   		EQU 		$40       				; relative origin [point]
cursRec   		EQU 		68        				; size of a cursor

Cursor               RECORD  0
data                 DS.B    32           ; Bits16
mask                 DS.B    32           ; Bits16
hotSpot              DS      Point
size                 EQU     *
                     ENDR


; PenState record

psLoc 			EQU 		0         				; pen location [point]
psSize			EQU 		4         				; pen size [point]
psMode			EQU 		8         				; pen mode [word]
psPat 			EQU 		10        				; pen [pattern]
psRec 			EQU 		18        				; size of pen state

PenState             RECORD  0
pnLoc                DS      Point
pnSize               DS      Point
pnMode               DS.W    1            ; short
pnPat                DS.B    8            ; Pattern
size                 EQU     *
                     ENDR


; Polygon record

polySize  		EQU 		0         				; total bytes [word]
polyBBox  		EQU 		2         				; bounding box [rectangle]
polyPoints		EQU 		10        				; vertices [Points]

Polygon              RECORD  0
polySize             DS.W    1            ; short
polyBBox             DS      Rect
polyPoints           DS.B    Point.size*1
size                 EQU     *
                     ENDR


; Region Structure

rgnSize   		EQU 		0         				; total bytes [word]
rgnBBox   		EQU 		2         				; bounding box [rectangle]
rgnData   		EQU 		10        				; region data [array]

Region               RECORD  0
rgnSize              DS.W    1            ; short: size in bytes
rgnBBox              DS      Rect         ;enclosing rectangle
size                 EQU     *
                     ENDR


; Picture Structure

picSize   		EQU 		0         				; total bytes [word]
picFrame  		EQU 		2         				; bounding box [rectangle]
picData   		EQU 		10        				; picture byte codes [array]

Picture              RECORD  0
picSize              DS.W    1            ; short
picFrame             DS      Rect
size                 EQU     *
                     ENDR


OpenCPicParams	RECORD	0
srcRect		ds.w	4
hRes		ds.l	1
vRes		ds.l	1
version		ds.w	1
reserved1	ds.w	1
reserved2	ds.l	1
			ENDR
			
; QDProcs structure

textProc  		EQU 		0         				; [pointer]
lineProc  		EQU 		4         				; [pointer]
rectProc  		EQU 		8         				; [pointer]
rRectProc 		EQU 		$C        				; [pointer]
ovalProc  		EQU 		$10       				; [pointer]
arcProc   		EQU 		$14       				; [pointer]
polyProc  		EQU 		$18       				; [pointer]
rgnProc   		EQU 		$1C       				; [pointer]
bitsProc  		EQU 		$20       				; [pointer]
commentProc   	EQU 		$24       				; [pointer]
txMeasProc		EQU 		$28       				; [pointer]
getPicProc		EQU 		$2C       				; [pointer]
putPicProc		EQU 		$30       				; [pointer]
qdProcsRec		EQU 		$34       				; size of QDProcs record

QDProcs              RECORD  0
textProc             DS.L    1            ; Ptr
lineProc             DS.L    1            ; Ptr
rectProc             DS.L    1            ; Ptr
rRectProc            DS.L    1            ; Ptr
ovalProc             DS.L    1            ; Ptr
arcProc              DS.L    1            ; Ptr
polyProc             DS.L    1            ; Ptr
rgnProc              DS.L    1            ; Ptr
bitsProc             DS.L    1            ; Ptr
commentProc          DS.L    1            ; Ptr
txMeasProc           DS.L    1            ; Ptr
getPicProc           DS.L    1            ; Ptr
putPicProc           DS.L    1            ; Ptr
size                 EQU     *
                     ENDR


; GrafPort Structure

device			EQU 		$0        				; device code [word]
portBits  		EQU 		$2        				; port's bitmap [bitmap]
portBounds		EQU 		$8        				; bounding box of bitmap [rect]
portRect  		EQU 		$10       				; port's rectangle [rect]
visRgn			EQU 		$18       				; visible region [handle]
clipRgn   		EQU 		$1C       				; clipping region [handle]
bkPat 			EQU 		$20       				; background [pattern]
fillPat   		EQU 		$28       				; fill [pattern]
pnLoc 			EQU 		$30       				; pen location [point]
pnSize			EQU 		$34       				; pen size [point]
pnMode			EQU 		$38       				; pen mode [word]
pnPat 			EQU 		$3A       				; pen [pattern]
pnVis 			EQU 		$42       				; pen visible [word]
txFont			EQU 		$44       				; text font [word]
txFace			EQU 		$46       				; text face [word]
txMode			EQU 		$48       				; text mode [word]
txSize			EQU 		$4A       				; text size [word]
spExtra   		EQU 		$4C       				; space extra [fixed]
fgColor   		EQU 		$50       				; foreground color mask [long]
bkColor   		EQU 		$54       				; background color mask [long]
colrBit   		EQU 		$58       				; color bit [word]
patStretch		EQU 		$5A       				; pattern stretch [word]
picSave   		EQU 		$5C       				; picture being saved [handle]
rgnSave   		EQU 		$60       				; region being saved [handle]
polySave  		EQU 		$64       				; polygon being saved [handle]
grafProcs 		EQU 		$68       				; QDProcs array [pointer]
portRec   		EQU 		$6C       				; size of grafport

GrafPort             RECORD  0
device               DS.W    1            ; short
portBits             DS      BitMapRecord
portRect             DS      Rect
visRgn               DS.L    1            ; RgnHandle
clipRgn              DS.L    1            ; RgnHandle
bkPat                DS.B    8            ; Pattern
fillPat              DS.B    8            ; Pattern
pnLoc                DS      Point
pnSize               DS      Point
pnMode               DS.W    1            ; short
pnPat                DS.B    8            ; Pattern
pnVis                DS.W    1            ; short
txFont               DS.W    1            ; short
txFace               DS.B    1            ; Style: txFace is unpacked byte but push as short
filler               DS.B    1            ; Byte
txMode               DS.W    1            ; short
txSize               DS.W    1            ; short
spExtra              DS.L    1            ; Fixed
fgColor              DS.L    1            ; long
bkColor              DS.L    1            ; long
colrBit              DS.W    1            ; short
patStretch           DS.W    1            ; short
picSave              DS.L    1            ; Handle
rgnSave              DS.L    1            ; Handle
polySave             DS.L    1            ; Handle
grafProcs            DS.L    1            ; QDProcsPtr
size                 EQU     *
                     ENDR


; QuickDraw Global Variables


GrafGlobals   	EQU 		0         				; A5 offset to globptr
thePort   		EQU 		0         				;GrafPtr
white 			EQU 		thePort-8     			;Pattern
black 			EQU 		white-8       			;Pattern
gray  			EQU 		black-8       			;Pattern
ltGray			EQU 		gray-8        			;Pattern
dkGray			EQU 		ltGray-8      			;Pattern
arrow 			EQU 		dkGray-68     			;Cursor
screenBits		EQU 		arrow-14      			;BitMap
randSeed  		EQU 		screenBits-4      		;LONGINT

; color manager equates

; RGBColor structure

red   			EQU 		$0        				;red channel intensity [short]
green 			EQU 		$2        				;green channel intensity[short]
blue  			EQU 		$4        				;blue channel intensity [short]
rgbColor  		EQU 		$6        				;size of record

RGBColorRec          RECORD  6,DECREMENT
size                 EQU     *
blue                 DS.W    1            ;magnitude of blue component
green                DS.W    1            ;magnitude of green component
red                  DS.W    1            ;magnitude of red component
                     ENDR

; ColorSpec structure

value 			EQU 		$0        				;value field [short]
rgb   			EQU 		$2        				;rgb values [rgbColor]
colorSpecSize 	EQU 		$8        				;size of record

ColorSpec            RECORD  0
value                DS.W    1            ; short: index or other value
rgb                  DS      RGBColorRec  ;true color
size                 EQU     *
                     ENDR


; MatchRec structure

;red EQU $0 ;defined in RGBColor
;green EQU $2 ;defined in RGBColor
;blue EQU $4 ;defined in RGBColor
matchData 		EQU 		$6        				; [long]
matchRecSize  	EQU 		$A

MatchRec             RECORD  0
red                  DS.W    1            ; short
green                DS.W    1            ; short
blue                 DS.W    1            ; short
matchData            DS.L    1            ; long
size                 EQU     *
                     ENDR


; Color Separation

normalBit 		EQU 		0         				; normal screen mapping
inverseBit		EQU 		1         				; inverse screen mapping
redBit			EQU 		4         				; RGB additive mapping
greenBit  		EQU 		3         				; for photos from screen
blueBit   		EQU 		2
cyanBit   		EQU 		8         				; CMYBk subtractive mapping
yellowBit 		EQU 		6
magentaBit		EQU 		7         				; for ink jet printer
blackBit  		EQU 		5
blackColor		EQU 		33
whiteColor		EQU 		30
redColor  		EQU 		205
greenColor		EQU 		341
blueColor 		EQU 		409
cyanColor 		EQU 		273
magentaColor  	EQU 		137
yellowColor   	EQU 		69


; Standard Picture Comments

picLParen 		EQU 		0
picRParen 		EQU 		1

; QuickDraw verbs

frame 			EQU 		0
paint 			EQU 		1
erase 			EQU 		2
invert			EQU 		3
fill  			EQU 		4

; QuickDraw private global variables

wideOpen  		EQU 		randSeed-4    			;RgnHandle
wideMaster		EQU 		wideOpen-4    			;RgnPtr
wideData  		EQU 		wideMaster-10     		;Fake Region
rgnBuf			EQU 		wideData-4    			;PointsHandle
rgnIndex  		EQU 		rgnBuf-2      			;INTEGER
rgnMax			EQU 		rgnIndex-2    			;INTEGER
playPic   		EQU 		rgnMax-4      			;Long
qdSpare0  		EQU 		playPic-2     			;unused word
thePoly   		EQU 		qdSpare0-4    			;POLYHANDLE
polyMax   		EQU 		thePoly-2     			;INTEGER
patAlign  		EQU 		polyMax-4     			;Point
fontAdj   		EQU 		patAlign-4    			;Fixed Point
fontPtr   		EQU 		fontAdj-4     			;long, ^FMOutput record
playIndex 		EQU 		fontPtr-4     			;long
pnLocFixed		EQU			playIndex-2				;word, horizontal pen fraction			<9>
qdRunSlop		EQU 		pnLocFixed-4			;fixed point, Script Mgr run slop		<11><13>
qdChExtra		EQU 		qdRunSlop-4				;fixed point, Script Mgr char extra		<11><13>
fontData  		EQU 		qdChExtra-12			;unused words							<9><11><13>
lastGrafGlob  	EQU 		fontData
grafSize  		EQU 		4-lastGrafGlob    		;total size in bytes

; A record version of the Quickdraw globals
; It is here rather than with the complementary equates because it needs other equates
; ...(bitmapRec, grafSize, cursRec)

QDGlobals 		RECORD  	0,DECREMENT
thePort   		DS.L		1
white 			DS.B		8
black 			DS.B		8
gray  			DS.B		8
ltGray			DS.B		8
dkGray			DS.B		8
arrow 			DS.B		cursRec
screenBits		DS.B		bitmapRec
randSeed  		DS.L		1
  				ORG 		-grafSize
  				ENDR


;************** FROM HERE TO THE ENDIF IS ALL THE NEW STUFF FOR COLOR QUICKDRAW *************

hiliteBit 		EQU 		7         				; flag bit in HiliteMode (lowMem flag)

; Equates for resource ID's

defQDColors   	EQU 		127       				; resource ID of clut for default QDColors

;
; PixMap field offsets

pmBaseAddr		EQU 		$0        				; [long]
pmNewFlag 		EQU 		$4        				; [1 bit] upper bit of rowbytes is flag
pmRowBytes		EQU 		$4        				; [word]
pmBounds  		EQU 		$6        				; [rect]
pmVersion 		EQU 		$E        				; [word] pixMap version number
pmPackType		EQU 		$10       				; [word] defines packing format
pmPackSize		EQU 		$12       				; [long] size of pixel data
pmHRes			EQU 		$16       				; [fixed] h. resolution (ppi)
pmVRes			EQU 		$1A       				; [fixed] v. resolution (ppi)
pmPixelType   	EQU 		$1E       				; [word] defines pixel type
pmPixelSize   	EQU 		$20       				; [word] # bits in pixel
pmCmpCount		EQU 		$22       				; [word] # components in pixel
pmCmpSize 		EQU 		$24       				; [word] # bits per field
pmPlaneBytes  	EQU 		$26       				; [long] offset to next plane
pmTable   		EQU 		$2A       				; [long] color map
pmReserved		EQU 		$2E       				; [long] MUST BE 0
pmRec 			EQU 		$32       				; size of pixMap record

PixMap               RECORD  0
baseAddr             DS.L    1            ; Ptr: pointer to pixels
rowBytes             DS.W    1            ; short: offset to next line
bounds               DS      Rect         ;encloses bitmap
pmVersion            DS.W    1            ; short: pixMap version number
packType             DS.W    1            ; short: defines packing format
packSize             DS.L    1            ; long: length of pixel data
hRes                 DS.L    1            ; Fixed: horiz. resolution (ppi)
vRes                 DS.L    1            ; Fixed: vert. resolution (ppi)
pixelType            DS.W    1            ; short: defines pixel type
pixelSize            DS.W    1            ; short: # bits in pixel
cmpCount             DS.W    1            ; short: # components in pixel
cmpSize              DS.W    1            ; short: # bits per component
planeBytes           DS.L    1            ; long: offset to next plane
pmTable              DS.L    1            ; CTabHandle: color map for this pixMap
pmReserved           DS.L    1            ; long: for future use. MUST BE 0
size                 EQU     *
                     ENDR


; pixel types

chunky			EQU 		0
chunkyPlanar  	EQU 		1
planar			EQU 		2
RGBDirect		EQU			16

;
; pmVersion values

baseAddr32		EQU			4						; pixmap base address is 32-bit address

; PixPat field offsets
;

patType   		EQU 		$0        				; [word] type of pattern
patMap			EQU 		$2        				; [long] handle to pixmap
patData   		EQU 		$6        				; [long] handle to data
patXData  		EQU 		$A        				; [long] handle to expanded pattern data
patXValid 		EQU 		$E        				; [word] flags whether expanded pattern valid
patXMap   		EQU 		$10       				; [long] handle to expanded pattern data
pat1Data  		EQU 		$14       				; [8 bytes] old-style pattern/RGB color
ppRec 			EQU 		$1C       				; size of pixPat record


PixPat               RECORD  0
patType              DS.W    1            ; short: type of pattern
patMap               DS.L    1            ; PixMapHandle: the pattern's pixMap
patData              DS.L    1            ; Handle: pixmap's data
patXData             DS.L    1            ; Handle: expanded Pattern data
patXValid            DS.W    1            ; short: flags whether expanded Pattern valid
patXMap              DS.L    1            ; Handle: Handle to expanded Pattern data
pat1Data             DS.B    8            ; Pattern: old-Style pattern/RGB color
size                 EQU     *
                     ENDR


; Pattern types
;

oldPat			EQU 		0         				; foreground/background pattern
newPat			EQU 		1         				; self-contained color pattern
ditherPat 		EQU 		2         				; rgb value to be dithered
oldCrsrPat		EQU 		$8000     				; old-style cursor
cCrsrPat  		EQU 		$8001     				; new-style cursor


; additional offsets in a color GrafPort
;

portPixMap		EQU 		portBits      			; [long] pixelMap handle
portVersion   	EQU 		portPixMap+4      		; [word] port version number
grafVars  		EQU 		portVersion+2     		; [long] handle to more fields
chExtra   		EQU 		grafVars+4    			; [word] character extra
pnLocHFrac		EQU 		chExtra+2     			; [word] pen fraction
bkPixPat  		EQU 		bkPat     				; [long] handle to bk pattern
rgbFgColor		EQU 		bkPixPat+4    			; [6 bytes] RGB components of fg color
rgbBkColor		EQU 		rgbFgColor+6      		; [6 bytes] RGB components of bk color
pnPixPat  		EQU 		pnPat     				; [long] handle to pen's pattern
fillPixPat		EQU 		pnPixPat+4    			; [long] handle to fill pattern 

CGrafPort            RECORD  0
device               DS.W    1            ; short
portPixMap           DS.L    1            ; PixMapHandle: port's pixel map
portVersion          DS.W    1            ; short: high 2 bits always set
grafVars             DS.L    1            ; Handle: Handle to more fields
chExtra              DS.W    1            ; short: character extra
pnLocHFrac           DS.W    1            ; short: pen fraction
portRect             DS      Rect
visRgn               DS.L    1            ; RgnHandle
clipRgn              DS.L    1            ; RgnHandle
bkPixPat             DS.L    1            ; PixPatHandle: background pattern
rgbFgColor           DS      RGBColorRec  ;RGB components of fg
rgbBkColor           DS      RGBColorRec  ;RGB components of bk
pnLoc                DS      Point
pnSize               DS      Point
pnMode               DS.W    1            ; short
pnPixPat             DS.L    1            ; PixPatHandle: pen's pattern
fillPixPat           DS.L    1            ; PixPatHandle: fill pattern
pnVis                DS.W    1            ; short
txFont               DS.W    1            ; short
txFace               DS.B    1            ; Style: txFace is unpacked byte  push as short
filler               DS.B    1            ; Byte
txMode               DS.W    1            ; short
txSize               DS.W    1            ; short
spExtra              DS.L    1            ; Fixed
fgColor              DS.L    1            ; long
bkColor              DS.L    1            ; long
colrBit              DS.W    1            ; short
patStretch           DS.W    1            ; short
picSave              DS.L    1            ; Handle
rgnSave              DS.L    1            ; Handle
polySave             DS.L    1            ; Handle
grafProcs            DS.L    1            ; CQDProcsPtr
size                 EQU     *
                     ENDR



; GDevice field offsets
;

gdRefNum  		EQU 		$0        				; [word] unitNum of driver
gdID  			EQU 		$2        				; [word] client ID for search procs
gdType			EQU 		$4        				; [word] fixed/CLUT/direct
gdITable  		EQU 		$6        				; [long] handle to inverse table
gdResPref 		EQU 		$A        				; [word] preferred resolution for inverse tables
gdSearchProc  	EQU 		$C        				; [long] search proc (list?) pointer
gdCompProc		EQU 		$10       				; [long] complement proc (list?) pointer
gdFlags   		EQU 		$14       				; [word] grafDevice flags word
gdPMap			EQU 		$16       				; [long] handle to pixMap describing device
gdRefCon  		EQU 		$1A       				; [long] reference value
gdNextGD  		EQU 		$1E       				; [long] handle of next gDevice
gdRect			EQU 		$22       				; [rect] device's bounds in global coordinates
gdMode			EQU 		$2A       				; [long] device's current mode
gdCCBytes 		EQU 		$2E       				; [word] depth of expanded cursor data
gdCCDepth 		EQU 		$30       				; [word] depth of expanded cursor data
gdCCXData 		EQU 		$32       				; [long] handle to cursor's expanded data
gdCCXMask 		EQU 		$36       				; [long] handle to cursor's expanded mask
gdReserved		EQU 		$3A       				; [long] MUST BE 0
gdRec 			EQU 		$3E       				; size of GrafDevice record

GDevice              RECORD  0
gdRefNum             DS.W    1            ; short: driver's unit number
gdID                 DS.W    1            ; short: client ID for search procs
gdType               DS.W    1            ; short: fixed/CLUT/direct
gdITable             DS.L    1            ; ITabHandle: Handle to inverse lookup table
gdResPref            DS.W    1            ; short: preferred resolution of GDITable
gdSearchProc         DS.L    1            ; SProcHndl: search proc list head
gdCompProc           DS.L    1            ; CProcHndl: complement proc list
gdFlags              DS.W    1            ; short: grafDevice flags word
gdPMap               DS.L    1            ; PixMapHandle: describing pixMap
gdRefCon             DS.L    1            ; long: reference value
gdNextGD             DS.L    1            ; GDHandle: GDHandle Handle of next gDevice
gdRect               DS      Rect         ; device's bounds in global coordinates
gdMode               DS.L    1            ; long: device's current mode
gdCCBytes            DS.W    1            ; short: depth of expanded cursor data
gdCCDepth            DS.W    1            ; short: depth of expanded cursor data
gdCCXData            DS.L    1            ; Handle: Handle to cursor's expanded data
gdCCXMask            DS.L    1            ; Handle: Handle to cursor's expanded mask
gdReserved           DS.L    1            ; long: future use. MUST BE 0
size                 EQU     *
                     ENDR


; VALUES FOR GDType

clutType  		EQU 		0         				; 0 if lookup table
fixedType 		EQU 		1         				; 1 if fixed table
directType		EQU 		2         				; 2 if direct values

; BIT ASSIGNMENTS FOR GDFlags

gdDevType 		EQU 		0         				; 0 = monochrome; 1 = color
hasAuxMenuBar	EQU			06						; 1 if device has an Aux menu bar on it
BurstDevice		EQU			07						; 1 if this device support burst xfer
ext32Device		EQU			08						; 1 if this device must be accessed in 32-bit mode
frozenDevice	EQU			09						; reserved for future use
ramInit   		EQU 		10        				; 1 if initialized from 'scrn' resource
mainScreen		EQU 		11        				; 1 if main screen
allInit   		EQU 		12        				; 1 if all devices initialized
screenDevice  	EQU 		13        				; 1 if screen device [not used]
noDriver  		EQU 		14        				; 1 if no driver for this GDevice
screenActive  	EQU 		15        				; 1 if in use

; CCrsr (Color Cursor) field offsets
;
; NOTE THAT THE FIRST FOUR FIELDS ARE PARALLEL TO THE FIRST FOUR FIELDS
; OF A PATTERN SO THAT PATCONVERT CAN BE USED TO EXPAND A CURSOR
;

crsrType  		EQU 		0         				;[WORD] CURSOR TYPE
crsrMap   		EQU 		crsrType+2    			;[LONG] HANDLE TO CURSOR'S PIXMAP
crsrData  		EQU 		crsrMap+4     			;[LONG] HANDLE TO CURSOR'S COLOR DATA
crsrXData 		EQU 		crsrData+4    			;[LONG] HANDLE TO EXPANDED DATA
crsrXValid		EQU 		crsrXData+4       		;[WORD] DEPTH OF EXPANDED DATA (0 IF NONE)
crsrXHandle   	EQU 		crsrXValid+2      		;[LONG] HANDLE FOR FUTURE USE
crsr1Data 		EQU 		crsrXHandle+4     		;[16 WORDS] ONE-BIT DATA
crsrMask  		EQU 		crsr1Data+32      		;[16 WORDS] ONE-BIT MASK
crsrHotSpot   	EQU 		crsrMask+32       		;[POINT] HOT-SPOT FOR CURSOR
crsrXTable		EQU 		crsrHotSpot+4     		;[LONG] TABLE ID FOR EXPANDED DATA
crsrID			EQU 		crsrXTable+4      		;[LONG] ID FOR CURSOR
crsrRec   		EQU 		crsrID+4      			;SIZE OF CURSOR SAVE AREA

CCrsr                RECORD  0
crsrType             DS.W    1            ; short: type of cursor
crsrMap              DS.L    1            ; PixMapHandle: the cursor's pixmap
crsrData             DS.L    1            ; Handle: cursor's data
crsrXData            DS.L    1            ; Handle: expanded cursor data
crsrXValid           DS.W    1            ; short: depth of expanded data (0 if none)
crsrXHandle          DS.L    1            ; Handle: future use
crsr1Data            DS.B    32           ; Bits16: one-bit cursor
crsrMask             DS.B    32           ; Bits16: cursor's mask
crsrHotSpot          DS      Point        ;cursor's hotspot
crsrXTable           DS.L    1            ; long: private
crsrID               DS.L    1            ; long: private
size                 EQU     *
                     ENDR



; CIcon (Color Icon) field offsets
;

iconPMap  		EQU 		0         				;[PIXMAP] ICON'S PIXMAP
iconMask  		EQU 		iconPMap+pmRec    		;[BITMAP] 1-BIT VERSION OF ICON ONE-BIT MASK FOR ICON
iconBMap  		EQU 		iconMask+bitmapRec    	;[BITMAP] 1-BIT VERSION OF ICON
iconData  		EQU 		iconBMap+bitmapRec    	;[LONG] HANDLE TO PIXMAP DATA
;FOLLOWED BY BMAP AND MASK DATA
iconRec   		EQU 		iconData+4    			;SIZE OF ICON HEADER

CIcon                RECORD  0
iconPMap             DS      PixMap       ;the icon's pixMap
iconMask             DS      BitMapRecord ;the icon's mask
iconBMap             DS      BitMapRecord ;the icon's bitMap
iconData             DS.L    1            ; Handle: the icon's data
iconMaskData         DS.W    1            ; Array of short: icon's mask and BitMap data
size                 EQU     *
                     ENDR


;
; Gamma Table format
;
gVersion  		EQU 		0         				; [word] gamma version number
gType 			EQU 		gVersion+2    			; [word] gamma data type
gFormulaSize  	EQU 		gType+2       			; [word] Formula data size
gChanCnt  		EQU 		gFormulaSize+2    		; [word] number of channels of data
gDataCnt  		EQU 		gChanCnt+2    			; [word] number of values/channel
gDataWidth		EQU 		gDataCnt+2    			; [word] bits/corrected value (data packed to next larger byte size)
gFormulaData  	EQU 		gDataWidth+2      		; [array] data for formulas, followed by gamma values


GammaTbl             RECORD  0
gVersion             DS.W    1            ; short: gamma version number
gType                DS.W    1            ; short: gamma data type
gFormulaSize         DS.W    1            ; short: Formula data size
gChanCnt             DS.W    1            ; short: number of channels of data
gDataCnt             DS.W    1            ; short: number of values/channel
gDataWidth           DS.W    1            ; short: bits/corrected value (data packed to next larger byte size)
gFormulaData         DS.W    1            ; Array of short: data for formulas followed by gamma values
size                 EQU     *
                     ENDR


; EXTENSIONS TO THE QDPROCS RECORD
;

opcodeProc		EQU 		$34       				; [pointer]
newProc1  		EQU 		$38       				; [pointer]
newProc2  		EQU 		$3C       				; [pointer]
newProc3  		EQU 		$40       				; [pointer]
newProc4  		EQU 		$44       				; [pointer]
newProc5  		EQU 		$48       				; [pointer]
newProc6  		EQU 		$4C       				; [pointer]
cqdProcsRec   	EQU 		$50       				; size of QDProcs record

; OFFSETS WITHIN GRAFVARS:
;
rgbOpColor		EQU 		0         				; [6 bytes] color for addPin, subPin and average
rgbHiliteColor	EQU 		rgbOpColor+6      		; [6 bytes] color for hiliting
pmFgColor 		EQU 		rgbHiliteColor+6  		; [4 bytes] palette handle for foreground color
pmFgIndex 		EQU 		pmFgColor+4       		; [2 bytes] index value for foreground
pmBkColor 		EQU 		pmFgIndex+2       		; [4 bytes] palette handle for background color
pmBkIndex 		EQU 		pmBkColor+4       		; [2 bytes] index value for background
pmFlags   		EQU 		pmBkIndex+2       		; [2 bytes] flags for Palette Manager
grafVarRec		EQU 		pmFlags+2     			; size of grafVar record

GrafVarsRec          RECORD  0
rgbOpColor           DS      RGBColorRec  ;color for addPin  subPin and average
rgbHiliteColor       DS      RGBColorRec  ;color for hiliting
pmFgColor            DS.L    1            ; Handle: palette Handle for foreground color
pmFgIndex            DS.W    1            ; short: index value for foreground
pmBkColor            DS.L    1            ; Handle: palette Handle for background color
pmBkIndex            DS.W    1            ; short: index value for background
pmFlags              DS.W    1            ; short: flags for Palette Manager
size                 EQU     *
                     ENDR


; ColorTable field offsets

ctSeed			EQU 		0         				; [long] id number for table
transIndex		EQU 		ctSeed+4  				; [word] index of transparent pixel (obsolete)
ctFlags   		EQU 		ctSeed+4      			; [word] hibh bit: 0 = PixMap; 1 = device
ctSize			EQU 		ctFlags+2     			; [word] number of entries in CTTable
ctTable   		EQU 		ctSize+2      			; [variant] array of color spec
ctRec 			EQU 		ctTable       			; size of record without color table
ctEntrySize   	EQU 		8         				; size of each entry in table
minSeed   		EQU 		1023      				; minimum seed value (< minSeed reserved for rsrc ID's)
protectBit		EQU 		7         				; protect bit in device color table
reserveBit		EQU 		6         				; reserve bit in device color table
invalColReq   	EQU 		-1        				; invalid color table request

ColorTable           RECORD  0
ctSeed               DS.L    1            ; long: unique identifier for table
ctFlags              DS.W    1            ; short: high bit: 0 = PixMap; 1 = device
ctSize               DS.W    1            ; short: number of entries in CTTable
ctTable              DS.B    8            ; CSpecArray: array [0..0] of ColorSpec
size                 EQU     *
                     ENDR


; CProcRec structure

nxtComp   		EQU 		$0        				;link to next proc [pointer]
compProc  		EQU 		$4        				;pointer to routine [pointer]
cProcSize 		EQU 		8         				; size of CProcRec

CProcRec             RECORD  0
nxtComp              DS.L    1            ; CProcHndl: CProcHndl Handle to next CProcRec
compProc             DS.L    1            ; ColorComplementProcPtr: pointer to complement procedure
size                 EQU     *
                     ENDR


; SProcRec structure

nxtSrch   		EQU 		$0        				;[pointer] link to next proc
srchproc  		EQU 		$4        				;[pointer] pointer to routine
sProcSize 		EQU 		8         				; size of SProcRec

SProcRec             RECORD  0
nxtSrch              DS.L    1            ; Handle: SProcHndl Handle to next SProcRec
srchProc             DS.L    1            ; ColorSearchProcPtr: pointer to search procedure
size                 EQU     *
                     ENDR


; request List structure

reqLSize  		EQU 		0         				; request list size [word]
reqLData  		EQU 		2         				; request list data [words]


ReqListRec           RECORD  0
reqLSize             DS.W    1            ; short: request list size
reqLData             DS.W    1            ; Array of short: request list data
size                 EQU     *
                     ENDR


	ENDIF	; ...already included 