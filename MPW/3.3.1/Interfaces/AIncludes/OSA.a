;////////////////////////////////////////////////////////////////////////////////
;// OPEN SCRIPTING ARCHITECTURE: Client Interface
;////////////////////////////////////////////////////////////////////////////////
;// Copyright Â© 1992-1994 Apple Computer, Inc. All rights reserved.
;// Authors: Jens Alfke, William Cook, Donn Denman, and Warren Harris
;////////////////////////////////////////////////////////////////////////////////
;// This interface defines what it means to be a "scripting component."
;// Scripting components allow "scripts" to be loaded and executed.  This
;// interface does not define the way in which a particular scripting
;// component's scripts are editing and debugged.
;////////////////////////////////////////////////////////////////////////////////

 IF &TYPE('__INCLUDINGOSA__') = 'UNDEFINED' THEN
__INCLUDINGOSA__ SET 1

 IF &TYPE('__INCLUDINGAPPLEEVENTS__') = 'UNDEFINED' THEN
 INCLUDE 'AppleEvents.a'
 ENDIF

 IF &TYPE('__INCLUDINGCOMPONENTS__') = 'UNDEFINED' THEN
 INCLUDE 'Components.a'
 ENDIF

;//////// Conditional Compilation

;////////////////////////////////////////////////////////////////////////////////
;// Types and Constants
;////////////////////////////////////////////////////////////////////////////////

kOSAComponentType	EQU	'osa '
;	// The componenent manager type code for components that
;	// support the OSA interface defined here.

kOSAGenericScriptingComponentSubtype EQU	'scpt'

kOSANullScript		EQU	0		
;	// No-script constant. 

kOSANullMode		EQU	0	; sounds better
kOSAModeNull		EQU	0	; tastes consistent
;	// Some routines take flags that control their execution.  This constant
;	// declares default mode settings are used.

kOSASuite		EQU	'ascr'
kOSARecordedText	EQU	'recd'
;	// Suite and event code of the RecordedText event. (See OSAStartRecording,
;	// below.)

;////////////////////////////////////////////////////////////////////////////////
;// API Errors
;////////////////////////////////////////////////////////////////////////////////

errOSASystemError	EQU	-1750
errOSAInvalidID		EQU	-1751
errOSABadStorageType	EQU	-1752
errOSAScriptError	EQU	-1753
errOSABadSelector	EQU	-1754
errOSASourceNotAvailable	EQU	-1756
errOSANoSuchDialect	EQU	-1757
errOSADataFormatObsolete	EQU	-1758
errOSADataFormatTooNew	EQU	-1759
errOSACorruptData	EQU	errAECorruptData
errOSARecordingIsAlreadyOn	EQU	errAERecordingIsAlreadyOn

;////////////////////////////////////////////////////////////////////////////////
;// Standard Script Errors
;////////////////////////////////////////////////////////////////////////////////
;// It is recommended that scripting components use the following set of error
;// codes to signal failure when applicable.  This enables applications that
;// use the OSA API to deal with some class of script errors in a less than 
;// ad hoc manner.  Scripting components are of course encouraged to return
;// component-specific errors when these don't apply.
;////////////////////////////////////////////////////////////////////////////////

;//////// Dynamic errors:
;//
;// These errors result from data-dependent conditions and are typically
;// signaled at runtime.

errOSACantCoerce	EQU	errAECoercionFail
;	// Signaled when a value can't be coerced to the desired type. Similar
;	// to errOSATypeError except results from coercion.

errOSACantAccess	EQU	-1728
;	// Signaled when an object is not found in a container.

errOSACantAssign	EQU	-10006
;	// Signaled when an object cannot be set in a container.  Same as 
;	// AERegistry error errAEWriteDenied.

errOSAGeneralError	EQU	-2700
;	// Signaled by user scripts or applications when no actual error code
;	// is to be returned.  Simply means "an error has occurred".  Most useful
;	// in conjunction with an error message from the application.

errOSADivideByZero	EQU	-2701
;	// Signaled when there is an attempt to divide by zero.

errOSANumericOverflow	EQU	-2702
;	// Signaled when integer or real value is too large to be represented.

errOSACantLaunch	EQU	-2703
;	// Signaled when application can't be launched or when it is remote and
;	// program linking is not enabled.

errOSAAppNotHighLevelEventAware	EQU	-2704
;	// Signaled when an application can't respond to AppleEvents.

errOSACorruptTerminology	EQU	-2705
;	// Signaled when an application's terminology resource is not readable.

errOSAStackOverflow	EQU	-2706
;	// Signaled when the runtime stack overflows.

errOSAInternalTableOverflow	EQU	-2707
;	// Signaled when a runtime internal data structure overflows.

errOSADataBlockTooLarge	EQU	-2708
;	// Signaled when an intrinsic limitation is exceeded for the size of 
;	// a value or data structure.

errOSACantGetTerminology	EQU	-2709
;	// Signaled when we couldn't terminology even though it was there.

errOSACantCreate			EQU	-2710
;	//

;//////// Component-specific dynamic script errors:
;//
;// The range -2720 thru -2739 is reserved for component-specific runtime errors.
;// (Note that error codes from different scripting components in this range will
;// overlap.)

;//////// Static errors:
;//
;// These errors comprise what are commonly thought of as parse and compile-
;// time errors.  However, in a dynamic system (e.g. AppleScript) any or all
;// of these may also occur at runtime.

errOSATypeError	EQU	errAEWrongDataType
;	// Signaled when data was not the right type and coercion is not allowed.

errOSAMessageNotUnderstood	EQU	errAEEventNotHandled
;	// Signaled when a message was sent to an object that didn't handle it.

errOSAUndefinedHandler	EQU	errAEHandlerNotFound
;	// Signaled when a function to be returned doesn't exist.  (Probably only
;	// useful in languages with first-class functions that distinguish between
;	// functions and other values (two name spaces). This is different from
;	// errOSAMessageNotUnderstood, which may be signaled when the method is
;	// invoked.

errOSAIllegalAccess	EQU	-1723
;	// Signaled when a container can never have the requested object.

errOSAIllegalIndex	EQU	errAEIllegalIndex
;	// Signaled when index was out of range. Specialization of errOSACantAccess.

errOSAIllegalRange	EQU	-1720
;	// Signaled when a range is screwy. Specialization of errOSACantAccess.

errOSAIllegalAssign	EQU	-10003
;	// Signaled when an object can never be set in a container.  Same as 
;	// AERegistry error errAENotModifiable.

errOSASyntaxError	EQU	-2740
;	// Signaled when a syntax error occurs. (e.g. "Syntax error" or
;	// "<this> can't go after <that>").

errOSASyntaxTypeError	EQU	-2741
;	// Signaled when another form of syntax was expected. (e.g. "expected
;	// a <type> but found <this>").

errOSATokenTooLong	EQU	-2742
;	// Signaled when a name or number is too long to be parsed.

errOSAMissingParameter	EQU	errAEDescNotFound
;	// Signaled when a parameter is missing for a function invocation.  Note
;	// that in some languages, this error may occur at runtime.

errOSAParameterMismatch	EQU	-1721
;	// Signaled when function is called with the wrong number of parameters,
;	// or a parameter pattern cannot be matched.

errOSADuplicateParameter	EQU	-2750
;	// Signaled when a formal parameter, local variable, or instance variable
;	// is specified more than once.

errOSADuplicateProperty	EQU	-2751
;	// Signaled when a formal parameter, local variable, or instance variable
;	// is specified more than once.

errOSADuplicateHandler	EQU	-2752
;	// Signaled when more than one handler is defined with the same name in 
;	// a scope where the language doesn't allow it.

errOSAUndefinedVariable	EQU	-2753
;	// Signaled when a variable is accessed that has no value.

errOSAInconsistentDeclarations	EQU	-2754
;	// Signaled when a variable is declared inconsistently in the same scope,
;	// such as both local and global.

errOSAControlFlowError	EQU	-2755
;	// Signaled when illegal control flow occurs in an application (no catcher
;	// for throw, non-lexical loop exit, etc.).

;//////// Component-specific static script errors:
;//
;// The range -2760 thru -2779 is reserved for component-specific parsing and
;// compile-time errors. (Note that error codes from different scripting
;// components in this range will overlap.)

;//////// Dialect-specific script errors:
;//
;// The range -2780 thru -2799 is reserved for dialect specific error codes for
;// scripting components that support dialects. (Note that error codes from
;// different scripting components in this range will overlap, as well as error
;// codes from different dialects in the same scripting component.)

;////////////////////////////////////////////////////////////////////////////////
;// OSA Interface Descriptions
;////////////////////////////////////////////////////////////////////////////////
;// The OSA Interface is broken down into a required interface, and several
;// optional interfaces to support additional functionality.  A given scripting
;// component may choose to support only some of the optional interfaces in
;// addition to the basic interface.  The OSA Component Flags may be used to 
;// query the Component Manager to find a scripting component with a particular
;// capability, or determine if a particular scripting component supports a 
;// particular capability.
;////////////////////////////////////////////////////////////////////////////////

;//////// OSA Component Flags:

kOSASupportsCompiling	EQU	$0002
kOSASupportsGetSource	EQU	$0004
kOSASupportsAECoercion	EQU	$0008
kOSASupportsAESending	EQU	$0010
kOSASupportsRecording	EQU	$0020
kOSASupportsConvenience	EQU	$0040
kOSASupportsDialects	EQU	$0080
kOSASupportsEventHandling	EQU	$0100

;//////// Component Selectors:

;// Basic Scripting:
kOSASelectLoad		EQU	$0001
kOSASelectStore		EQU	$0002
kOSASelectExecute	EQU	$0003
kOSASelectDisplay	EQU	$0004
kOSASelectScriptError	EQU	$0005
kOSASelectDispose	EQU	$0006
kOSASelectSetScriptInfo	EQU	$0007
kOSASelectGetScriptInfo	EQU	$0008
kOSASelectSetActiveProc	EQU	$0009
kOSASelectGetActiveProc	EQU	$000A
;// Compiling:
kOSASelectScriptingComponentName EQU	$0102
kOSASelectCompile	EQU	$0103
kOSASelectCopyID	EQU	$0104
;// GetSource:
kOSASelectGetSource	EQU	$0201
;// AECoercion:
kOSASelectCoerceFromDesc	EQU	$0301
kOSASelectCoerceToDesc	EQU	$0302
;// AESending:
kOSASelectSetSendProc	EQU	$0401
kOSASelectGetSendProc	EQU	$0402
kOSASelectSetCreateProc	EQU	$0403
kOSASelectGetCreateProc	EQU	$0404
kOSASelectSetDefaultTarget	EQU	$0405
;// Recording:
kOSASelectStartRecording	EQU	$0501
kOSASelectStopRecording	EQU	$0502
;// Convenience:
kOSASelectLoadExecute	EQU	$0601
kOSASelectCompileExecute	EQU	$0602
kOSASelectDoScript	EQU	$0603
;// Dialects:
kOSASelectSetCurrentDialect	EQU	$0701
kOSASelectGetCurrentDialect	EQU	$0702
kOSASelectAvailableDialects	EQU	$0703
kOSASelectGetDialectInfo	EQU	$0704
kOSASelectAvailableDialectCodeList EQU	$0705
;// Event Handling:
kOSASelectSetResumeDispatchProc	EQU	$0801
kOSASelectGetResumeDispatchProc	EQU	$0802
kOSASelectExecuteEvent	EQU	$0803
kOSASelectDoEvent	EQU	$0804
kOSASelectMakeContext	EQU	$0805

kOSASelectComponentSpecificStart EQU	$1001
;	// scripting component specific selectors are added beginning with this
;	// value

;//////// Mode Flags:
;//
;// Warning: These should not conflict with the AESend mode flags in
;// AppleEvents.h, because we may want to use them as OSA mode flags too.

kOSAModePreventGetSource	EQU	$00000001
;	// This mode flag may be passed to OSALoad, OSAStore or OSACompile to
;	// instruct the scripting component to not retain the "source" of an
;	// expression.  This will cause the OSAGetSource call to return the error
;	// errOSASourceNotAvailable if used.  However, some scripting components
;	// may not retain the source anyway.  This is mainly used when either space
;	// efficiency is desired, or a script is to be "locked" so that its
;	// implementation may not be viewed.

kOSAModeNeverInteract	EQU	kAENeverInteract
kOSAModeCanInteract	EQU	kAECanInteract
kOSAModeAlwaysInteract	EQU	kAEAlwaysInteract
kOSAModeDontReconnect	EQU	kAEDontReconnect
;	// These mode flags may be passed to OSACompile, OSAExecute, OSALoadExecute
;	// OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to
;	// indicate whether or not the script may interact with the user, switch
;	// layer or reconnect if necessary.  Any AppleEvents will be sent with the
;	// corresponding AESend mode supplied.

kOSAModeCantSwitchLayer	EQU	$00000040
;	// This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute
;	// OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to
;	// indicate whether or not AppleEvents should be sent with the
;	// kAECanSwitchLayer mode flag sent or not. NOTE: This flag is exactly the
;	// opposite sense of the AppleEvent flag kAECanSwitchLayer.  This is to
;	// provide a more convenient default, i.e. not supplying any mode
;	// (kOSAModeNull) means to send events with kAECanSwitchLayer.  Supplying
;	// the kOSAModeCantSwitchLayer mode flag will cause AESend to be called
;	// without kAECanSwitchLayer.

kOSAModeDoRecord	EQU	$00001000
;	// This mode flag may be passed to OSACompile, OSAExecute, OSALoadExecute
;	// OSACompileExecute, OSADoScript, OSAExecuteEvent, or OSADoEvent to
;	// indicate whether or not AppleEvents should be sent with the kAEDontRecord
;	// mode flag sent or not. NOTE: This flag is exactly the opposite sense of
;	// the AppleEvent flag kAEDontRecord.  This is to provide a more convenient
;	// default, i.e. not supplying any mode (kOSAModeNull) means to send events
;	// with kAEDontRecord.  Supplying the kOSAModeDoRecord mode flag will 
;	// cause AESend to be called without kAEDontRecord.

kOSAModeCompileIntoContext	EQU	$00000002
;	// This is a mode flag for OSACompile that indicates that a context should
;	// be created as the result of compilation. All handler definitions are
;	// inserted into the new context, and variables are initialized by
;	// evaluating their initial values in a null context (i.e. they must be
;	// constant expressions).

kOSAModeAugmentContext	EQU	$00000004
;	// This is a mode flag for OSACompile that indicates that the previous
;	// script ID (input to OSACompile) should be augmented with any new
;	// definitions in the sourceData rather than replaced with a new script.
;	// This means that the previous script ID must designate a context.
;	// The presence of this flag causes the kOSAModeCompileIntoContext flag
;	// to be implicitly used, causing any new definitions to be initialized
;	// in a null context.

kOSAModeDisplayForHumans	EQU	$00000008
;	// This mode flag may be passed to OSADisplay or OSADoScript to indicate
;	// that output only need be human-readable, not re-compilable by OSACompile.
;	// If used, output may be arbitrarily "beautified", e.g. quotes may be left
;	// off of string values, long lists may have elipses, etc.

kOSAModeDontStoreParent	EQU	$00004000
;	// This mode flag may be passed to OSAStore in the case where the scriptID
;	// is a context.  This causes the context to be saved, but not the context's
;	// parent context.  When the stored context is loaded back in, the parent
;	// will be kOSANullScript.

kOSAModeDispatchToDirectObject	EQU $00020000
;	// This mode flag may be passed to OSAExecuteEvent to cause the event to
;	// be dispatched to the direct object of the event. The direct object (or
;	// subject attribute if the direct object is a non-object specifier) will
;	// be resolved, and the resulting script object will be the recipient of
;	// the message. The context argument to OSAExecuteEvent will serve as the
;	// root of the lookup/resolution process.
kOSAModeDontGetDataForArguments	EQU	$00040000
;	// This mode flag may be passed to OSAExecuteEvent to indicate that
;	// components do not have to get the data of object specifier arguments.

;////////////////////////////////////////////////////////////////////////////////
;// OSA Basic Scripting Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components must at least support the Basic Scripting interface.
;////////////////////////////////////////////////////////////////////////////////

;//////// Loading and Storing Scripts:
;//
;// These routines allow scripts to be loaded and stored in their internal
;// (possibly compiled, non-text) representation.

kOSAScriptResourceType	EQU	kOSAGenericScriptingComponentSubtype
;	// Resource type for scripts.
	
typeOSAGenericStorage	EQU	kOSAScriptResourceType
;	// Default type given to OSAStore which creates "generic" loadable script
;	// data descriptors.

;pascal OSAError
;OSALoad(ComponentInstance	scriptingComponent,
;        const AEDesc*	scriptData,
;        long		modeFlags,
;        OSAID*		resultingScriptID);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSABadStorageType:	scriptData not for this scripting component
;	// 	errOSACorruptData:	data seems to be corrupt
;	// 	errOSADataFormatObsolete	script data format is no longer supported
;	// 	errOSADataFormatTooNew	script data format is from a newer version
;	// 
;	// ModeFlags:
;	//	kOSAModePreventGetSource

		MACRO
		_OSALoad
		MOVE.L	#((12<<16)|kOSASelectLoad),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAStore(ComponentInstance	scriptingComponent, 
;         OSAID		scriptID, 
;         DescType	desiredType,
;         long		modeFlags,
;         AEDesc*	resultingScriptData);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	// 	errOSABadStorageType:	desiredType not for this scripting component
;	// 
;	// ModeFlags:
;	//	kOSAModePreventGetSource
;	//	kOSAModeDontStoreParent

		MACRO
		_OSAStore
		MOVE.L	#((16<<16)|kOSASelectStore),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;//////// Executing Scripts:

;pascal OSAError
;OSAExecute(ComponentInstance	scriptingComponent,
;           OSAID	compiledScriptID,
;           OSAID	contextID,
;           long	modeFlags,
;           OSAID*	resultingScriptValueID);
;	// This call runs a script.  The contextID represents the environment
;	// with which global variables in the script are resolved.  The constant
;	// kOSANullScript may be used for the contextID if the application wishes
;	// to not deal with context directly (a default one is associated with each
;	// scripting component instance).  The resultingScriptValueID is the 
;	// result of evaluation, and contains a value which may be displayed using
;	// the OSAGetSource call.  The modeFlags convey scripting component
;	// specific information.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	// 	errOSAScriptError:	the executing script got an error
;	//
;	// ModeFlags:
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSAExecute
		MOVE.L	#((16<<16)|kOSASelectExecute),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;//////// Displaying results:

;pascal OSAError
;OSADisplay(ComponentInstance	scriptingComponent,
;           OSAID	scriptValueID,
;           DescType	desiredType,
;           long	modeFlags,
;           AEDesc*	resultingText);
;	// This call is used to convert results (script value IDs) into displayable
;	// text. The desiredType should be at least typeChar, and modeFlags are
;	// scripting system specific flags to control the formatting of the
;	// resulting text. This call differs from OSAGetSource in that (1) it
;	// always produces at least typeChar, (2) is only works on script values,
;	// (3) it may display it's output in non-compilable form (e.g. without
;	// string quotes, elipses inserted in long and/or circular lists, etc.) and
;	// (4) it is required by the basic scripting interface.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	// 	errAECoercionFail:	desiredType not supported by scripting component
;	//
;	// ModeFlags:
;	//	kOSAModeDisplayForHumans

		MACRO
		_OSADisplay
		MOVE.L	#((16<<16)|kOSASelectDisplay),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;//////// Getting Error Information:

;pascal OSAError
;OSAScriptError(ComponentInstance	scriptingComponent,
;	OSType		selector,
;	DescType		desiredType,
;	AEDesc*		resultingErrorDescription);
;	// Whenever script execution returns errOSAExecutionError, this routine
;	// may be used to get information about that error.  The selector describes
;	// the type of information desired about the error (various selectors are
;	// listed below).  The desiredType indicates the data type of the result
;	// desired for that selector.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	//	errOSABadSelector:	selector not supported by scripting component
;	// 	errAECoercionFail:	desiredType not supported by scripting component

		MACRO
		_OSAScriptError
		MOVE.L	#((12<<16)|kOSASelectScriptError),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;// OSAScriptError selectors:

kOSAErrorNumber		EQU	keyErrorNumber
;	// This selector is used to determine the error number of a script error.
;	// These error numbers may be either system error numbers, or error numbers
;	// that are scripting component specific.
;	// Required desiredTypes:
;	//	typeShortInteger

kOSAErrorMessage	EQU	keyErrorString
;	// This selector is used to determine the full error message associated
;	// with the error number.  It should include the name of the application
;	// which caused the error, as well as the specific error that occurred.
;	// This selector is sufficient for simple error reporting (but see
;	// kOSAErrorBriefMessage, below).
;	// Required desiredTypes:
;	//	typeChar					error message string

kOSAErrorBriefMessage	EQU	'errb'
;	// This selector is used to determine a brief error message associated with
;	// the error number.  This message and should not mention the name of the
;	// application which caused the error, any partial results or offending
;	// object (see kOSAErrorApp, kOSAErrorPartialResult and
;	// kOSAErrorOffendingObject, below).
;	// Required desiredTypes:
;	//	typeChar					brief error message string

kOSAErrorApp		EQU	'erap'
;	// This selector is used to determine which application actually got the
;	// error (if it was the result of an AESend), or the current application
;	// if ....
;	// Required desiredTypes:
;	//	typeProcessSerialNumber		PSN of the errant application
;	//	typeChar					name of the errant application

kOSAErrorPartialResult	EQU	'ptlr'
;	// This selector is used to determine any partial result returned by an 
;	// operation. If an AESend call failed, but a partial result was returned,
;	// then the partial result may be returned as an AEDesc.
;	// Required desiredTypes:
;	//	typeBest					AEDesc of any partial result

kOSAErrorOffendingObject	EQU	'erob'
;	// This selector is used to determine any object which caused the error
;	// that may have been indicated by an application.  The result is an 
;	// AEDesc.
;	// Required desiredTypes:
;	//	typeBest					AEDesc of any offending object
	
kOSAErrorExpectedType	EQU	'errt'
;	// This selector is used to determine the type expected by a coercion 
;	// operation if a type error occurred. 

kOSAErrorRange	EQU	'erng'
;	// This selector is used to determine the source text range (start and 
;	// end positions) of where the error occurred.
;	// Required desiredTypes:
;	//	typeOSAErrorRange

typeOSAErrorRange	EQU	'erng'
;	// An AERecord type containing keyOSASourceStart and keyOSASourceEnd fields
;	// of type short.
keyOSASourceStart	EQU	'srcs'
;	// Field of a typeOSAErrorRange record of typeShortInteger.
keyOSASourceEnd		EQU	'srce'
;	// Field of a typeOSAErrorRange record of typeShortInteger.

;//////// Disposing Script IDs:

;pascal OSAError
;OSADispose(ComponentInstance	scriptingComponent,
;           OSAID	scriptID);
;	// Disposes a script or context.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID

		MACRO
		_OSADispose
		MOVE.L	#((4<<16)|kOSASelectDispose),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;//////// Getting and Setting Script Information:

;pascal OSAError
;OSASetScriptInfo(ComponentInstance	scriptingComponent,
;	  OSAID		scriptID,
;	  OSType		selector,
;	  long		value);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	//	errOSABadSelector:	selector not supported by scripting component
;	// 							or selector not for this scriptID

		MACRO
		_OSASetScriptInfo
		MOVE.L	#((12<<16)|kOSASelectSetScriptInfo),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAGetScriptInfo(ComponentInstance	scriptingComponent,
;	  OSAID		scriptID,
;	  OSType		selector,
;	  long*		result);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	//	errOSABadSelector:	selector not supported by scripting component
;	// 							or selector not for this scriptID

		MACRO
		_OSAGetScriptInfo
		MOVE.L	#((12<<16)|kOSASelectGetScriptInfo),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

kOSAScriptIsModified	EQU	'modi'
;	// Selector returns boolean.

kOSAScriptIsTypeCompiledScript	EQU	'cscr'
;	// Selector returns boolean.
	
kOSAScriptIsTypeScriptValue	EQU	'valu'
;	// Selector returns boolean.

kOSAScriptIsTypeScriptContext	EQU	'cntx'
;	// Selector returns boolean.

kOSAScriptBestType	EQU	'best'
;	// Selector returns a DescType which may be passed to OSACoerceToDesc.

kOSACanGetSource	EQU	'gsrc'
;	// This selector is used to determine whether a script has source 
;	// associated with it that when given to OSAGetSource, the call will not
;	// fail.  The selector returns a boolean.

;//////// Manipulating the ActiveProc:
;//
;// Scripting systems will supply default values for these procedures if they
;// are not set by the client:

;pascal OSAError
;OSASetActiveProc(ComponentInstance	scriptingComponent,
;	  OSAActiveProcPtr	activeProc,
;	  long		refCon);
;	// If activeProc is nil, the default activeProc is used.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSASetActiveProc
		MOVE.L	#((8<<16)|kOSASelectSetActiveProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAGetActiveProc(ComponentInstance	scriptingComponent,
;	  OSAActiveProcPtr*	activeProc,
;	  long*		refCon);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAGetActiveProc
		MOVE.L	#((8<<16)|kOSASelectGetActiveProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional Compiling Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the Compiling interface have the 
;// kOSASupportsCompiling bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;pascal OSAError
;OSAScriptingComponentName(ComponentInstance	scriptingComponent,
;	           AEDesc*	resultingScriptingComponentName);
;	// Given a scripting component, this routine returns the name of that
;	// scripting component in a type that is coercable to text (typeChar).
;	// The generic scripting component returns the name of the default
;	// scripting component.  This name should be sufficient to convey to the
;	// user the kind of script (syntax) he is expected to write.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAScriptingComponentName
		MOVE.L	#((4<<16)|kOSASelectScriptingComponentName),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSACompile(ComponentInstance	scriptingComponent,
;           const AEDesc*	sourceData,
;           long	modeFlags,
;           OSAID*	previousAndResultingScriptID);
;	// Coerces input desc (possibly text) into a script's internal format.
;	// Once compiled, the script is ready to run.  The modeFlags convey
;	// scripting component specific information.  The previous script ID
;	// (result parameter) is made to refer to the newly compiled script,
;	// unless it was originally kOSANullScript.  In this case a new script
;	// ID is created and used.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	//	errAECoercionFail:		sourceData is not compilable
;	// 	errOSAScriptError:		sourceData was a bad script (syntax error)
;	// 	errOSAInvalidID:		previousAndResultingCompiledScriptID was not
;	//							valid on input
;	//
;	// ModeFlags:
;	//	kOSAModePreventGetSource
;	//	kOSAModeCompileIntoContext
;	//	kOSAModeAugmentContext
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSACompile
		MOVE.L	#((12<<16)|kOSASelectCompile),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSACopyID(ComponentInstance	scriptingComponent,
;          OSAID	fromID,
;          OSAID*	toID);
;	// If toID is a reference to kOSANullScript then it is updated to have a
;	// new scriptID value.  This call can be used to perform undo or revert
;	// operations on scripts. 
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID

		MACRO
		_OSACopyID
		MOVE.L	#((8<<16)|kOSASelectCopyID),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional GetSource Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the GetSource interface have the 
;// kOSASupportsGetSource bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;pascal OSAError
;OSAGetSource(ComponentInstance	scriptingComponent,
;             OSAID	scriptID,
;             DescType	desiredType,
;             AEDesc*	resultingSourceData);
;	// This routine causes a compiled script to be output in a form (possibly
;	// text) such that it is suitable to be passed back to OSACompile.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	//	errOSASourceNotAvailable	can't get source for this scriptID

		MACRO
		_OSAGetSource
		MOVE.L	#((12<<16)|kOSASelectGetSource),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional AECoercion Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the AECoercion interface have the 
;// kOSASupportsAECoercion bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;pascal OSAError
;OSACoerceFromDesc(ComponentInstance	scriptingComponent,
;	   const AEDesc*	scriptData,
;	   long		modeFlags,
;	   OSAID*		resultingScriptID);
;	// This routine causes script data to be coerced into a script value.
;	// If the scriptData is an AppleEvent, then the resultingScriptID is a
;	// compiled script ID (mode flags for OSACompile may be used in this case).
;	// Other scriptData descriptors create script value IDs.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	//
;	// ModeFlags:
;	//	kOSAModePreventGetSource
;	//	kOSAModeCompileIntoContext
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSACoerceFromDesc
		MOVE.L	#((12<<16)|kOSASelectCoerceFromDesc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSACoerceToDesc(ComponentInstance	scriptingComponent,
;	 OSAID		scriptID,
;	 DescType		desiredType,
;	 long		modeFlags,
;	 AEDesc*		result);
;	// This routine causes a script value to be coerced into any desired form.
;	// If the scriptID denotes a compiled script, then it may be coerced to 
;	// typeAppleEvent.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID

		MACRO
		_OSACoerceToDesc
		MOVE.L	#((16<<16)|kOSASelectCoerceToDesc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional AESending Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the AESending interface have the 
;// kOSASupportsAESending bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;// Scripting systems will supply default values for these procedures if they
;// are not set by the client:

;pascal OSAError
;OSASetSendProc(ComponentInstance	scriptingComponent,
;	AESendProcPtr		sendProc,
;	long		refCon);
;	// If sendProc is nil, the default sendProc is used.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSASetSendProc
		MOVE.L	#((8<<16)|kOSASelectSetSendProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAGetSendProc(ComponentInstance	scriptingComponent,
;	AESendProcPtr*		sendProc,
;	long*		refCon);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAGetSendProc
		MOVE.L	#((8<<16)|kOSASelectGetSendProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSASetCreateProc(ComponentInstance	scriptingComponent,
;	  AECreateAppleEventProcPtr	createProc,
;	  long		refCon);
;	// If createProc is nil, the default createProc is used.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSASetCreateProc
		MOVE.L	#((8<<16)|kOSASelectSetCreateProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAGetCreateProc(ComponentInstance	scriptingComponent,
;	  AECreateAppleEventProcPtr*	createProc,
;	  long*		refCon);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAGetCreateProc
		MOVE.L	#((8<<16)|kOSASelectGetCreateProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSASetDefaultTarget(ComponentInstance	scriptingComponent,
;	     const AEAddressDesc*	target);
;	// This routine sets the default target application for AE sending.
;	// It also establishes the default target from which terminologies come.
;	// It is effectively like having an AppleScript "tell" statement around
;	// the entire program.  If this routine is not called, or if the target 
;	// is a null AEDesc, then the current application is the default target.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSASetDefaultTarget
		MOVE.L	#((4<<16)|kOSASelectSetDefaultTarget),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional Recording Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the Recording interface have the 
;// kOSASupportsRecording bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;pascal OSAError
;OSAStartRecording(ComponentInstance	scriptingComponent,
;	   OSAID*		compiledScriptToModifyID);
;	// Starts recording.  If compiledScriptToModifyID is kOSANullScript, a
;	// new script ID is created and returned.  If the current application has
;	// a handler for the kOSARecordedText event, then kOSARecordedText events
;	// are sent to the application containing the text of each AppleEvent 
;	// recorded.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	//	errOSARecordingIsAlreadyOn

		MACRO
		_OSAStartRecording
		MOVE.L	#((4<<16)|kOSASelectStartRecording),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAStopRecording(ComponentInstance	scriptingComponent,
;	  OSAID		compiledScriptID);
;	// If compiledScriptID is not being recorded into or recording is not
;	// currently on, no error is returned.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID

		MACRO
		_OSAStopRecording
		MOVE.L	#((4<<16)|kOSASelectStopRecording),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional Convenience Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the Convenience interface have the 
;// kOSASupportsConvenience bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;pascal OSAError 
;OSALoadExecute(ComponentInstance	scriptingComponent,
;	const AEDesc*		scriptData,
;	OSAID		contextID,
;	long		modeFlags,
;	OSAID*		resultingScriptValueID);
;	// This routine is effectively equivalent to calling OSALoad followed by
;	// OSAExecute.  After execution, the compiled source is disposed.  Only the
;	// resulting value ID is retained.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSABadStorageType:	scriptData not for this scripting component
;	// 	errOSACorruptData:		data seems to be corrupt
;	// 	errOSADataFormatObsolete	script data format is no longer supported
;	// 	errOSADataFormatTooNew		script data format is from a newer version
;	// 	errOSAInvalidID
;	// 	errOSAScriptError:		the executing script got an error
;	//
;	// ModeFlags:
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSALoadExecute
		MOVE.L	#((16<<16)|kOSASelectStore),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError 
;OSACompileExecute(ComponentInstance	scriptingComponent,
;	   const AEDesc*	sourceData,
;	   OSAID		contextID,
;	   long		modeFlags,
;	   OSAID*		resultingScriptValueID);
;	// This routine is effectively equivalent to calling OSACompile followed by
;	// OSAExecute.  After execution, the compiled source is disposed.  Only the
;	// resulting value ID is retained.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	//	errAECoercionFail:		sourceData is not compilable
;	// 	errOSAScriptError:		sourceData was a bad script (syntax error)
;	// 	errOSAInvalidID:		previousAndResultingCompiledScriptID was not
;	//							valid on input
;	// 	errOSAScriptError:		the executing script got an error
;	//
;	// ModeFlags:
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSACompileExecute
		MOVE.L	#((16<<16)|kOSASelectCompileExecute),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError 
;OSADoScript(ComponentInstance	scriptingComponent,
;            const AEDesc*	sourceData,
;            OSAID	contextID,
;            DescType	desiredType,
;            long	modeFlags,
;            AEDesc*	resultingText);
;	// This routine is effectively equivalent to calling OSACompile followed by
;	// OSAExecute and then OSADisplay.  After execution, the compiled source
;	// and the resulting value are is disposed.  Only the resultingText
;	// descriptor is retained.  If a script error occur during processing, the 
;	// resultingText gets the error message of the error, and errOSAScriptError
;	// is returned.  OSAScriptError may still be used to extract more 
;	// information about the particular error.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	//	errAECoercionFail:	sourceData is not compilable or 
;	//			desiredType not supported by scripting component
;	// 	errOSAScriptError:	sourceData was a bad script (syntax error)
;	// 	errOSAInvalidID:	previousAndResultingCompiledScriptID was not
;	//			valid on input
;	// 	errOSAScriptError:	the executing script got an error
;	//
;	// ModeFlags:
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord
;	//	kOSAModeDisplayForHumans

		MACRO
		_OSADoScript
		MOVE.L	#((20<<16)|kOSASelectDoScript),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional Dialects Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the Dialects interface have the 
;// kOSASupportsDialects bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;// These calls allows an scripting component that supports different dialects
;// to dynamically switch between those dialects.  Although this interface is
;// specified, the particular dialect codes are scripting component dependent.

;pascal OSAError 
;OSASetCurrentDialect(ComponentInstance	scriptingComponent,
;	      short		dialectCode);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSANoSuchDialect:	invalid dialectCode

		MACRO
		_OSASetCurrentDialect
		MOVE.L	#((2<<16)|kOSASelectSetCurrentDialect),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError 
;OSAGetCurrentDialect(ComponentInstance	scriptingComponent,
;	      short*		resultingDialectCode);
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAGetCurrentDialect
		MOVE.L	#((4<<16)|kOSASelectGetCurrentDialect),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError 
;OSAAvailableDialects(ComponentInstance	scriptingComponent,
;	      AEDesc*		resultingDialectInfoList);
;	// This call return an AEList containing information about each of the
;	// currently available dialects of a scripting component.  Each item
;	// is an AERecord of typeOSADialectInfo that contains at least the fields
;	// keyOSADialectName, keyOSADialectCode, KeyOSADialectLangCode and 
;	// keyOSADialectScriptCode.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAAvailableDialects
		MOVE.L	#((4<<16)|kOSASelectAvailableDialects),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAGetDialectInfo(ComponentInstance	scriptingComponent,
;	   short		dialectCode,
;	   OSType		selector,
;	   AEDesc*		resultingDialectInfo);
;	// This call gives information about the specified dialect of a scripting
;	// component. It returns an AEDesc whose type depends on the selector 
;	// specified. Available selectors are the same as the field keys for a
;	// dialect info record. The type of AEDesc returned is the same as the 
;	// type of the field that has same key as the selector.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	//  errOSABadSelector
;	// 	errOSANoSuchDialect:	invalid dialectCode

		MACRO
		_OSAGetDialectInfo
		MOVE.L	#((10<<16)|kOSASelectGetDialectInfo),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError 
;OSAAvailableDialectCodeList(ComponentInstance	scriptingComponent,
;	    AEDesc*		resultingDialectCodeList);
;	// This is alternative to OSAGetAvailableDialectCodeList. Use this call
;	// and  OSAGetDialectInfo to get information on dialects.
;	// This call return an AEList containing dialect code for each of the
;	// currently available dialects of a scripting component. Each dialect
;	// code is a short integer of type typeShortInteger.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAAvailableDialectCodeList
		MOVE.L	#((4<<16)|kOSASelectAvailableDialectCodeList),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

typeOSADialectInfo	EQU	'difo'
;	// Type of a dialect info record containing at least keyOSADialectName
;	// and keyOSADialectCode fields.

;// keys for dialect info record, also used as selectors to OSAGetDialectInfo.

keyOSADialectName	EQU	'dnam'
;	// Field of a typeOSADialectInfo record of typeChar.
keyOSADialectCode	EQU	'dcod'
;	// Field of a typeOSADialectInfo record of typeShortInteger.
keyOSADialectLangCode	EQU	'dlcd'
;	// Field of a typeOSADialectInfo record of typeShortInteger.
keyOSADialectScriptCode	EQU	'dscd'
;	// Field of a typeOSADialectInfo record of typeShortInteger.

;////////////////////////////////////////////////////////////////////////////////
;// OSA Optional Event Handling Interface
;////////////////////////////////////////////////////////////////////////////////
;// Scripting components that support the Event Handling interface have the 
;// kOSASupportsEventHandling bit set in it's ComponentDescription.
;////////////////////////////////////////////////////////////////////////////////

;pascal OSAError
;OSASetResumeDispatchProc(ComponentInstance	scriptingComponent,
;	          AEHandlerProcPtr	resumeDispatchProc,
;	          long		refCon);
;	// This function is used to set the ResumeDispatchProc that will be used
;	// by OSAExecuteEvent and OSADoEvent if either no event handler can be
;	// found in the context, or the context event hander "continues" control
;	// onward. The two constants kOSAUseStandardDispatch and kOSANoDispatch
;	// may also be passed to this routine indicating that the handler registered
;	// in the application with AEInstallEventHandler should be used, or no
;	// dispatch should occur, respectively.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSASetResumeDispatchProc
		MOVE.L	#((8<<16)|kOSASelectSetResumeDispatchProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

kOSAUseStandardDispatch	EQU	kAEUseStandardDispatch
;	// Special ResumeDispatchProc constant which may be passed to 
;	// OSASetResumeDispatchProc indicating that the handler registered
;	// in the application with AEInstallEventHandler should be used.

kOSANoDispatch		EQU	kAENoDispatch
;	// Special ResumeDispatchProc constant which may be passed to 
;	// OSASetResumeDispatchProc indicating that no dispatch should occur.

kOSADontUsePhac		EQU	$0001
;	// Special refCon constant that may be given to OSASetResumeDispatchProc
;	// only when kOSAUseStandardDispatch is used as the ResumeDispatchProc.
;	// This causes the standard dispatch to be performed, except the phac
;	// handler is not called.  This is useful during tinkerability, when
;	// the phac handler is used to lookup a context associated with an event's 
;	// direct parameter, and call OSAExecuteEvent or OSADoEvent.  Failure to
;	// bypass the phac handler would result in an infinite loop.

;pascal OSAError
;OSAGetResumeDispatchProc(ComponentInstance	scriptingComponent,
;	          AEHandlerProcPtr*	resumeDispatchProc,
;	          long*		refCon);
;	// Returns the registered ResumeDispatchProc.  If no ResumeDispatchProc has
;	// been registered, then kOSAUseStandardDispatch (the default) is returned.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError

		MACRO
		_OSAGetResumeDispatchProc
		MOVE.L	#((8<<16)|kOSASelectGetResumeDispatchProc),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAExecuteEvent(ComponentInstance	scriptingComponent,
;	 const AppleEvent*	theAppleEvent,
;	 OSAID		contextID,
;	 long		modeFlags,
;	 OSAID*		resultingScriptValueID);
;	// This call is similar to OSAExecute except the initial command to
;	// execute comes in the form of an AppleEvent.  If the contextID
;	// defines any event handlers for that event, they are used to process
;	// the event.  If no event handler can be found in the context
;	// errAEEventNotHandled is returned.  If an event handler is found and
;	// the hander "continues" control onward, the ResumeDispatchProc
;	// (registered with OSASetResumeDispatchProc, above) is called given the
;	// AppleEvent.  The result is returned as a scriptValueID.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	// 	errOSAScriptError:		the executing script got an error
;	// 	errAEEventNotHandled:	no handler for event in contextID
;	//
;	// ModeFlags:
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSAExecuteEvent
		MOVE.L	#((16<<16)|kOSASelectExecuteEvent),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSADoEvent(ComponentInstance	scriptingComponent,
;           const AppleEvent*	theAppleEvent,
;           OSAID	contextID,
;           long	modeFlags,
;           AppleEvent*	reply);
;	// This call is similar to OSADoScript except the initial command to
;	// execute comes in the form of an AppleEvent, and the result is an 
;	// AppleEvent reply record.  If the contextID defines any event handlers
;	// for that event, they are used to process the event.  If no event handler
;	// can be found in the context errAEEventNotHandled is returned.  If an
;	// event handler is found and the hander "continues" control onward, the
;	// ResumeDispatchProc (registered with OSASetResumeDispatchProc, above) is
;	// called given the AppleEvent.  The result is returned in the form of an
;	// AppleEvent reply descriptor. If at any time the script gets an error, or
;	// if the ResumeDispatchProc returns a reply event indicating an error,
;	// then the OSADoEvent call itself returns an error reply (i.e. OSADoEvent
;	// should never return errOSAScriptError).  Any error result returned by
;	// the ResumeDispatchProc will be returned by OSADoEvent.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	// 	errAEEventNotHandled:	no handler for event in contextID
;	//
;	// ModeFlags:
;	//	kOSAModeNeverInteract
;	//	kOSAModeCanInteract
;	//	kOSAModeAlwaysInteract
;	//	kOSAModeCantSwitchLayer
;	//	kOSAModeDontReconnect
;	//	kOSAModeDoRecord

		MACRO
		_OSADoEvent
		MOVE.L	#((16<<16)|kOSASelectStore),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;pascal OSAError
;OSAMakeContext(ComponentInstance	scriptingComponent,
;	const AEDesc*		contextName,
;	OSAID		parentContext,
;	OSAID*		resultingContextID);
;	// Makes a new empty context which may be passed to OSAExecute or 
;	// OSAExecuteEvent.  If contextName is typeNull, an unnamed context is
;	// created. If parentContext is kOSANullScript then the resulting context
;	// does not inherit bindings from any other context.
;	//
;	// Errors:
;	//	badComponentInstance	invalid scripting component instance
;	// 	errOSASystemError
;	// 	errOSAInvalidID
;	// 	errAECoercionFail:		contextName is invalid

		MACRO
		_OSAMakeContext
		MOVE.L	#((12<<16)|kOSASelectMakeContext),-(A7)
		MOVEQ	#$0,D0
		DC.W	$A82A	; TB 002A
		ENDM

;////////////////////////////////////////////////////////////////////////////////
;// You're still here?  Go home.
 ENDIF
;////////////////////////////////////////////////////////////////////////////////
