/*
	File:		Memory.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __MEMORY__
#define __MEMORY__

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

enum  {
	maxSize						= 0x800000,						/*Max data block size is 8 megabytes*/
	defaultPhysicalEntryCount	= 8,
/* values returned from the GetPageState function */
	kPageInMemory				= 0,
	kPageOnDisk					= 1,
	kNotPaged					= 2
};

enum  {
/* masks for Zone->heapType field */
	k32BitHeap					= 1,							/* valid in all Memory Managers */
	kNewStyleHeap				= 2,							/* true if new Heap Manager is present */
	kNewDebugHeap				= 4								/* true if new Heap Manager is running in debug mode on this heap */
};


/* size of a block in bytes */

typedef long Size;

typedef struct Zone Zone, *THz;

typedef pascal long (*GrowZoneProcPtr)(Size cbNeeded);

enum {
	uppGrowZoneProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Size)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr GrowZoneUPP;

#define CallGrowZoneProc(userRoutine, cbNeeded)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppGrowZoneProcInfo, (cbNeeded))
#define NewGrowZoneProc(userRoutine)		\
		(GrowZoneUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppGrowZoneProcInfo, GetCurrentISA())
#else
typedef GrowZoneProcPtr GrowZoneUPP;

#define CallGrowZoneProc(userRoutine, cbNeeded)		\
		(*(userRoutine))((cbNeeded))
#define NewGrowZoneProc(userRoutine)		\
		(GrowZoneUPP)(userRoutine)
#endif

typedef pascal void (*PurgeProcPtr)(Handle blockToPurge);

enum {
	uppPurgeProcInfo = kPascalStackBased
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(Handle)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr PurgeUPP;

#define CallPurgeProc(userRoutine, blockToPurge)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppPurgeProcInfo, (blockToPurge))
#define NewPurgeProc(userRoutine)		\
		(PurgeUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppPurgeProcInfo, GetCurrentISA())
#else
typedef PurgeProcPtr PurgeUPP;

#define CallPurgeProc(userRoutine, blockToPurge)		\
		(*(userRoutine))((blockToPurge))
#define NewPurgeProc(userRoutine)		\
		(PurgeUPP)(userRoutine)
#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct Zone {
	Ptr							bkLim;
	Ptr							purgePtr;
	Ptr							hFstFree;
	long						zcbFree;
	GrowZoneUPP					gzProc;
	short						moreMast;
	short						flags;
	short						cntRel;
	short						maxRel;
	short						cntNRel;
	Byte						heapType;
	Byte						unused;
	short						cntEmpty;
	short						cntHandles;
	long						minCBFree;
	PurgeUPP					purgeProc;
	Ptr							sparePtr;
	Ptr							allocPtr;
	short						heapData;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct MemoryBlock {
	void						*address;
	unsigned long				count;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct MemoryBlock MemoryBlock;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct LogicalToPhysicalTable {
	MemoryBlock					logical;
	MemoryBlock					physical[defaultPhysicalEntryCount];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct LogicalToPhysicalTable LogicalToPhysicalTable;

typedef short PageState;

typedef short StatusRegisterContents;


/*
	UserFnProcs cannot be written in or called from a high-level 
	language without the help of mixed mode or assembly glue because they 
	use the following parameter-passing convention:

	typedef pascal void (*UserFnProcPtr)(void *parameter);

		In:
			=> 	parameter				A0.L
		Out:
			none
*/

enum  {
	uppUserFnProcInfo			= kRegisterBased|REGISTER_ROUTINE_PARAMETER(1,kRegisterA0,kFourByteCode)
};

#if USESROUTINEDESCRIPTORS
typedef pascal void (*UserFnProcPtr)(void *parameter);

typedef UniversalProcPtr UserFnUPP;

#define CallUserFnProc(userRoutine, parameter)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppUserFnProcInfo, (parameter))

#define NewUserFnProc(userRoutine)  \
	(UserFnUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppUserFnProcInfo, GetCurrentISA())

#else
typedef ProcPtr UserFnUPP;

#define NewUserFnProc(userRoutine)  \
	(UserFnUPP)(userRoutine)

#endif

#ifdef __cplusplus
extern "C" {
#endif

#if USESCODEFRAGMENTS
extern pascal Ptr GetApplLimit(void);
extern pascal THz SystemZone(void);
extern pascal THz ApplicationZone(void);
extern pascal Handle GZSaveHnd(void);
extern pascal Ptr TopMem(void);
extern pascal OSErr MemError(void);
#else
#define GetApplLimit() (* (Ptr*) 0x0130)

#define SystemZone() (* (THz*) 0x02A6)

#define ApplicationZone() (* (THz*) 0x02AA)

#define GZSaveHnd() (* (Handle*) 0x0328)

#define TopMem() (* (Ptr*) 0x0108)

#define MemError() (* (OSErr*) 0x0220)

#endif


#if USES68KINLINES
#pragma parameter __A0 GetZone
#endif
extern pascal THz GetZone(void)
 ONEWORDINLINE(0xA11A);

#if USES68KINLINES
#pragma parameter __A0 NewHandle(__D0)
#endif
extern pascal Handle NewHandle(Size byteCount)
 ONEWORDINLINE(0xA122);

#if USES68KINLINES
#pragma parameter __A0 NewHandleSys(__D0)
#endif
extern pascal Handle NewHandleSys(Size byteCount)
 ONEWORDINLINE(0xA522);

#if USES68KINLINES
#pragma parameter __A0 NewHandleClear(__D0)
#endif
extern pascal Handle NewHandleClear(Size byteCount)
 ONEWORDINLINE(0xA322);

#if USES68KINLINES
#pragma parameter __A0 NewHandleSysClear(__D0)
#endif
extern pascal Handle NewHandleSysClear(Size byteCount)
 ONEWORDINLINE(0xA722);

#if USES68KINLINES
#pragma parameter __A0 HandleZone(__A0)
#endif
extern pascal THz HandleZone(Handle h)
 ONEWORDINLINE(0xA126);

#if USES68KINLINES
#pragma parameter __A0 RecoverHandle(__A0)
#endif
extern pascal Handle RecoverHandle(Ptr p)
 ONEWORDINLINE(0xA128);

#if USES68KINLINES
#pragma parameter __A0 RecoverHandleSys(__A0)
#endif
extern pascal Handle RecoverHandleSys(Ptr p)
 ONEWORDINLINE(0xA528);

#if USES68KINLINES
#pragma parameter __A0 NewPtr(__D0)
#endif
extern pascal Ptr NewPtr(Size byteCount)
 ONEWORDINLINE(0xA11E);

#if USES68KINLINES
#pragma parameter __A0 NewPtrSys(__D0)
#endif
extern pascal Ptr NewPtrSys(Size byteCount)
 ONEWORDINLINE(0xA51E);

#if USES68KINLINES
#pragma parameter __A0 NewPtrClear(__D0)
#endif
extern pascal Ptr NewPtrClear(Size byteCount)
 ONEWORDINLINE(0xA31E);

#if USES68KINLINES
#pragma parameter __A0 NewPtrSysClear(__D0)
#endif
extern pascal Ptr NewPtrSysClear(Size byteCount)
 ONEWORDINLINE(0xA71E);

#if USES68KINLINES
#pragma parameter __A0 PtrZone(__A0)
#endif
extern pascal THz PtrZone(Ptr p)
 ONEWORDINLINE(0xA148);

#if USES68KINLINES
#pragma parameter __D0 MaxBlock
#endif
extern pascal long MaxBlock(void)
 ONEWORDINLINE(0xA061);

#if USES68KINLINES
#pragma parameter __D0 MaxBlockSys
#endif
extern pascal long MaxBlockSys(void)
 ONEWORDINLINE(0xA461);

#if USES68KINLINES
#pragma parameter __D0 StackSpace
#endif
extern pascal long StackSpace(void)
 ONEWORDINLINE(0xA065);

#if USES68KINLINES
#pragma parameter __A0 NewEmptyHandle
#endif
extern pascal Handle NewEmptyHandle(void)
 ONEWORDINLINE(0xA166);

#if USES68KINLINES
#pragma parameter __A0 NewEmptyHandleSys
#endif
extern pascal Handle NewEmptyHandleSys(void)
 ONEWORDINLINE(0xA566);

#if USES68KINLINES
#pragma parameter  HLock(__A0)
#endif
extern pascal void HLock(Handle h)
 ONEWORDINLINE(0xA029);

#if USES68KINLINES
#pragma parameter  HUnlock(__A0)
#endif
extern pascal void HUnlock(Handle h)
 ONEWORDINLINE(0xA02A);

#if USES68KINLINES
#pragma parameter  HPurge(__A0)
#endif
extern pascal void HPurge(Handle h)
 ONEWORDINLINE(0xA049);

#if USES68KINLINES
#pragma parameter  HNoPurge(__A0)
#endif
extern pascal void HNoPurge(Handle h)
 ONEWORDINLINE(0xA04A);

#if USES68KINLINES
#pragma parameter  HLockHi(__A0)
#endif
extern pascal void HLockHi(Handle h)
 TWOWORDINLINE(0xA064, 0xA029);
extern pascal Handle TempNewHandle(Size logicalSize, OSErr *resultCode)
 THREEWORDINLINE(0x3F3C, 0x001D, 0xA88F);
extern pascal Size TempMaxMem(Size *grow)
 THREEWORDINLINE(0x3F3C, 0x0015, 0xA88F);
extern pascal long TempFreeMem(void)
 THREEWORDINLINE(0x3F3C, 0x0018, 0xA88F);

/*  Temporary Memory routines renamed, but obsolete, in System 7.0 and later.  */

extern pascal void TempHLock(Handle h, OSErr *resultCode)
 THREEWORDINLINE(0x3F3C, 0x001E, 0xA88F);
extern pascal void TempHUnlock(Handle h, OSErr *resultCode)
 THREEWORDINLINE(0x3F3C, 0x001F, 0xA88F);
extern pascal void TempDisposeHandle(Handle h, OSErr *resultCode)
 THREEWORDINLINE(0x3F3C, 0x0020, 0xA88F);
extern pascal Ptr TempTopMem(void)
 THREEWORDINLINE(0x3F3C, 0x0016, 0xA88F);
extern pascal void InitApplZone(void)
 ONEWORDINLINE(0xA02C);
extern pascal void InitZone(GrowZoneUPP pgrowZone, short cmoreMasters, void *limitPtr, void *startPtr);

#if USES68KINLINES
#pragma parameter  SetZone(__A0)
#endif
extern pascal void SetZone(THz hz)
 ONEWORDINLINE(0xA01B);

#if USES68KINLINES
#pragma parameter __D0 CompactMem(__D0)
#endif
extern pascal Size CompactMem(Size cbNeeded)
 ONEWORDINLINE(0xA04C);

#if USES68KINLINES
#pragma parameter __D0 CompactMemSys(__D0)
#endif
extern pascal Size CompactMemSys(Size cbNeeded)
 ONEWORDINLINE(0xA44C);

#if USES68KINLINES
#pragma parameter  PurgeMem(__D0)
#endif
extern pascal void PurgeMem(Size cbNeeded)
 ONEWORDINLINE(0xA04D);

#if USES68KINLINES
#pragma parameter  PurgeMemSys(__D0)
#endif
extern pascal void PurgeMemSys(Size cbNeeded)
 ONEWORDINLINE(0xA44D);

#if USES68KINLINES
#pragma parameter __D0 FreeMem
#endif
extern pascal long FreeMem(void)
 ONEWORDINLINE(0xA01C);

#if USES68KINLINES
#pragma parameter __D0 FreeMemSys
#endif
extern pascal long FreeMemSys(void)
 ONEWORDINLINE(0xA41C);

#if USES68KINLINES
#pragma parameter  ReserveMem(__D0)
#endif
extern pascal void ReserveMem(Size cbNeeded)
 ONEWORDINLINE(0xA040);

#if USES68KINLINES
#pragma parameter  ReserveMemSys(__D0)
#endif
extern pascal void ReserveMemSys(Size cbNeeded)
 ONEWORDINLINE(0xA440);

#if USES68KINLINES
#pragma parameter __D0 MaxMem(__A1)
#endif
extern pascal Size MaxMem(Size *grow)
 TWOWORDINLINE(0xA11D, 0x2288);

#if USES68KINLINES
#pragma parameter __D0 MaxMemSys(__A1)
#endif
extern pascal Size MaxMemSys(Size *grow)
 TWOWORDINLINE(0xA51D, 0x2288);

#if USES68KINLINES
#pragma parameter  SetGrowZone(__A0)
#endif
extern pascal void SetGrowZone(GrowZoneUPP growZone)
 ONEWORDINLINE(0xA04B);

#if USES68KINLINES
#pragma parameter  SetApplLimit(__A0)
#endif
extern pascal void SetApplLimit(void *zoneLimit)
 ONEWORDINLINE(0xA02D);

#if USES68KINLINES
#pragma parameter  MoveHHi(__A0)
#endif
extern pascal void MoveHHi(Handle h)
 ONEWORDINLINE(0xA064);

#if USES68KINLINES
#pragma parameter  DisposePtr(__A0)
#endif
extern pascal void DisposePtr(Ptr p)
 ONEWORDINLINE(0xA01F);
extern pascal Size GetPtrSize(Ptr p);

#if USES68KINLINES
#pragma parameter  SetPtrSize(__A0, __D0)
#endif
extern pascal void SetPtrSize(Ptr p, Size newSize)
 ONEWORDINLINE(0xA020);

#if USES68KINLINES
#pragma parameter  DisposeHandle(__A0)
#endif
extern pascal void DisposeHandle(Handle h)
 ONEWORDINLINE(0xA023);

#if USES68KINLINES
#pragma parameter  SetHandleSize(__A0, __D0)
#endif
extern pascal void SetHandleSize(Handle h, Size newSize)
 ONEWORDINLINE(0xA024);
extern pascal Size GetHandleSize(Handle h);

#if USES68KINLINES
#pragma parameter __D0 InlineGetHandleSize(__A0)
#endif
extern pascal Size InlineGetHandleSize(Handle h)
 ONEWORDINLINE(0xA025);

#if USES68KINLINES
#pragma parameter  ReallocateHandle(__A0, __D0)
#endif
extern pascal void ReallocateHandle(Handle h, Size byteCount)
 ONEWORDINLINE(0xA027);

#if USES68KINLINES
#pragma parameter  EmptyHandle(__A0)
#endif
extern pascal void EmptyHandle(Handle h)
 ONEWORDINLINE(0xA02B);

#if USES68KINLINES
#pragma parameter  HSetRBit(__A0)
#endif
extern pascal void HSetRBit(Handle h)
 ONEWORDINLINE(0xA067);

#if USES68KINLINES
#pragma parameter  HClrRBit(__A0)
#endif
extern pascal void HClrRBit(Handle h)
 ONEWORDINLINE(0xA068);
extern pascal void MoreMasters(void)
 ONEWORDINLINE(0xA036);

#if USES68KINLINES
#pragma parameter  BlockMove(__A0, __A1, __D0)
#endif
extern pascal void BlockMove(const void *srcPtr, void *destPtr, Size byteCount)
 ONEWORDINLINE(0xA02E);

#if USES68KINLINES
#pragma parameter  BlockMoveData(__A0, __A1, __D0)
#endif
extern pascal void BlockMoveData(const void *srcPtr, void *destPtr, Size byteCount)
 ONEWORDINLINE(0xA22E);
extern pascal void PurgeSpace(long *total, long *contig);

#if USES68KINLINES
#pragma parameter __D0 HGetState(__A0)
#endif
extern pascal char HGetState(Handle h)
 ONEWORDINLINE(0xA069);

#if USES68KINLINES
#pragma parameter  HSetState(__A0, __D0)
#endif
extern pascal void HSetState(Handle h, char flags)
 ONEWORDINLINE(0xA06A);

#if USES68KINLINES
#pragma parameter  SetApplBase(__A0)
#endif
extern pascal void SetApplBase(void *startPtr)
 ONEWORDINLINE(0xA057);
extern pascal void MaxApplZone(void)
 ONEWORDINLINE(0xA063);

#if USES68KINLINES
#pragma parameter __D0 HoldMemory(__A0, __A1)
#endif
extern pascal OSErr HoldMemory(void *address, unsigned long count)
 TWOWORDINLINE(0x7000, 0xA05C);

#if USES68KINLINES
#pragma parameter __D0 UnholdMemory(__A0, __A1)
#endif
extern pascal OSErr UnholdMemory(void *address, unsigned long count)
 TWOWORDINLINE(0x7001, 0xA05C);

#if USES68KINLINES
#pragma parameter __D0 LockMemory(__A0, __A1)
#endif
extern pascal OSErr LockMemory(void *address, unsigned long count)
 TWOWORDINLINE(0x7002, 0xA05C);

#if USES68KINLINES
#pragma parameter __D0 LockMemoryContiguous(__A0, __A1)
#endif
extern pascal OSErr LockMemoryContiguous(void *address, unsigned long count)
 TWOWORDINLINE(0x7004, 0xA05C);

#if USES68KINLINES
#pragma parameter __D0 UnlockMemory(__A0, __A1)
#endif
extern pascal OSErr UnlockMemory(void *address, unsigned long count)
 TWOWORDINLINE(0x7003, 0xA05C);
extern pascal OSErr GetPhysical(LogicalToPhysicalTable *addresses, unsigned long *physicalEntryCount);

#if USES68KINLINES
#pragma parameter __D0 DeferUserFn(__A0, __D0)
#endif
extern pascal OSErr DeferUserFn(UserFnUPP userFunction, void *argument)
 ONEWORDINLINE(0xA08F);

#if USES68KINLINES
#pragma parameter __D0 DebuggerGetMax
#endif
extern pascal long DebuggerGetMax(void)
 TWOWORDINLINE(0x7000, 0xA08D);
extern pascal void DebuggerEnter(void)
 TWOWORDINLINE(0x7001, 0xA08D);
extern pascal void DebuggerExit(void)
 TWOWORDINLINE(0x7002, 0xA08D);
extern pascal void DebuggerPoll(void)
 TWOWORDINLINE(0x7003, 0xA08D);

#if USES68KINLINES
#pragma parameter __D0 GetPageState(__A0)
#endif
extern pascal PageState GetPageState(const void *address)
 TWOWORDINLINE(0x7004, 0xA08D);

#if USES68KINLINES
#pragma parameter __D0 PageFaultFatal
#endif
extern pascal Boolean PageFaultFatal(void)
 TWOWORDINLINE(0x7005, 0xA08D);

#if USES68KINLINES
#pragma parameter __D0 DebuggerLockMemory(__A0, __A1)
#endif
extern pascal OSErr DebuggerLockMemory(void *address, unsigned long count)
 TWOWORDINLINE(0x7006, 0xA08D);

#if USES68KINLINES
#pragma parameter __D0 DebuggerUnlockMemory(__A0, __A1)
#endif
extern pascal OSErr DebuggerUnlockMemory(void *address, unsigned long count)
 TWOWORDINLINE(0x7007, 0xA08D);

#if USES68KINLINES
#pragma parameter __D0 EnterSupervisorMode
#endif
extern pascal StatusRegisterContents EnterSupervisorMode(void)
 TWOWORDINLINE(0x7008, 0xA08D);

/* HeapDispatch glue */


#if USES68KINLINES
#pragma parameter __D0 DisposeZone(__A0)
#endif
extern pascal OSErr DisposeZone(THz theZone)
 TWOWORDINLINE(0x701D, 0xA0A4);
#if USES68KINLINES
#if SystemSixOrLater

#if USES68KINLINES
#pragma parameter __D0 StripAddress(__D0)
#endif
extern pascal Ptr StripAddress(void *theAddress)
 ONEWORDINLINE(0xA055);
#else
extern pascal Ptr StripAddress(void *theAddress);
#endif

#else
#define StripAddress(x) ((Ptr)(x))

#endif

#if USES68KINLINES

#if USES68KINLINES
#pragma parameter __D0 Translate24To32(__D0)
#endif
extern pascal Ptr Translate24To32(void *addr24)
 ONEWORDINLINE(0xA091);
#else
#define Translate24To32(x) ((Ptr)(x))

#endif

#if OLDROUTINENAMES
#define ApplicZone() ApplicationZone()

#define MFTempNewHandle(logicalSize, resultCode) TempNewHandle(logicalSize, resultCode)

#define MFMaxMem(grow) TempMaxMem(grow)

#define MFFreeMem() TempFreeMem()

#define MFTempHLock(h, resultCode) TempHLock(h, resultCode)

#define MFTempHUnlock(h, resultCode) TempHUnlock(h, resultCode)

#define MFTempDisposHandle(h, resultCode) TempDisposeHandle(h, resultCode)

#define MFTopMem() TempTopMem()

#define ResrvMem(cbNeeded) ReserveMem(cbNeeded)

#define DisposPtr(p) DisposePtr(p)

#define DisposHandle(h) DisposeHandle(h)

#define ReallocHandle(h, byteCount) ReallocateHandle(h, byteCount)

#endif

#ifdef __cplusplus
}
#endif

#endif

