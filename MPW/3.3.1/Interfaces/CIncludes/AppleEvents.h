/*
	File:		AppleEvents.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __APPLEEVENTS__
#define __APPLEEVENTS__

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

#ifndef __MEMORY__
#include <Memory.h>
#endif

#ifndef __OSUTILS__
#include <OSUtils.h>
#endif

#ifndef __EVENTS__
#include <Events.h>
/*	#include <Quickdraw.h>										*/
/*		#include <QuickdrawText.h>								*/
/*			#include <IntlResources.h>							*/
#endif

#ifndef __EPPC__
#include <EPPC.h>
/*	#include <PPCToolBox.h>										*/
/*		#include <AppleTalk.h>									*/
/*	#include <Processes.h>										*/
/*		#include <Files.h>										*/
/*			#include <SegLoad.h>								*/
#endif

#ifndef __NOTIFICATION__
#include <Notification.h>
#endif


/*--------------------------------------------------------------
		Apple event descriptor types
--------------------------------------------------------------*/

#define typeBoolean 'bool'

#define typeChar 'TEXT'

#define typeSMInt 'shor'

#define typeInteger 'long'

#define typeSMFloat 'sing'

#define typeFloat 'doub'

#define typeLongInteger 'long'

#define typeShortInteger 'shor'

#define typeLongFloat 'doub'

#define typeShortFloat 'sing'

#define typeExtended 'exte'

#define typeComp 'comp'

#define typeMagnitude 'magn'

#define typeAEList 'list'

#define typeAERecord 'reco'

#define typeAppleEvent 'aevt'

#define typeTrue 'true'

#define typeFalse 'fals'

#define typeAlias 'alis'

#define typeEnumerated 'enum'

#define typeType 'type'

#define typeAppParameters 'appa'

#define typeProperty 'prop'

#define typeFSS 'fss '

#define typeKeyword 'keyw'

#define typeSectionH 'sect'

#define typeWildCard '****'

#define typeApplSignature 'sign'

#define typeSessionID 'ssid'

#define typeTargetID 'targ'

#define typeProcessSerialNumber 'psn '

#define typeNull 'null'


/*--------------------------------------------------------------
		Keywords for Apple event parameters
--------------------------------------------------------------*/

#define keyDirectObject '----'

#define keyErrorNumber 'errn'

#define keyErrorString 'errs'

#define keyProcessSerialNumber 'psn '


/*--------------------------------------------------------------
		Keywords for Apple event attributes
--------------------------------------------------------------*/

#define keyTransactionIDAttr 'tran'

#define keyReturnIDAttr 'rtid'

#define keyEventClassAttr 'evcl'

#define keyEventIDAttr 'evid'

#define keyAddressAttr 'addr'

#define keyOptionalKeywordAttr 'optk'

#define keyTimeoutAttr 'timo'

#define keyInteractLevelAttr 'inte'

#define keyEventSourceAttr 'esrc'

#define keyMissedKeywordAttr 'miss'

#define keyOriginalAddressAttr 'from'


/*--------------------------------------------------------------
		Keywords for special handlers
--------------------------------------------------------------*/

#define keyPreDispatch 'phac'

#define keySelectProc 'selh'


/*--------------------------------------------------------------
		Keyword for recording
--------------------------------------------------------------*/

#define keyAERecorderCount 'recr'


/*--------------------------------------------------------------
		Keyword for version information
--------------------------------------------------------------*/

#define keyAEVersion 'vers'


/*--------------------------------------------------------------
		Event Class
--------------------------------------------------------------*/

#define kCoreEventClass 'aevt'


/*--------------------------------------------------------------
		Event ID's
--------------------------------------------------------------*/

#define kAEOpenApplication 'oapp'

#define kAEOpenDocuments 'odoc'

#define kAEPrintDocuments 'pdoc'

#define kAEQuitApplication 'quit'

#define kAEAnswer 'ansr'

#define kAEApplicationDied 'obit'


/*--------------------------------------------------------------
		Constants for use in AESend mode
--------------------------------------------------------------*/

enum  {
	kAENoReply					= 0x00000001,					/* sender doesn't want a reply to event */
	kAEQueueReply				= 0x00000002,					/* sender wants a reply but won't wait */
	kAEWaitReply				= 0x00000003,					/* sender wants a reply and will wait */
	kAENeverInteract			= 0x00000010,					/* server should not interact with user */
	kAECanInteract				= 0x00000020,					/* server may try to interact with user */
	kAEAlwaysInteract			= 0x00000030,					/* server should always interact with user where appropriate */
	kAECanSwitchLayer			= 0x00000040,					/* interaction may switch layer */
	kAEDontReconnect			= 0x00000080,					/* don't reconnect if there is a sessClosedErr from PPCToolbox */
	kAEWantReceipt				= nReturnReceipt,				/* sender wants a receipt of message */
	kAEDontRecord				= 0x00001000,					/* don't record this event - available only in vers 1.0.1 and greater */
	kAEDontExecute				= 0x00002000,					/* don't send the event for recording - available only in vers 1.0.1 and greater */
/*--------------------------------------------------------------
		Constants for the send priority in AESend
--------------------------------------------------------------*/
	kAENormalPriority			= 0x00000000,					/* post message at the end of the event queue */
	kAEHighPriority				= nAttnMsg						/* post message at the front of the event queue */
};


/*--------------------------------------------------------------
		Constants for recording
--------------------------------------------------------------*/

#define kAEStartRecording 'reca'

#define kAEStopRecording 'recc'

#define kAENotifyStartRecording 'rec1'

#define kAENotifyStopRecording 'rec0'

#define kAENotifyRecording 'recr'


/*--------------------------------------------------------------
		Constant for the returnID param of AECreateAppleEvent
--------------------------------------------------------------*/

enum  {
	kAutoGenerateReturnID		= -1,							/* AECreateAppleEvent will generate a session-unique ID */
/*--------------------------------------------------------------
		Constant for transaction ID's
--------------------------------------------------------------*/
	kAnyTransactionID			= 0,							/* no transaction is in use */
/*--------------------------------------------------------------
		Constants for timeout durations
--------------------------------------------------------------*/
	kAEDefaultTimeout			= -1,							/* timeout value determined by AEM */
	kNoTimeOut					= -2							/* wait until reply comes back, however long it takes */
};


/*--------------------------------------------------------------
		Constants for AEResumeTheCurrentEvent
--------------------------------------------------------------*/

enum  {
	kAENoDispatch				= 0,							/* dispatch parameter to AEResumeTheCurrentEvent takes a pointer to a dispatch */
	kAEUseStandardDispatch		= 0xFFFFFFFF,					/* table, or one of these two constants */
/*--------------------------------------------------------------
		Constants for Refcon in AEResumeTheCurrentEvent with kAEUseStandardDispatch
--------------------------------------------------------------*/
	kAEDoNotIgnoreHandler		= 0x00000000,
	kAEIgnoreAppPhacHandler		= 0x00000001,					/* available only in vers 1.0.1 and greater */
	kAEIgnoreAppEventHandler	= 0x00000002,					/* available only in vers 1.0.1 and greater */
	kAEIgnoreSysPhacHandler		= 0x00000004,					/* available only in vers 1.0.1 and greater */
	kAEIgnoreSysEventHandler	= 0x00000008,					/* available only in vers 1.0.1 and greater */
	kAEIngoreBuiltInEventHandler = 0x00000010,					/* available only in vers 1.0.1 and greater */
	kAEDontDisposeOnResume		= 0x80000000					/* available only in vers 1.0.1 and greater */
};


/*--------------------------------------------------------------
		Apple event manager data types
--------------------------------------------------------------*/

typedef unsigned long AEEventClass;

typedef unsigned long AEEventID;

typedef unsigned long AEKeyword;

typedef ResType DescType;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct AEDesc {
	DescType					descriptorType;
	Handle						dataHandle;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct AEDesc AEDesc;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct AEKeyDesc {
	AEKeyword					descKey;
	AEDesc						descContent;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct AEKeyDesc AEKeyDesc;


/* an AEDesc which contains address data */

typedef AEDesc AEAddressDesc;


/* a list of AEDesc's is a special kind of AEDesc */

typedef AEDesc AEDescList;


/* AERecord is a list of keyworded AEDesc's */

typedef AEDescList AERecord;


/* an AERecord that contains an AppleEvent */

typedef AERecord AppleEvent;


/* parameter to AESend */

typedef long AESendMode;


/* priority param of AESend */

typedef short AESendPriority;

enum  {
	kAEInteractWithSelf,
	kAEInteractWithLocal,
	kAEInteractWithAll
};

typedef unsigned char AEInteractAllowed;

enum  {
	kAEUnknownSource,
	kAEDirectCall,
	kAESameProcess,
	kAELocalProcess,
	kAERemoteProcess
};

typedef unsigned char AEEventSource;

enum  {
	kAEDataArray,
	kAEPackedArray,
	kAEHandleArray,
	kAEDescArray,
	kAEKeyDescArray
};

typedef unsigned char AEArrayType;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
union AEArrayData {
	short						kAEDataArray[1];
	char						kAEPackedArray[1];
	Handle						kAEHandleArray[1];
	AEDesc						kAEDescArray[1];
	AEKeyDesc					kAEKeyDescArray[1];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef union AEArrayData AEArrayData;

typedef AEArrayData *AEArrayDataPointer;

typedef pascal Boolean (*AEIdleProcPtr)(EventRecord *theEvent, long *sleepTime, RgnHandle *mouseRgn);

enum {
	uppAEIdleProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(EventRecord*)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(RgnHandle*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr AEIdleUPP;

#define CallAEIdleProc(userRoutine, theEvent, sleepTime, mouseRgn)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAEIdleProcInfo, (theEvent), (sleepTime), (mouseRgn))
#define NewAEIdleProc(userRoutine)		\
		(AEIdleUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppAEIdleProcInfo, GetCurrentISA())
#else
typedef AEIdleProcPtr AEIdleUPP;

#define CallAEIdleProc(userRoutine, theEvent, sleepTime, mouseRgn)		\
		(*(userRoutine))((theEvent), (sleepTime), (mouseRgn))
#define NewAEIdleProc(userRoutine)		\
		(AEIdleUPP)(userRoutine)
#endif

typedef pascal Boolean (*AEFilterProcPtr)(EventRecord *theEvent, long returnID, long transactionID, const AEAddressDesc *sender);

enum {
	uppAEFilterProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(EventRecord*)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(AEAddressDesc*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr AEFilterUPP;

#define CallAEFilterProc(userRoutine, theEvent, returnID, transactionID, sender)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAEFilterProcInfo, (theEvent), (returnID), (transactionID), (sender))
#define NewAEFilterProc(userRoutine)		\
		(AEFilterUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppAEFilterProcInfo, GetCurrentISA())
#else
typedef AEFilterProcPtr AEFilterUPP;

#define CallAEFilterProc(userRoutine, theEvent, returnID, transactionID, sender)		\
		(*(userRoutine))((theEvent), (returnID), (transactionID), (sender))
#define NewAEFilterProc(userRoutine)		\
		(AEFilterUPP)(userRoutine)
#endif

typedef pascal OSErr (*AEEventHandlerProcPtr)(const AppleEvent *theAppleEvent, AppleEvent *reply, long handlerRefcon);

enum {
	uppAEEventHandlerProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(AppleEvent*)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(AppleEvent*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr AEEventHandlerUPP;

#define CallAEEventHandlerProc(userRoutine, theAppleEvent, reply, handlerRefcon)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAEEventHandlerProcInfo, (theAppleEvent), (reply), (handlerRefcon))
#define NewAEEventHandlerProc(userRoutine)		\
		(AEEventHandlerUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppAEEventHandlerProcInfo, GetCurrentISA())
#else
typedef AEEventHandlerProcPtr AEEventHandlerUPP;

#define CallAEEventHandlerProc(userRoutine, theAppleEvent, reply, handlerRefcon)		\
		(*(userRoutine))((theAppleEvent), (reply), (handlerRefcon))
#define NewAEEventHandlerProc(userRoutine)		\
		(AEEventHandlerUPP)(userRoutine)
#endif

typedef pascal OSErr (*AECoerceDescProcPtr)(const AEDesc *fromDesc, DescType toType, long handlerRefcon, AEDesc *toDesc);

enum {
	uppAECoerceDescProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(AEDesc*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr AECoerceDescUPP;

#define CallAECoerceDescProc(userRoutine, fromDesc, toType, handlerRefcon, toDesc)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAECoerceDescProcInfo, (fromDesc), (toType), (handlerRefcon), (toDesc))
#define NewAECoerceDescProc(userRoutine)		\
		(AECoerceDescUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppAECoerceDescProcInfo, GetCurrentISA())
#else
typedef AECoerceDescProcPtr AECoerceDescUPP;

#define CallAECoerceDescProc(userRoutine, fromDesc, toType, handlerRefcon, toDesc)		\
		(*(userRoutine))((fromDesc), (toType), (handlerRefcon), (toDesc))
#define NewAECoerceDescProc(userRoutine)		\
		(AECoerceDescUPP)(userRoutine)
#endif

typedef pascal OSErr (*AECoercePtrProcPtr)(DescType typeCode, const void *dataPtr, Size dataSize, DescType toType, long handlerRefcon, AEDesc *result);

enum {
	uppAECoercePtrProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(void*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(Size)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(AEDesc*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr AECoercePtrUPP;

#define CallAECoercePtrProc(userRoutine, typeCode, dataPtr, dataSize, toType, handlerRefcon, result)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppAECoercePtrProcInfo, (typeCode), (dataPtr), (dataSize), (toType), (handlerRefcon), (result))
#define NewAECoercePtrProc(userRoutine)		\
		(AECoercePtrUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppAECoercePtrProcInfo, GetCurrentISA())
#else
typedef AECoercePtrProcPtr AECoercePtrUPP;

#define CallAECoercePtrProc(userRoutine, typeCode, dataPtr, dataSize, toType, handlerRefcon, result)		\
		(*(userRoutine))((typeCode), (dataPtr), (dataSize), (toType), (handlerRefcon), (result))
#define NewAECoercePtrProc(userRoutine)		\
		(AECoercePtrUPP)(userRoutine)
#endif

typedef UniversalProcPtr AECoercionHandlerUPP;


/*--------------------------------------------------------------
		Apple event manager error messages
--------------------------------------------------------------*/

enum  {
	errAECoercionFail			= -1700,						/* bad parameter data or unable to coerce the data supplied */
	errAEDescNotFound			= -1701,
	errAECorruptData			= -1702,
	errAEWrongDataType			= -1703,
	errAENotAEDesc				= -1704,
	errAEBadListItem			= -1705,						/* the specified list item does not exist */
	errAENewerVersion			= -1706,						/* need newer version of the AppleEvent manager */
	errAENotAppleEvent			= -1707,						/* the event is not in AppleEvent format */
	errAEEventNotHandled		= -1708,						/* the AppleEvent was not handled by any handler */
	errAEReplyNotValid			= -1709,						/* AEResetTimer was passed an invalid reply parameter */
	errAEUnknownSendMode		= -1710,						/* mode wasn't NoReply, WaitReply, or QueueReply or Interaction level is unknown */
	errAEWaitCanceled			= -1711,						/* in AESend, the user cancelled out of wait loop for reply or receipt */
	errAETimeout				= -1712,						/* the AppleEvent timed out */
	errAENoUserInteraction		= -1713,						/* no user interaction is allowed */
	errAENotASpecialFunction	= -1714,						/* there is no special function for/with this keyword */
	errAEParamMissed			= -1715,						/* a required parameter was not accessed */
	errAEUnknownAddressType		= -1716,						/* the target address type is not known */
	errAEHandlerNotFound		= -1717,						/* no handler in the dispatch tables fits the parameters to AEGetEventHandler or AEGetCoercionHandler */
	errAEReplyNotArrived		= -1718							/* the contents of the reply you are accessing have not arrived yet */
};

enum  {
	errAEIllegalIndex			= -1719,						/* index is out of range in a put operation */
	errAEUnknownObjectType		= -1731,						/* available only in version 1.0.1 or greater */
	errAERecordingIsAlreadyOn	= -1732							/* available only in version 1.0.1 or greater */
};

#ifdef __cplusplus
extern "C" {
#endif


/**************************************************************************
 The following calls apply to any AEDesc. Every 'result' descriptor is
 created for you, so you will be responsible for memory management
 (including disposing) of the descriptors so created. Note: purgeable
 descriptor data is not supported - the AEM does not call LoadResource.  
**************************************************************************/

extern pascal OSErr AECreateDesc(DescType typeCode, const void *dataPtr, Size dataSize, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0825, 0xA816);
extern pascal OSErr AECoercePtr(DescType typeCode, const void *dataPtr, Size dataSize, DescType toType, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0A02, 0xA816);
extern pascal OSErr AECoerceDesc(const AEDesc *theAEDesc, DescType toType, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0603, 0xA816);
extern pascal OSErr AEDisposeDesc(AEDesc *theAEDesc)
 THREEWORDINLINE(0x303C, 0x0204, 0xA816);
extern pascal OSErr AEDuplicateDesc(const AEDesc *theAEDesc, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0405, 0xA816);

/**************************************************************************
  The following calls apply to AEDescList. Since AEDescList is a subtype of
  AEDesc, the calls in the previous section can also be used for AEDescList.
  All list and array indices are 1-based. If the data was greater than
  maximumSize in the routines below, then actualSize will be greater than
  maximumSize, but only maximumSize bytes will actually be retrieved.
**************************************************************************/

extern pascal OSErr AECreateList(const void *factoringPtr, Size factoredSize, Boolean isRecord, AEDescList *resultList)
 THREEWORDINLINE(0x303C, 0x0706, 0xA816);
extern pascal OSErr AECountItems(const AEDescList *theAEDescList, long *theCount)
 THREEWORDINLINE(0x303C, 0x0407, 0xA816);
extern pascal OSErr AEPutPtr(const AEDescList *theAEDescList, long index, DescType typeCode, const void *dataPtr, Size dataSize)
 THREEWORDINLINE(0x303C, 0x0A08, 0xA816);
extern pascal OSErr AEPutDesc(const AEDescList *theAEDescList, long index, const AEDesc *theAEDesc)
 THREEWORDINLINE(0x303C, 0x0609, 0xA816);
extern pascal OSErr AEGetNthPtr(const AEDescList *theAEDescList, long index, DescType desiredType, AEKeyword *theAEKeyword, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
 THREEWORDINLINE(0x303C, 0x100A, 0xA816);
extern pascal OSErr AEGetNthDesc(const AEDescList *theAEDescList, long index, DescType desiredType, AEKeyword *theAEKeyword, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0A0B, 0xA816);
extern pascal OSErr AESizeOfNthItem(const AEDescList *theAEDescList, long index, DescType *typeCode, Size *dataSize)
 THREEWORDINLINE(0x303C, 0x082A, 0xA816);
extern pascal OSErr AEGetArray(const AEDescList *theAEDescList, AEArrayType arrayType, AEArrayDataPointer arrayPtr, Size maximumSize, DescType *itemType, Size *itemSize, long *itemCount)
 THREEWORDINLINE(0x303C, 0x0D0C, 0xA816);
extern pascal OSErr AEPutArray(const AEDescList *theAEDescList, AEArrayType arrayType, const AEArrayData *arrayPtr, DescType itemType, Size itemSize, long itemCount)
 THREEWORDINLINE(0x303C, 0x0B0D, 0xA816);
extern pascal OSErr AEDeleteItem(const AEDescList *theAEDescList, long index)
 THREEWORDINLINE(0x303C, 0x040E, 0xA816);

/**************************************************************************
 The following calls apply to AERecord. Since AERecord is a subtype of
 AEDescList, the calls in the previous sections can also be used for
 AERecord an AERecord can be created by using AECreateList with isRecord
 set to true. 
 
 NOTE: These calls are duplicately named, so their implementation has
 been changed to a macro which calls the duplicate function.
**************************************************************************/

#define AEPutKeyPtr(theAERecord, theAEKeyword, typeCode, dataPtr, dataSize)  \
	AEPutParamPtr((theAERecord), (theAEKeyword), (typeCode), (dataPtr), (dataSize))

#define AEPutKeyDesc(theAERecord, theAEKeyword, theAEDesc)  \
	AEPutParamDesc((theAERecord), (theAEKeyword), (theAEDesc))

#define AEGetKeyPtr(theAERecord, theAEKeyword, desiredType, typeCode, dataPtr, maxSize, actualSize)  \
	AEGetParamPtr((theAERecord), (theAEKeyword), (desiredType), (typeCode), (dataPtr), (maxSize), (actualSize))

#define AEGetKeyDesc(theAERecord, theAEKeyword, desiredType, result)  \
	AEGetParamDesc((theAERecord), (theAEKeyword), (desiredType), (result))

#define AESizeOfKeyDesc(theAERecord, theAEKeyword, typeCode, dataSize)  \
	AESizeOfParam((theAERecord), (theAEKeyword), (typeCode), (dataSize))

#define AEDeleteKeyDesc(theAERecord, theAEKeyword)  \
	AEDeleteParam((theAERecord), (theAEKeyword))


/**************************************************************************
  The following calls are used to pack and unpack parameters from records
  of type AppleEvent. Since AppleEvent is a subtype of AERecord, the calls
  in the previous sections can also be used for variables of type
  AppleEvent. The next six calls are in fact identical to the six calls
  for AERecord.
**************************************************************************/

extern pascal OSErr AEPutParamPtr(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType typeCode, const void *dataPtr, Size dataSize)
 THREEWORDINLINE(0x303C, 0x0A0F, 0xA816);
extern pascal OSErr AEPutParamDesc(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, const AEDesc *theAEDesc)
 THREEWORDINLINE(0x303C, 0x0610, 0xA816);
extern pascal OSErr AEGetParamPtr(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
 THREEWORDINLINE(0x303C, 0x0E11, 0xA816);
extern pascal OSErr AEGetParamDesc(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0812, 0xA816);
extern pascal OSErr AESizeOfParam(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType *typeCode, Size *dataSize)
 THREEWORDINLINE(0x303C, 0x0829, 0xA816);
extern pascal OSErr AEDeleteParam(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword)
 THREEWORDINLINE(0x303C, 0x0413, 0xA816);

/**************************************************************************
 The following calls also apply to type AppleEvent. Message attributes are
 far more restricted, and can only be accessed through the following 5
 calls. The various list and record routines cannot be used to access the
 attributes of an event. 
**************************************************************************/

extern pascal OSErr AEGetAttributePtr(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, DescType *typeCode, void *dataPtr, Size maximumSize, Size *actualSize)
 THREEWORDINLINE(0x303C, 0x0E15, 0xA816);
extern pascal OSErr AEGetAttributeDesc(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType desiredType, AEDesc *result)
 THREEWORDINLINE(0x303C, 0x0826, 0xA816);
extern pascal OSErr AESizeOfAttribute(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType *typeCode, Size *dataSize)
 THREEWORDINLINE(0x303C, 0x0828, 0xA816);
extern pascal OSErr AEPutAttributePtr(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, DescType typeCode, const void *dataPtr, Size dataSize)
 THREEWORDINLINE(0x303C, 0x0A16, 0xA816);
extern pascal OSErr AEPutAttributeDesc(const AppleEvent *theAppleEvent, AEKeyword theAEKeyword, const AEDesc *theAEDesc)
 THREEWORDINLINE(0x303C, 0x0627, 0xA816);

/**************************************************************************
  The next couple of calls are basic routines used to create, send,
  and process AppleEvents. 
**************************************************************************/

extern pascal OSErr AECreateAppleEvent(AEEventClass theAEEventClass, AEEventID theAEEventID, const AEAddressDesc *target, short returnID, long transactionID, AppleEvent *result)
 THREEWORDINLINE(0x303C, 0x0B14, 0xA816);
extern pascal OSErr AESend(const AppleEvent *theAppleEvent, AppleEvent *reply, AESendMode sendMode, AESendPriority sendPriority, long timeOutInTicks, AEIdleUPP idleProc, AEFilterUPP filterProc)
 THREEWORDINLINE(0x303C, 0x0D17, 0xA816);
extern pascal OSErr AEProcessAppleEvent(const EventRecord *theEventRecord)
 THREEWORDINLINE(0x303C, 0x021B, 0xA816);

/* 
 Note: during event processing, an event handler may realize that it is likely
 to exceed the client's timeout limit. Passing the reply to this
 routine causes a wait event to be generated that asks the client
 for more time. 
*/

extern pascal OSErr AEResetTimer(const AppleEvent *reply)
 THREEWORDINLINE(0x303C, 0x0219, 0xA816);

/**************************************************************************
 The following four calls are available for applications which need more
 sophisticated control over when and how events are processed. Applications
 which implement multi-session servers or which implement their own
 internal event queueing will probably be the major clients of these
 routines. They can be called from within a handler to prevent the AEM from
 disposing of the AppleEvent when the handler returns. They can be used to
 asynchronously process the event (as MacApp does).
**************************************************************************/

extern pascal OSErr AESuspendTheCurrentEvent(const AppleEvent *theAppleEvent)
 THREEWORDINLINE(0x303C, 0x022B, 0xA816);

/* 
 Note: The following routine tells the AppleEvent manager that processing
 is either about to resume or has been completed on a previously suspended
 event. The procPtr passed in as the dispatcher parameter will be called to
 attempt to redispatch the event. Several constants for the dispatcher
 parameter allow special behavior. They are:
  	- kAEUseStandardDispatch means redispatch as if the event was just
	  received, using the standard AppleEvent dispatch mechanism.
  	- kAENoDispatch means ignore the parameter.
   	  Use this in the case where the event has been handled and no
	  redispatch is needed.
  	- non nil means call the routine which the dispatcher points to.
*/

extern pascal OSErr AEResumeTheCurrentEvent(const AppleEvent *theAppleEvent, const AppleEvent *reply, AEEventHandlerUPP dispatcher, long handlerRefcon)
 THREEWORDINLINE(0x303C, 0x0818, 0xA816);
extern pascal OSErr AEGetTheCurrentEvent(AppleEvent *theAppleEvent)
 THREEWORDINLINE(0x303C, 0x021A, 0xA816);
extern pascal OSErr AESetTheCurrentEvent(const AppleEvent *theAppleEvent)
 THREEWORDINLINE(0x303C, 0x022C, 0xA816);

/**************************************************************************
  The following three calls are used to allow applications to behave
  courteously when a user interaction such as a dialog box is needed. 
**************************************************************************/

extern pascal OSErr AEGetInteractionAllowed(AEInteractAllowed *level)
 THREEWORDINLINE(0x303C, 0x021D, 0xA816);
extern pascal OSErr AESetInteractionAllowed(AEInteractAllowed level)
 THREEWORDINLINE(0x303C, 0x011E, 0xA816);
extern pascal OSErr AEInteractWithUser(long timeOutInTicks, NMRecPtr nmReqPtr, AEIdleUPP idleProc)
 THREEWORDINLINE(0x303C, 0x061C, 0xA816);

/**************************************************************************
  These calls are used to set up and modify the event dispatch table.
**************************************************************************/

extern pascal OSErr AEInstallEventHandler(AEEventClass theAEEventClass, AEEventID theAEEventID, AEEventHandlerUPP handler, long handlerRefcon, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x091F, 0xA816);
extern pascal OSErr AERemoveEventHandler(AEEventClass theAEEventClass, AEEventID theAEEventID, AEEventHandlerUPP handler, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0720, 0xA816);
extern pascal OSErr AEGetEventHandler(AEEventClass theAEEventClass, AEEventID theAEEventID, AEEventHandlerUPP *handler, long *handlerRefcon, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0921, 0xA816);

/**************************************************************************
  These calls are used to set up and modify the coercion dispatch table.
**************************************************************************/

extern pascal OSErr AEInstallCoercionHandler(DescType fromType, DescType toType, AECoercionHandlerUPP handler, long handlerRefcon, Boolean fromTypeIsDesc, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0A22, 0xA816);
extern pascal OSErr AERemoveCoercionHandler(DescType fromType, DescType toType, AECoercionHandlerUPP handler, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0723, 0xA816);
extern pascal OSErr AEGetCoercionHandler(DescType fromType, DescType toType, AECoercionHandlerUPP *handler, long *handlerRefcon, Boolean *fromTypeIsDesc, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0B24, 0xA816);

/**************************************************************************
  These calls are used to set up and modify special hooks into the
  AppleEvent manager.
**************************************************************************/

extern pascal OSErr AEInstallSpecialHandler(AEKeyword functionClass, UniversalProcPtr handler, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0500, 0xA816);
extern pascal OSErr AERemoveSpecialHandler(AEKeyword functionClass, UniversalProcPtr handler, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0501, 0xA816);
extern pascal OSErr AEGetSpecialHandler(AEKeyword functionClass, UniversalProcPtr *handler, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x052D, 0xA816);

/**************************************************************************
  This call was added in version 1.0.1. If called with the keyword
  keyAERecorderCount ('recr'), the number of recorders that are
  currently active is returned in 'result'.
**************************************************************************/


/* available only in vers 1.0.1 and greater */

extern pascal OSErr AEManagerInfo(AEKeyword keyWord, long *result)
 THREEWORDINLINE(0x303C, 0x0441, 0xA816);
#ifdef __cplusplus
}
#endif

#endif

