/*
	File:		Sound.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __SOUND__
#define __SOUND__

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

#define synthCodeRsrc 'snth'				/* Resource types used by Sound Manager */
#define soundListRsrc 'snd '

#define kSoundHardwareType 'sdev'

#define twelfthRootTwo 1.05946309434

enum  {
	swMode						= -1,							/*Sound Driver modes*/
	ftMode						= 1,
	ffMode						= 0,
	rate44khz					= (long)0xAC440000,				/*44100.00000 in fixed-point*/
	rate22khz					= (long)0x56EE8BA3,				/*22254.54545 in fixed-point*/
	rate11khz					= (long)0x2B7745D1,				/*11127.27273 in fixed-point*/
/*synthesizer numbers for SndNewChannel*/
	squareWaveSynth				= 1,							/*square wave synthesizer*/
	waveTableSynth				= 3,							/*wave table synthesizer*/
	sampledSynth				= 5,							/*sampled sound synthesizer*/
/*old Sound Manager MACE synthesizer numbers*/
	MACE3snthID					= 11,
	MACE6snthID					= 13,
	kMiddleC					= 60,							/*MIDI note value for middle C*/
	kSimpleBeepID				= 1,							/*reserved resource ID for Simple Beep*/
	kFullVolume					= 0x0100,						/*1.0, setting for full hardware output volume*/
	kNoVolume					= 0,							/*setting for no sound volume*/
/*command numbers for SndDoCommand and SndDoImmediate*/
	nullCmd						= 0,
	initCmd						= 1,
	freeCmd						= 2,
	quietCmd					= 3,
	flushCmd					= 4,
	reInitCmd					= 5,
	waitCmd						= 10,
	pauseCmd					= 11,
	resumeCmd					= 12,
	callBackCmd					= 13
};

enum  {
	syncCmd						= 14,
	availableCmd				= 24,
	versionCmd					= 25,
	totalLoadCmd				= 26,
	loadCmd						= 27,
	freqDurationCmd				= 40,
	restCmd						= 41,
	freqCmd						= 42,
	ampCmd						= 43,
	timbreCmd					= 44,
	getAmpCmd					= 45,
	volumeCmd					= 46,							/*sound manager 3.0 or later only*/
	getVolumeCmd				= 47,							/*sound manager 3.0 or later only*/
	waveTableCmd				= 60,
	phaseCmd					= 61
};

enum  {
	soundCmd					= 80,
	bufferCmd					= 81,
	rateCmd						= 82,
	continueCmd					= 83,
	doubleBufferCmd				= 84,
	getRateCmd					= 85,
	sizeCmd						= 90,
	convertCmd					= 91,
	stdQLength					= 128,
	dataOffsetFlag				= 0x8000,
/*channel initialization parameters*/
	waveInitChannelMask			= 0x07,
	waveInitChannel0			= 0x04,							/*wave table only, Sound Manager 2.0 and earlier*/
	waveInitChannel1			= 0x05,							/*wave table only, Sound Manager 2.0 and earlier*/
	waveInitChannel2			= 0x06,							/*wave table only, Sound Manager 2.0 and earlier*/
	waveInitChannel3			= 0x07,							/*wave table only, Sound Manager 2.0 and earlier*/
	initChan0					= waveInitChannel0,				/*obsolete spelling*/
	initChan1					= waveInitChannel1,				/*obsolete spelling*/
	initChan2					= waveInitChannel2,				/*obsolete spelling*/
	initChan3					= waveInitChannel3,				/*obsolete spelling*/
	initPanMask					= 0x0003,						/*mask for right/left pan values*/
	initSRateMask				= 0x0030,						/*mask for sample rate values*/
	initStereoMask				= 0x00C0,						/*mask for mono/stereo values*/
	initCompMask				= 0xFF00						/*mask for compression IDs*/
};

enum  {
	initChanLeft				= 0x0002,						/*left stereo channel*/
	initChanRight				= 0x0003,						/*right stereo channel*/
	initNoInterp				= 0x0004,						/*no linear interpolation*/
	initNoDrop					= 0x0008,						/*no drop-sample conversion*/
	initMono					= 0x0080,						/*monophonic channel*/
	initStereo					= 0x00C0,						/*stereo channel*/
	initMACE3					= 0x0300,						/*MACE 3:1*/
	initMACE6					= 0x0400,						/*MACE 6:1*/
	kUseOptionalOutputDevice	= -1,							/*only for Sound Manager 3.0 or later*/
	stdSH						= 0x00,							/*Standard sound header encode value*/
	extSH						= 0xFF,							/*Extended sound header encode value*/
	cmpSH						= 0xFE,							/*Compressed sound header encode value*/
	notCompressed				= 0,							/*compression ID's*/
	fixedCompression			= -1,							/*compression ID for fixed-sized compression*/
	variableCompression			= -2,							/*compression ID for variable-sized compression*/
	twoToOne					= 1,
	eightToThree				= 2,
	threeToOne					= 3,
	sixToOne					= 4,
	outsideCmpSH				= 0								/*MACE constants*/
};

enum  {
	insideCmpSH					= 1,
	aceSuccess					= 0,
	aceMemFull					= 1,
	aceNilBlock					= 2,
	aceBadComp					= 3,
	aceBadEncode				= 4,
	aceBadDest					= 5,
	aceBadCmd					= 6,
	sixToOnePacketSize			= 8,
	threeToOnePacketSize		= 16,
	stateBlockSize				= 64,
	leftOverBlockSize			= 32,
	firstSoundFormat			= 0x0001,						/*general sound format*/
	secondSoundFormat			= 0x0002,						/*special sampled sound format (HyperCard)*/
	dbBufferReady				= 0x00000001,					/*double buffer is filled*/
	dbLastBuffer				= 0x00000004,					/*last double buffer to play*/
	sysBeepDisable				= 0x0000,						/*SysBeep() enable flags*/
	sysBeepEnable				= 0x0001,
	unitTypeNoSelection			= 0xFFFF,						/*unitTypes for AudioSelection.unitType*/
	unitTypeSeconds				= 0x0000
};


/*Structures for Sound Driver*/

typedef unsigned char FreeWave[30001];

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FFSynthRec {
	short						mode;
	Fixed						count;
	FreeWave					waveBytes;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FFSynthRec FFSynthRec;

typedef FFSynthRec *FFSynthPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct Tone {
	short						count;
	short						amplitude;
	short						duration;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct Tone Tone;

typedef Tone Tones[5001];

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SWSynthRec {
	short						mode;
	Tones						triplets;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SWSynthRec SWSynthRec;

typedef SWSynthRec *SWSynthPtr;

typedef unsigned char Wave[256];

typedef Wave *WavePtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FTSoundRec {
	short						duration;
	Fixed						sound1Rate;
	long						sound1Phase;
	Fixed						sound2Rate;
	long						sound2Phase;
	Fixed						sound3Rate;
	long						sound3Phase;
	Fixed						sound4Rate;
	long						sound4Phase;
	WavePtr						sound1Wave;
	WavePtr						sound2Wave;
	WavePtr						sound3Wave;
	WavePtr						sound4Wave;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FTSoundRec FTSoundRec;

typedef FTSoundRec *FTSndRecPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FTSynthRec {
	short						mode;
	FTSndRecPtr					sndRec;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FTSynthRec FTSynthRec;

typedef FTSynthRec *FTSynthPtr;

typedef pascal void (*SndCompletionProcPtr)(void);

enum {
	uppSndCompletionProcInfo = kPascalStackBased
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr SndCompletionUPP;

#define CallSndCompletionProc(userRoutine)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSndCompletionProcInfo)
#define NewSndCompletionProc(userRoutine)		\
		(SndCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSndCompletionProcInfo, GetCurrentISA())
#else
typedef SndCompletionProcPtr SndCompletionUPP;

#define CallSndCompletionProc(userRoutine)		\
		(*(userRoutine))()
#define NewSndCompletionProc(userRoutine)		\
		(SndCompletionUPP)(userRoutine)
#endif


/*Structures for Sound Manager*/

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SndCommand {
	unsigned short				cmd;
	short						param1;
	long						param2;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SndCommand SndCommand;

typedef struct SndChannel SndChannel;

typedef SndChannel *SndChannelPtr;

typedef pascal void (*SndCallBackProcPtr)(SndChannelPtr chan, SndCommand *cmd);

enum {
	uppSndCallBackProcInfo = kPascalStackBased
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SndChannelPtr)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(SndCommand*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr SndCallBackUPP;

#define CallSndCallBackProc(userRoutine, chan, cmd)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSndCallBackProcInfo, (chan), (cmd))
#define NewSndCallBackProc(userRoutine)		\
		(SndCallBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSndCallBackProcInfo, GetCurrentISA())
#else
typedef SndCallBackProcPtr SndCallBackUPP;

#define CallSndCallBackProc(userRoutine, chan, cmd)		\
		(*(userRoutine))((chan), (cmd))
#define NewSndCallBackProc(userRoutine)		\
		(SndCallBackUPP)(userRoutine)
#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SndChannel {
	struct SndChannel			*nextChan;
	Ptr							firstMod;						/* reserved for the Sound Manager */
	SndCallBackUPP				callBack;
	long						userInfo;
	long						wait;							/* The following is for internal Sound Manager use only.*/
	SndCommand					cmdInProgress;
	short						flags;
	short						qLength;
	short						qHead;
	short						qTail;
	SndCommand					queue[stdQLength];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif


/*MACE structures*/

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct StateBlock {
	short						stateVar[stateBlockSize];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct StateBlock StateBlock;

typedef StateBlock *StateBlockPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct LeftOverBlock {
	unsigned long				count;
	char						sampleArea[leftOverBlockSize];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct LeftOverBlock LeftOverBlock;

typedef LeftOverBlock *LeftOverBlockPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct ModRef {
	unsigned short				modNumber;
	long						modInit;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct ModRef ModRef;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SndListResource {
	short						format;
	short						numModifiers;
	ModRef						modifierPart[1];				/*This is a variable length array*/
	short						numCommands;
	SndCommand					commandPart[1];					/*This is a variable length array*/
	char						dataPart[1];					/*This is a variable length array*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SndListResource SndListResource;

typedef SndListResource *SndListPtr;

typedef SndListPtr *SndListHndl;


/*HyperCard sound resource format*/

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct Snd2ListResource {
	short						format;
	short						refCount;
	short						numCommands;
	SndCommand					commandPart[1];					/*This is a variable length array*/
	char						dataPart[1];					/*This is a variable length array*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct Snd2ListResource Snd2ListResource;

typedef Snd2ListResource *Snd2ListPtr;

typedef Snd2ListPtr *Snd2ListHndl;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SoundHeader {
	Ptr							samplePtr;						/*if NIL then samples are in sampleArea*/
	unsigned long				length;							/*length of sound in bytes*/
	Fixed						sampleRate;						/*sample rate for this sound*/
	unsigned long				loopStart;						/*start of looping portion*/
	unsigned long				loopEnd;						/*end of looping portion*/
	unsigned char				encode;							/*header encoding*/
	unsigned char				baseFrequency;					/*baseFrequency value*/
	unsigned char				sampleArea[1];					/*space for when samples follow directly*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SoundHeader SoundHeader;

typedef SoundHeader *SoundHeaderPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct CmpSoundHeader {
	Ptr							samplePtr;						/*if nil then samples are in sample area*/
	unsigned long				numChannels;					/*number of channels i.e. mono = 1*/
	Fixed						sampleRate;						/*sample rate in Apples Fixed point representation*/
	unsigned long				loopStart;						/*loopStart of sound before compression*/
	unsigned long				loopEnd;						/*loopEnd of sound before compression*/
	unsigned char				encode;							/*data structure used , stdSH, extSH, or cmpSH*/
	unsigned char				baseFrequency;					/*same meaning as regular SoundHeader*/
	unsigned long				numFrames;						/*length in frames ( packetFrames or sampleFrames )*/
	extended80					AIFFSampleRate;					/*IEEE sample rate*/
	Ptr							markerChunk;					/*sync track*/
	OSType						format;							/*data format type, was futureUse1*/
	unsigned long				futureUse2;						/*reserved by Apple*/
	StateBlockPtr				stateVars;						/*pointer to State Block*/
	LeftOverBlockPtr			leftOverSamples;				/*used to save truncated samples between compression calls*/
	unsigned short				compressionID;					/*0 means no compression, non zero means compressionID*/
	unsigned short				packetSize;						/*number of bits in compressed sample packet*/
	unsigned short				snthID;							/*resource ID of Sound Manager snth that contains NRT C/E*/
	unsigned short				sampleSize;						/*number of bits in non-compressed sample*/
	unsigned char				sampleArea[1];					/*space for when samples follow directly*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct CmpSoundHeader CmpSoundHeader;

typedef CmpSoundHeader *CmpSoundHeaderPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct ExtSoundHeader {
	Ptr							samplePtr;						/*if nil then samples are in sample area*/
	unsigned long				numChannels;					/*number of channels,  ie mono = 1*/
	Fixed						sampleRate;						/*sample rate in Apples Fixed point representation*/
	unsigned long				loopStart;						/*same meaning as regular SoundHeader*/
	unsigned long				loopEnd;						/*same meaning as regular SoundHeader*/
	unsigned char				encode;							/*data structure used , stdSH, extSH, or cmpSH*/
	unsigned char				baseFrequency;					/*same meaning as regular SoundHeader*/
	unsigned long				numFrames;						/*length in total number of frames*/
	extended80					AIFFSampleRate;					/*IEEE sample rate*/
	Ptr							markerChunk;					/*sync track*/
	Ptr							instrumentChunks;				/*AIFF instrument chunks*/
	Ptr							AESRecording;
	unsigned short				sampleSize;						/*number of bits in sample*/
	unsigned short				futureUse1;						/*reserved by Apple*/
	unsigned long				futureUse2;						/*reserved by Apple*/
	unsigned long				futureUse3;						/*reserved by Apple*/
	unsigned long				futureUse4;						/*reserved by Apple*/
	unsigned char				sampleArea[1];					/*space for when samples follow directly*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct ExtSoundHeader ExtSoundHeader;

typedef ExtSoundHeader *ExtSoundHeaderPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct ConversionBlock {
	short						destination;
	short						unused;
	CmpSoundHeaderPtr			inputPtr;
	CmpSoundHeaderPtr			outputPtr;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct ConversionBlock ConversionBlock;

typedef ConversionBlock *ConversionBlockPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SMStatus {
	short						smMaxCPULoad;
	short						smNumChannels;
	short						smCurCPULoad;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SMStatus SMStatus;

typedef SMStatus *SMStatusPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SCStatus {
	Fixed						scStartTime;
	Fixed						scEndTime;
	Fixed						scCurrentTime;
	Boolean						scChannelBusy;
	Boolean						scChannelDisposed;
	Boolean						scChannelPaused;
	Boolean						scUnused;
	unsigned long				scChannelAttributes;
	long						scCPULoad;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SCStatus SCStatus;

typedef SCStatus *SCStatusPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct AudioSelection {
	long						unitType;
	Fixed						selStart;
	Fixed						selEnd;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef pascal void (*FilePlayCompletionProcPtr)(SndChannelPtr chan);

enum {
	uppFilePlayCompletionProcInfo = kPascalStackBased
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SndChannelPtr)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr FilePlayCompletionUPP;

#define CallFilePlayCompletionProc(userRoutine, chan)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppFilePlayCompletionProcInfo, (chan))
#define NewFilePlayCompletionProc(userRoutine)		\
		(FilePlayCompletionUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppFilePlayCompletionProcInfo, GetCurrentISA())
#else
typedef FilePlayCompletionProcPtr FilePlayCompletionUPP;

#define CallFilePlayCompletionProc(userRoutine, chan)		\
		(*(userRoutine))((chan))
#define NewFilePlayCompletionProc(userRoutine)		\
		(FilePlayCompletionUPP)(userRoutine)
#endif

typedef struct AudioSelection AudioSelection;

typedef AudioSelection *AudioSelectionPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SndDoubleBuffer {
	long						dbNumFrames;
	long						dbFlags;
	long						dbUserInfo[2];
	char						dbSoundData[1];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SndDoubleBuffer SndDoubleBuffer;

typedef SndDoubleBuffer *SndDoubleBufferPtr;

typedef pascal void (*SndDoubleBackProcPtr)(SndChannelPtr channel, SndDoubleBufferPtr doubleBufferPtr);

enum {
	uppSndDoubleBackProcInfo = kPascalStackBased
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(SndChannelPtr)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(SndDoubleBufferPtr)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr SndDoubleBackUPP;

#define CallSndDoubleBackProc(userRoutine, channel, doubleBufferPtr)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppSndDoubleBackProcInfo, (channel), (doubleBufferPtr))
#define NewSndDoubleBackProc(userRoutine)		\
		(SndDoubleBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSndDoubleBackProcInfo, GetCurrentISA())
#else
typedef SndDoubleBackProcPtr SndDoubleBackUPP;

#define CallSndDoubleBackProc(userRoutine, channel, doubleBufferPtr)		\
		(*(userRoutine))((channel), (doubleBufferPtr))
#define NewSndDoubleBackProc(userRoutine)		\
		(SndDoubleBackUPP)(userRoutine)
#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SndDoubleBufferHeader {
	short						dbhNumChannels;
	short						dbhSampleSize;
	short						dbhCompressionID;
	short						dbhPacketSize;
	Fixed						dbhSampleRate;
	SndDoubleBufferPtr			dbhBufferPtr[2];
	SndDoubleBackUPP			dbhDoubleBack;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SndDoubleBufferHeader SndDoubleBufferHeader;

typedef SndDoubleBufferHeader *SndDoubleBufferHeaderPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SndDoubleBufferHeader2 {
	short						dbhNumChannels;
	short						dbhSampleSize;
	short						dbhCompressionID;
	short						dbhPacketSize;
	Fixed						dbhSampleRate;
	SndDoubleBufferPtr			dbhBufferPtr[2];
	SndDoubleBackUPP			dbhDoubleBack;
	OSType						dbhFormat;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SndDoubleBufferHeader2 SndDoubleBufferHeader2;

typedef SndDoubleBufferHeader2 *SndDoubleBufferHeader2Ptr;

#ifdef __cplusplus
extern "C" {
#endif

extern pascal OSErr SndDoCommand(SndChannelPtr chan, const SndCommand *cmd, Boolean noWait)
 ONEWORDINLINE(0xA803);
extern pascal OSErr SndDoImmediate(SndChannelPtr chan, const SndCommand *cmd)
 ONEWORDINLINE(0xA804);
extern pascal OSErr SndNewChannel(SndChannelPtr *chan, short synth, long init, SndCallBackUPP userRoutine)
 ONEWORDINLINE(0xA807);
extern pascal OSErr SndDisposeChannel(SndChannelPtr chan, Boolean quietNow)
 ONEWORDINLINE(0xA801);
extern pascal OSErr SndPlay(SndChannelPtr chan, Handle sndHdl, Boolean async)
 ONEWORDINLINE(0xA805);
extern pascal OSErr SndAddModifier(SndChannelPtr chan, Ptr modifier, short id, long init)
 ONEWORDINLINE(0xA802);
extern pascal OSErr SndControl(short id, SndCommand *cmd)
 ONEWORDINLINE(0xA806);
extern pascal void SetSoundVol(short level);

#if USES68KINLINES
#pragma parameter  GetSoundVol(__A0)
#endif
extern pascal void GetSoundVol(short *level)
 THREEWORDINLINE(0x4218, 0x10B8, 0x0260);
extern pascal NumVersion SndSoundManagerVersion(void)
 FOURWORDINLINE(0x203C, 0x000C, 0x0008, 0xA800);
extern pascal OSErr SndStartFilePlay(SndChannelPtr chan, short fRefNum, short resNum, long bufferSize, void *theBuffer, AudioSelectionPtr theSelection, FilePlayCompletionUPP theCompletion, Boolean async)
 FOURWORDINLINE(0x203C, 0x0D00, 0x0008, 0xA800);
extern pascal OSErr SndPauseFilePlay(SndChannelPtr chan)
 FOURWORDINLINE(0x203C, 0x0204, 0x0008, 0xA800);
extern pascal OSErr SndStopFilePlay(SndChannelPtr chan, Boolean quietNow)
 FOURWORDINLINE(0x203C, 0x0308, 0x0008, 0xA800);
extern pascal OSErr SndChannelStatus(SndChannelPtr chan, short theLength, SCStatusPtr theStatus)
 FOURWORDINLINE(0x203C, 0x0010, 0x0008, 0xA800);
extern pascal OSErr SndManagerStatus(short theLength, SMStatusPtr theStatus)
 FOURWORDINLINE(0x203C, 0x0014, 0x0008, 0xA800);
extern pascal void SndGetSysBeepState(short *sysBeepState)
 FOURWORDINLINE(0x203C, 0x0018, 0x0008, 0xA800);
extern pascal OSErr SndSetSysBeepState(short sysBeepState)
 FOURWORDINLINE(0x203C, 0x001C, 0x0008, 0xA800);
extern pascal OSErr SndPlayDoubleBuffer(SndChannelPtr chan, SndDoubleBufferHeaderPtr theParams)
 FOURWORDINLINE(0x203C, 0x0020, 0x0008, 0xA800);
extern pascal NumVersion MACEVersion(void)
 FOURWORDINLINE(0x203C, 0x0000, 0x0010, 0xA800);
extern pascal void Comp3to1(const void *inBuffer, void *outBuffer, unsigned long cnt, const void *inState, void *outState, unsigned long numChannels, unsigned long whichChannel)
 FOURWORDINLINE(0x203C, 0x0004, 0x0010, 0xA800);
extern pascal void Exp1to3(const void *inBuffer, void *outBuffer, unsigned long cnt, const void *inState, void *outState, unsigned long numChannels, unsigned long whichChannel)
 FOURWORDINLINE(0x203C, 0x0008, 0x0010, 0xA800);
extern pascal void Comp6to1(const void *inBuffer, void *outBuffer, unsigned long cnt, const void *inState, void *outState, unsigned long numChannels, unsigned long whichChannel)
 FOURWORDINLINE(0x203C, 0x000C, 0x0010, 0xA800);
extern pascal void Exp1to6(const void *inBuffer, void *outBuffer, unsigned long cnt, const void *inState, void *outState, unsigned long numChannels, unsigned long whichChannel)
 FOURWORDINLINE(0x203C, 0x0010, 0x0010, 0xA800);

/*Sound Manager 3.0 and later calls*/

extern pascal OSErr GetSysBeepVolume(long *level)
 FOURWORDINLINE(0x203C, 0x0224, 0x0018, 0xA800);
extern pascal OSErr SetSysBeepVolume(long level)
 FOURWORDINLINE(0x203C, 0x0228, 0x0018, 0xA800);
extern pascal OSErr GetDefaultOutputVolume(long *level)
 FOURWORDINLINE(0x203C, 0x022C, 0x0018, 0xA800);
extern pascal OSErr SetDefaultOutputVolume(long level)
 FOURWORDINLINE(0x203C, 0x0230, 0x0018, 0xA800);
extern pascal OSErr GetSoundHeaderOffset(Handle sndHandle, long *offset)
 FOURWORDINLINE(0x203C, 0x0404, 0x0018, 0xA800);
#ifdef __cplusplus
}
#endif

#endif

