/*
	File:		FragLoad.h

	Copyright:	© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __FRAGLOAD__
#define __FRAGLOAD__ 1

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

#ifndef __FILES__
#include <Files.h>
/*	#include <OSUtils.h>										*/
/*	#include <SegLoad.h>										*/
#endif

#ifndef __TRAPS__
#endif

typedef long ConnectionID;

typedef unsigned long LoadFlags;

typedef unsigned char SymClass;

#define kPowerPCArch 'pwpc'

#define kMotorola68KArch 'm68k'

#define kAnyArchType '???\?'


// *** Confusing names, soon to be removed!

#define kPowerPC 'pwpc'

#define kMotorola68K 'm68k'

#define kNoLibName ((unsigned char *) 0)

#define kNoConnectionID ((ConnectionID) 0)

#define kUnresolvedSymbolAddress ((Ptr) 0x0)


// use for findFlags mask

enum  {
	kLoadLib					= 1,							// use existing connection if possible
	kFindLib					= 2,							// just see if library is already loaded
	kLoadNewCopy				= 5,							// load a new instance no matter what
	kUseInPlace					= 0x80							// use container's sections in place
};

enum  {
	kCodeSym					= 0,
	kDataSym					= 1,
	kTVectSym					= 2,
	kTOCSym						= 3,
	kGlueSym					= 4
};


/************************************************************************/


/*         for fragment initialization routines                         */


/************************************************************************/

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct MemFragment {
	Ptr							address;
	long						length;
	Boolean						inPlace;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct MemFragment MemFragment;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct DiskFragment {
	FSSpecPtr					fileSpec;						// ! Must correspond to FSSpecPtr in segmented case!
	long						offset;
	long						length;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct DiskFragment DiskFragment;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SegmentedFragment {
	FSSpecPtr					fileSpec;						// ! Must correspond to FSSpecPtr in data fork case!
	OSType						rsrcType;
	short						rsrcID;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SegmentedFragment SegmentedFragment;


// ! Note that the onDisk and inSegs members are required to have an FSSpecPtr


// ! field at the same location!  CFM code uses just one member to access the


// ! information for either case!

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FragmentLocator {
	long						where;
	union {
		MemFragment					inMem;
		DiskFragment				onDisk;
		SegmentedFragment			inSegs;
	}							u;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FragmentLocator FragmentLocator, *FragmentLocatorPtr;


// NOTE: when fragLocator. where == kOnDisk, then


//       fragLocator. u. onDisk. fileSpec is a pointer


//       to the file that the library belonged to.


//       the pointer is valid only for the duration


//       of the init routine's invocation, so make


//       a copy of the filespec if it is important

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct InitBlock {
	long						contextID;
	long						closureID;
	long						connectionID;
	FragmentLocator				fragLocator;
	Ptr							libName;
	long						reserved4a;
	long						reserved4b;
	long						reserved4c;
	long						reserved4d;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct InitBlock InitBlock, *InitBlockPtr;


// Prototype for initialization routines.  Note that these are C, not Pascal conventions!


// This differs from customary "Apple-callback" useage, but is felt to be less error prone


// in practice since the vast bulk of 68K CFM aware code will be in C.


// NOTE: Initialization routines may comfortably ignore their parameters, however, they must


//       return an error status (ie: noErr) in order to succeed with the load of the library.


// Termination routines get no parameters and have no return value.

typedef OSErr ConnectionInitializationRoutine(InitBlockPtr initBlkPtr);

typedef void ConnectionTerminationRoutine(void);


/************************************************************************/


/*                for building shared libraries                         */


/************************************************************************/

#define kCFMRsrcType 'cfrg'

#define kCFMRsrcID 0

#define kSHLBFileType 'shlb'


/************************************************************************/


/*                error codes                                           */


/************************************************************************/

enum  {
	fragNoErr					= 0,
	fragContextNotFound			= -2800,						// contextID was not valid
	fragConnectionIDNotFound	= -2801,						// connecionID was not valid
	fragSymbolNotFound			= -2802,						// symbol was not found in connection
	fragSectionNotFound			= -2803,						// section was not found
	fragLibNotFound				= -2804,						// library name not found in Frag registry
	fragDupRegLibName			= -2805,						// registered name already in use
	fragFormatUnknown			= -2806,						// fragment container format unknown
	fragHadUnresolveds			= -2807,						// loaded fragment had "hard" unresolved imports
	fragUnused1					= -2808,						// unused
	fragNoMem					= -2809,						// out of memory for interal bookkeeping
	fragNoAddrSpace				= -2810,						// out of memory in user's address space for loadable section
	fragNoContextIDs			= -2811,						// no more context id’s
	fragObjectInitSeqErr		= -2812,						// order error during user initialization function invocation
	fragImportTooOld			= -2813,						// import library was too old and therefore incompatible
	fragImportTooNew			= -2814,						// import library was too new and therefore incompatible
	fragInitLoop				= -2815,						// circularity detected in mandatory initialization order
	fragInitRtnUsageErr			= -2816,						// boot library has initialization routine
	fragLibConnErr				= -2817,						// error connecting to library (error occured in sub prepare)
	fragMgrInitErr				= -2818,						// error in initailization of this manager
	fragConstErr				= -2819,						// internal inconstistancy
	fragCorruptErr				= -2820,						// fragment container corrupted (known format)
	fragUserInitProcErr			= -2821,						// user intialization routine did not return noErr
	fragAppNotFound				= -2822,						// no application found in cfrg (for Process Manager)
	fragArchError				= -2823,						// fragment targeted for an unacceptable architecture
	fragInvalidFragmentUsage	= -2824,						/* ie: an application's main fragment had no entry point
                                           *    - or - an accerated resource had no entry point,
										   *               or it had a termination routine, etc... */
	fragLastErrCode				= -2899							// last reserved error code number
};

#if TurnOff68KCFMTraps || __powerc || powerc
#define CFMTrap(arg)

#else
#define CFMTrap(arg) = { 0x3F3C, arg, _CodeFragmentDispatch }

#endif

#ifdef __cplusplus
extern "C" {
#endif

extern pascal OSErr GetSharedLibrary(Str63 libName, OSType archType, LoadFlags findFlags, ConnectionID *connID, Ptr *mainAddr, Str255 errName)
 THREEWORDINLINE(0x3F3C, 1, 0xAA5A);
#define GetSharedLibraryProcInfo  \
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(2, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(3, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(4, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(5, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(6, kFourByteCode))

extern pascal OSErr GetDiskFragment(FSSpecPtr fileSpec, long offset, long length, Str63 fragName, LoadFlags findFlags, ConnectionID *connID, Ptr *mainAddr, Str255 errName)
 THREEWORDINLINE(0x3F3C, 2, 0xAA5A);
#define GetDiskFragmentProcInfo  \
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(2, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(3, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(4, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(5, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(6, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(7, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(8, kFourByteCode))

extern pascal OSErr GetMemFragment(Ptr memAddr, long length, Str63 fragName, LoadFlags findFlags, ConnectionID *connID, Ptr *mainAddr, Str255 errName)
 THREEWORDINLINE(0x3F3C, 3, 0xAA5A);
#define GetMemFragmentProcInfo 	\
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(2, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(3, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(4, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(5, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(6, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(7, kFourByteCode))

extern pascal OSErr CloseConnection(ConnectionID *connID)
 THREEWORDINLINE(0x3F3C, 4, 0xAA5A);
#define CloseConnectionProcInfo  \
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode))

extern pascal OSErr FindSymbol(ConnectionID connID, Str255 symName, Ptr *symAddr, SymClass *symClass)
 THREEWORDINLINE(0x3F3C, 5, 0xAA5A);
#define FindSymbolProcInfo 		\
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(2, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(3, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(4, kFourByteCode))

extern pascal OSErr CountSymbols(ConnectionID connID, long *symCount)
 THREEWORDINLINE(0x3F3C, 6, 0xAA5A);
#define CountSymbolsProcInfo 	\
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(2, kFourByteCode))

extern pascal OSErr GetIndSymbol(ConnectionID connID, long symIndex, Str255 symName, Ptr *symAddr, SymClass *symClass)
 THREEWORDINLINE(0x3F3C, 7, 0xAA5A);
#define GetIndSymbolProcInfo 	\
	(kPascalStackBased	|			\
	RESULT_SIZE(kTwoByteCode) |	 \
	STACK_ROUTINE_PARAMETER(1, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(2, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(3, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(4, kFourByteCode) |	 \
	STACK_ROUTINE_PARAMETER(5, kFourByteCode))

#ifdef __cplusplus
}
#endif

#endif

