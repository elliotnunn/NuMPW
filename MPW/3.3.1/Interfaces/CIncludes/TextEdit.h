/*
	File:		TextEdit.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __TEXTEDIT__
#define __TEXTEDIT__

#ifndef __QUICKDRAW__
#include <Quickdraw.h>
/*	#include <Types.h>											*/
/*		#include <ConditionalMacros.h>							*/
/*		#include <MixedMode.h>									*/
/*			#include <Traps.h>									*/
/*	#include <QuickdrawText.h>									*/
/*		#include <IntlResources.h>								*/
#endif

typedef struct TERec TERec, *TEPtr, **TEHandle;


/*
	The following ProcPtrs cannot be written in or called from a high-level 
	language without the help of mixed mode or assembly glue because they 
	use the following parameter-passing conventions:

	typedef pascal void (*HighHookProcPtr)(const Rect *r, TEPtr pTE);
	typedef pascal void (*CaretHookProcPtr)(const Rect *r, TEPtr pTE);

		In:
			=> 	r						on stack
			=>	pTE						A3.L
		Out:
			none

	typedef pascal Boolean (*EOLHookProcPtr)(char theChar, TEPtr pTE, TEHandle hTE);

		In:
			=> 	theChar					D0.B
			=>	pTE						A3.L
			=>	hTE						A4.L
		Out:
			<=	Boolean					Z bit of the CCR

	typedef pascal unsigned short (*WidthHookProcPtr)(unsigned short textLen,
	 unsigned short textOffset, char *textBufferPtr, TEPtr pTE, TEHandle hTE);
	typedef pascal unsigned short (*TextWidthHookProcPtr)(unsigned short textLen,
	 unsigned short textOffset, char *textBufferPtr, TEPtr pTE, TEHandle hTE);

		In:
			=> 	textLen					D0.W
			=>	textOffset				D1.W
			=>	textBufferPtr			A0.L
			=>	pTE						A3.L
			=>	hTE						A4.L
		Out:
			<=	unsigned short			D1.W

	typedef pascal unsigned short (*NWidthHookProcPtr)(unsigned short styleRunLen,
	 unsigned short styleRunOffset, short slop, short direction, char *textBufferPtr, 
	 short *lineStart, TEPtr pTE, TEHandle hTE);

		In:
			=> 	styleRunLen				D0.W
			=>	styleRunOffset			D1.W
			=>	slop					D2.W (low)
			=>	direction				D2.W (high)
			=>	textBufferPtr			A0.L
			=>	lineStart				A2.L
			=>	pTE						A3.L
			=>	hTE						A4.L
		Out:
			<=	unsigned short			D1.W

	typedef pascal void (*DrawHookProcPtr)(unsigned short textOffset, unsigned short drawLen,
	 char *textBufferPtr, TEPtr pTE, TEHandle hTE);

		In:
			=> 	textOffset				D0.W
			=>	drawLen					D1.W
			=>	textBufferPtr			A0.L
			=>	pTE						A3.L
			=>	hTE						A4.L
		Out:
			none

	typedef pascal Boolean (*HitTestHookProcPtr)(unsigned short styleRunLen,
	 unsigned short styleRunOffset, unsigned short slop, char *textBufferPtr,
	 TEPtr pTE, TEHandle hTE, unsigned short *pixelWidth, unsigned short *charOffset, 
	 Boolean *pixelInChar);

		In:
			=> 	styleRunLen				D0.W
			=>	styleRunOffset			D1.W
			=>	slop					D2.W
			=>	textBufferPtr			A0.L
			=>	pTE						A3.L
			=>	hTE						A4.L
		Out:
			<=	pixelWidth				D0.W (low)
			<=	Boolean					D0.W (high)
			<=	charOffset				D1.W
			<=	pixelInChar				D2.W

	typedef pascal void (*TEFindWordProcPtr)(unsigned short currentPos, short caller, 
	 TEPtr pTE, TEHandle hTE, unsigned short *wordStart, unsigned short *wordEnd);

		In:
			=> 	currentPos				D0.W
			=>	caller					D2.W
			=>	pTE						A3.L
			=>	hTE						A4.L
		Out:
			<=	wordStart				D0.W
			<=	wordEnd					D1.W

	typedef pascal void (*TERecalcProcPtr)(TEPtr pTE, unsigned short changeLength,
  	 unsigned short *lineStart, unsigned short *firstChar, unsigned short *lastChar);

		In:
			=> 	pTE						A3.L
			=>	changeLength			D7.W
		Out:
			<=	lineStart				D2.W
			<=	firstChar				D3.W
			<=	lastChar				D4.W

	typedef pascal void (*TEDoTextProcPtr)(TEPtr pTE, unsigned short firstChar, unsigned short lastChar,
	 short selector, GrafPtr *currentGrafPort, short *charPosition);

		In:
			=> 	pTE						A3.L
			=>	firstChar				D3.W
			=>	lastChar				D4.W
			=>	selector				D7.W
		Out:
			<=	currentGrafPort			A0.L
			<=	charPosition			D0.W

*/

enum  {
	uppHighHookProcInfo			= SPECIAL_CASE_PROCINFO(kSpecialCaseHighHook),
	uppCaretHookProcInfo		= SPECIAL_CASE_PROCINFO(kSpecialCaseCaretHook),
	uppEOLHookProcInfo			= SPECIAL_CASE_PROCINFO(kSpecialCaseEOLHook),
	uppWidthHookProcInfo		= SPECIAL_CASE_PROCINFO(kSpecialCaseWidthHook),
	uppNWidthHookProcInfo		= SPECIAL_CASE_PROCINFO(kSpecialCaseNWidthHook),
	uppTextWidthHookProcInfo	= SPECIAL_CASE_PROCINFO(kSpecialCaseTextWidthHook),
	uppDrawHookProcInfo			= SPECIAL_CASE_PROCINFO(kSpecialCaseDrawHook),
	uppHitTestHookProcInfo		= SPECIAL_CASE_PROCINFO(kSpecialCaseHitTestHook),
	uppTEFindWordProcInfo		= SPECIAL_CASE_PROCINFO(kSpecialCaseTEFindWord),
	uppTERecalcProcInfo			= SPECIAL_CASE_PROCINFO(kSpecialCaseTERecalc),
	uppTEDoTextProcInfo			= SPECIAL_CASE_PROCINFO(kSpecialCaseTEDoText)
};

#if USESROUTINEDESCRIPTORS
typedef pascal void (*HighHookProcPtr)(const Rect *r, TEPtr pTE);

typedef UniversalProcPtr HighHookUPP;

#define CallHighHookProc(userRoutine, r, pTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppHighHookProcInfo, (r), (pTE))

#define NewHighHookProc(userRoutine)  \
	(HighHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppHighHookProcInfo, GetCurrentISA())

typedef pascal void (*CaretHookProcPtr)(const Rect *r, TEPtr pTE);

typedef UniversalProcPtr CaretHookUPP;

#define CallCaretHookProc(userRoutine, r, pTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppCaretHookProcInfo, (r), (pTE))

#define NewCaretHookProc(userRoutine)  \
	(CaretHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppCaretHookProcInfo, GetCurrentISA())

typedef pascal Boolean (*EOLHookProcPtr)(char theChar, TEPtr pTE, TEHandle hTE);

typedef UniversalProcPtr EOLHookUPP;

#define CallEOLHookProc(userRoutine, theChar, pTE, hTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), (uppEOLHookProcInfo), (theChar), (pTE), (hTE))

#define NewEOLHookProc(userRoutine)  \
	(EOLHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppEOLHookProcInfo, GetCurrentISA())

typedef pascal unsigned short (*WidthHookProcPtr)(unsigned short textLen, unsigned short textOffset, char *textBufferPtr, TEPtr pTE, TEHandle hTE);

typedef UniversalProcPtr WidthHookUPP;

#define CallWidthHookProc(userRoutine, textLen, textOffset, textBufferPtr, pTE, hTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), (uppWidthHookProcInfo), (textLen),  \
	(textOffset), (textBufferPtr), (pTE), (hTE))

#define NewWidthHookProc(userRoutine)  \
	(WidthHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppWidthHookProcInfo, GetCurrentISA())

typedef pascal unsigned short (*NWidthHookProcPtr)(unsigned short styleRunLen, unsigned short styleRunOffset, short slop, short direction, char *textBufferPtr, short *lineStart, TEPtr pTE, TEHandle hTE);

typedef UniversalProcPtr NWidthHookUPP;

#define CallNWidthHookProc(userRoutine, styleRunLen, styleRunOffset, slop, direction, textBufferPtr, lineStart, pTE, hTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), (uppNWidthHookProcInfo), (styleRunLen),  \
	(styleRunOffset), (slop), (direction), (textBufferPtr), (lineStart), (pTE), (hTE))

#define NewNWidthHookProc(userRoutine)  \
	(NWidthHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppNWidthHookProcInfo, GetCurrentISA())

typedef pascal unsigned short (*TextWidthHookProcPtr)(unsigned short textLen, unsigned short textOffset, char *textBufferPtr, TEPtr pTE, TEHandle hTE);

typedef UniversalProcPtr TextWidthHookUPP;

#define CallTextWidthHookProc(userRoutine, textLen, textOffset, textBufferPtr, pTE, hTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), (uppTextWidthHookProcInfo), (textLen),  \
	(textOffset), (textBufferPtr), (pTE), (hTE))

#define NewTextWidthHookProc(userRoutine)  \
	(TextWidthHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTextWidthHookProcInfo, GetCurrentISA())

typedef pascal void (*DrawHookProcPtr)(unsigned short textOffset, unsigned short drawLen, char *textBufferPtr, TEPtr pTE, TEHandle hTE);

typedef UniversalProcPtr DrawHookUPP;

#define CallDrawHookProc(userRoutine, textOffset, drawLen, textBufferPtr, pTE, hTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), (uppDrawHookProcInfo), (textOffset),  \
	(drawLen), (textBufferPtr), (pTE), (hTE))

#define NewDrawHookProc(userRoutine)  \
	(DrawHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppDrawHookProcInfo, GetCurrentISA())

typedef pascal Boolean (*HitTestHookProcPtr)(unsigned short styleRunLen, unsigned short styleRunOffset, unsigned short slop, char *textBufferPtr, TEPtr pTE, TEHandle hTE, unsigned short *pixelWidth, unsigned short *charOffset, Boolean *pixelInChar);

typedef UniversalProcPtr HitTestHookUPP;

#define CallHitTestHookProc(userRoutine, styleRunLen, styleRunOffset, slop, textBufferPtr, pTE, hTE, pixelWidth, charOffset, pixelInChar)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppHitTestHookProcInfo, (styleRunLen),  \
	(styleRunOffset), (slop), (textBufferPtr), (pTE), (hTE), (pixelWidth),  \
	(charOffset), (pixelInChar))

#define NewHitTestHookProc(userRoutine)  \
	(HitTestHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppHitTestHookProcInfo, GetCurrentISA())

typedef pascal void (*TEFindWordProcPtr)(unsigned short currentPos, short caller, TEPtr pTE, TEHandle hTE, unsigned short *wordStart, unsigned short *wordEnd);

typedef UniversalProcPtr TEFindWordUPP;

#define CallTEFindWordProc(userRoutine, currentPos, caller, pTE, hTE, wordStart, wordEnd)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppTEFindWordProcInfo, (currentPos),  \
	(caller), (pTE), (hTE), (wordStart), (wordEnd))

#define NewTEFindWordProc(userRoutine)  \
	(TEFindWordUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTEFindWordProcInfo, GetCurrentISA())

typedef pascal void (*TERecalcProcPtr)(TEPtr pTE, unsigned short changeLength, unsigned short *lineStart, unsigned short *firstChar, unsigned short *lastChar);

typedef UniversalProcPtr TERecalcUPP;

#define CallTERecalcProc(userRoutine, pTE, changeLength, lineStart, firstChar, lastChar)  \
	CallUniversalProc((UniversalProcPtr) (userRoutine), uppTERecalcProcInfo, (pTE),	 \
	(changeLength), (lineStart), (firstChar), (lastChar))

#define NewTERecalcProc(userRoutine)  \
	(TERecalcUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTERecalcProcInfo, GetCurrentISA())

typedef pascal void (*TEDoTextProcPtr)(TEPtr pTE, unsigned short firstChar, unsigned short lastChar, short selector, GrafPtr *currentGrafPort, short *charPosition);

typedef UniversalProcPtr TEDoTextUPP;

#define CallTEDoTextProc(userRoutine, pTE, firstChar, lastChar, selector, currentGrafPort, charPosition)  \
	CallUniversalProc((UniversalProcPtr) (userRoutine), uppTEDoTextProcInfo, (pTE),	 \
	(firstChar), (lastChar), (selector), (currentGrafPort), (charPosition))

#define NewTEDoTextProc(userRoutine)  \
	(TEDoTextUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTEDoTextProcInfo, GetCurrentISA())

#else
typedef ProcPtr HighHookUPP;

#define NewHighHookProc(userRoutine)  \
	(HighHookUPP)(userRoutine)

typedef ProcPtr CaretHookUPP;

#define NewCaretHookProc(userRoutine)  \
	(CaretHookUPP)(userRoutine)

typedef ProcPtr EOLHookUPP;

#define NewEOLHookProc(userRoutine)  \
	(EOLHookUPP)(userRoutine)

typedef ProcPtr WidthHookUPP;

#define NewWidthHookProc(userRoutine)  \
	(WidthHookUPP)(userRoutine)

typedef ProcPtr NWidthHookUPP;

#define NewNWidthHookProc(userRoutine)  \
	(NWidthHookUPP)(userRoutine)

typedef ProcPtr TextWidthHookUPP;

#define NewTextWidthHookProc(userRoutine)  \
	(TextWidthHookUPP)(userRoutine)

typedef ProcPtr DrawHookUPP;

#define NewDrawHookProc(userRoutine)  \
	(DrawHookUPP)(userRoutine)

typedef ProcPtr HitTestHookUPP;

#define NewHitTestHookProc(userRoutine)  \
	(HitTestHookUPP)(userRoutine)

typedef ProcPtr TEFindWordUPP;

#define NewTEFindWordProc(userRoutine)  \
	(TEFindWordUPP)(userRoutine)

typedef ProcPtr TERecalcUPP;

#define NewTERecalcProc(userRoutine)  \
	(TERecalcUPP)(userRoutine)

typedef ProcPtr TEDoTextUPP;

#define NewTEDoTextProc(userRoutine)  \
	(TEDoTextUPP)(userRoutine)

#endif

enum  {
/* Justification (word alignment) styles */
	teJustLeft					= 0,
	teJustCenter				= 1,
	teJustRight					= -1,
	teForceLeft					= -2,
/* new names for the Justification (word alignment) styles */
	teFlushDefault				= 0,							/*flush according to the line direction */
	teCenter					= 1,							/*center justify (word alignment) */
	teFlushRight				= -1,							/*flush right for all scripts */
	teFlushLeft					= -2,							/*flush left for all scripts */
/* Set/Replace style modes */
	fontBit						= 0,							/*set font*/
	faceBit						= 1,							/*set face*/
	sizeBit						= 2,							/*set size*/
	clrBit						= 3,							/*set color*/
	addSizeBit					= 4,							/*add size mode*/
	toggleBit					= 5,							/*set faces in toggle mode*/
	toglBit						= 5,							/* obsolete.  use toggleBit */
/* TESetStyle/TEContinuousStyle modes */
	doFont						= 1,							/* set font (family) number*/
	doFace						= 2,							/*set character style*/
	doSize						= 4,							/*set type size*/
	doColor						= 8,							/*set color*/
	doAll						= 15,							/*set all attributes*/
	addSize						= 16							/*adjust type size*/
};

enum  {
	doToggle					= 32,							/*toggle mode for TESetStyle*/
/* offsets into TEDispatchRec */
	EOLHook						= 0,							/*[UniversalProcPtr] TEEOLHook*/
	DRAWHook					= 4,							/*[UniversalProcPtr] TEWidthHook*/
	WIDTHHook					= 8,							/*[UniversalProcPtr] TEDrawHook*/
	HITTESTHook					= 12,							/*[UniversalProcPtr] TEHitTestHook*/
	nWIDTHHook					= 24,							/*[UniversalProcPtr] nTEWidthHook*/
	TextWidthHook				= 28,							/*[UniversalProcPtr] TETextWidthHook*/
/* selectors for TECustomHook */
	intEOLHook					= 0,							/*TEIntHook value*/
	intDrawHook					= 1,							/*TEIntHook value*/
	intWidthHook				= 2,							/*TEIntHook value*/
	intHitTestHook				= 3,							/*TEIntHook value*/
	intNWidthHook				= 6,							/*TEIntHook value for new version of WidthHook*/
	intTextWidthHook			= 7,							/*TEIntHook value for new TextWidthHook*/
/* feature or bit definitions for TEFeatureFlag */
	teFAutoScroll				= 0,							/*00000001b*/
	teFAutoScr					= 0,							/*00000001b  obsolete. use teFAutoScroll*/
	teFTextBuffering			= 1,							/*00000010b*/
	teFOutlineHilite			= 2,							/*00000100b*/
	teFInlineInput				= 3,							/*00001000b */
	teFUseTextServices			= 4,							/*00010000b */
/* action for the new "bit (un)set" interface, TEFeatureFlag */
	TEBitClear					= 0,
	TEBitSet					= 1								/*set the selector bit*/
};

enum  {
	TEBitTest					= -1,							/*no change; just return the current setting*/
	teBitClear					= 0,
	teBitSet					= 1,							/*set the selector bit*/
	teBitTest					= -1,							/*no change; just return the current setting*/
/*constants for identifying the routine that called FindWord */
	teWordSelect				= 4,							/*clickExpand to select word*/
	teWordDrag					= 8,							/*clickExpand to drag new word*/
	teFromFind					= 12,							/*FindLine called it ($0C)*/
	teFromRecal					= 16,							/*RecalLines called it ($10)      obsolete */
/*constants for identifying TEDoText selectors */
	teFind						= 0,							/*TEDoText called for searching*/
	teHighlight					= 1,							/*TEDoText called for highlighting*/
	teDraw						= -1,							/*TEDoText called for drawing text*/
	teCaret						= -2							/*TEDoText called for drawing the caret*/
};


/*
	WordBreakProcs and TEClickLoopProcs cannot be written in or called from a 
	high-level language without the help of mixed mode or assembly glue 
	because they use the following parameter-passing conventions:

	typedef pascal Boolean (*WordBreakProcPtr)(Ptr text, short charPos);

		In:
			=> 	text			A0.L
			=> 	charPos			D0.W
		Out:
			<=	Boolean			Z bit of the CCR
			
	typedef pascal Boolean (*TEClickLoopProcPtr)(TEPtr pTE);

		In:
			=>	pTE				A3.L
		Out:
			<= 	Boolean			D0.B
*/

enum  {
	uppWordBreakProcInfo		= kRegisterBased|REGISTER_RESULT_LOCATION(kCCRegisterZBit)|REGISTER_ROUTINE_PARAMETER(1,kRegisterA0,kFourByteCode)|REGISTER_ROUTINE_PARAMETER(2,kRegisterD0,kTwoByteCode),
	uppTEClickLoopProcInfo		= kRegisterBased|RESULT_SIZE(kOneByteCode)|REGISTER_RESULT_LOCATION(kRegisterD0)|REGISTER_ROUTINE_PARAMETER(1,kRegisterA3,kFourByteCode)
};

#if USESROUTINEDESCRIPTORS
typedef pascal Boolean (*WordBreakProcPtr)(Ptr text, short charPos);

typedef UniversalProcPtr WordBreakUPP;

#define CallWordBreakProc(userRoutine, text, charPos)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppWordBreakProcInfo, (text), (charPos))

#define NewWordBreakProc(userRoutine)  \
	(WordBreakUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppWordBreakProcInfo, GetCurrentISA())

typedef pascal Boolean (*TEClickLoopProcPtr)(TEPtr pTE);

typedef UniversalProcPtr TEClickLoopUPP;

#define CallTEClickLoopProc(userRoutine, pTE)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppTEClickLoopProcInfo, (pTE))

#define NewTEClickLoopProc(userRoutine)  \
	(TEClickLoopUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppTEClickLoopProcInfo, GetCurrentISA())

#else
typedef ProcPtr WordBreakUPP;

#define NewWordBreakProc(userRoutine)  \
	(WordBreakUPP)(userRoutine)

typedef ProcPtr TEClickLoopUPP;

#define NewTEClickLoopProc(userRoutine)  \
	(TEClickLoopUPP)(userRoutine)

#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct TERec {
	Rect						destRect;
	Rect						viewRect;
	Rect						selRect;
	short						lineHeight;
	short						fontAscent;
	Point						selPoint;
	short						selStart;
	short						selEnd;
	short						active;
	WordBreakUPP				wordBreak;
	TEClickLoopUPP				clickLoop;
	long						clickTime;
	short						clickLoc;
	long						caretTime;
	short						caretState;
	short						just;
	short						teLength;
	Handle						hText;
/* short recalBack;		*/
/* short recalLines;	*/
	long						hDispatchRec;					/* added to replace recalBack & recalLines.  it's a handle anyway */
	short						clikStuff;
	short						crOnly;
	short						txFont;
	Style						txFace;							/*txFace is unpacked byte*/
	char						filler;
	short						txMode;
	short						txSize;
	GrafPtr						inPort;
	HighHookUPP					highHook;
	CaretHookUPP				caretHook;
	short						nLines;
	short						lineStarts[16001];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef char Chars[32001];

typedef char *CharsPtr, **CharsHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct StyleRun {
	short						startChar;						/*starting character position*/
	short						styleIndex;						/*index in style table*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct StyleRun StyleRun;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct STElement {
	short						stCount;						/*number of runs in this style*/
	short						stHeight;						/*line height*/
	short						stAscent;						/*font ascent*/
	short						stFont;							/*font (family) number*/
	Style						stFace;							/*character Style*/
	char						filler;							/*stFace is unpacked byte*/
	short						stSize;							/*size in points*/
	RGBColor					stColor;						/*absolute (RGB) color*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct STElement STElement;

typedef STElement TEStyleTable[1777], *STPtr, **STHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct LHElement {
	short						lhHeight;						/*maximum height in line*/
	short						lhAscent;						/*maximum ascent in line*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct LHElement LHElement;


/* ARRAY [0..8000] OF LHElement */

typedef LHElement LHTable[8001], *LHPtr, **LHHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct ScrpSTElement {
	long						scrpStartChar;					/*starting character position*/
	short						scrpHeight;						/*starting character position*/
	short						scrpAscent;
	short						scrpFont;
	Style						scrpFace;						/*unpacked byte*/
	char						filler;							/*scrpFace is unpacked byte*/
	short						scrpSize;
	RGBColor					scrpColor;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct ScrpSTElement ScrpSTElement;


/* ARRAY [0..1600] OF ScrpSTElement */

typedef ScrpSTElement ScrpSTTable[1601];

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct StScrpRec {
	short						scrpNStyles;					/*number of styles in scrap*/
	ScrpSTTable					scrpStyleTab;					/*table of styles for scrap*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct StScrpRec StScrpRec;

typedef StScrpRec *StScrpPtr, **StScrpHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct NullStRec {
	long						teReserved;						/*reserved for future expansion*/
	StScrpHandle				nullScrap;						/*handle to scrap style table*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct NullStRec NullStRec;

typedef NullStRec *NullStPtr, **NullStHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct TEStyleRec {
	short						nRuns;							/*number of style runs*/
	short						nStyles;						/*size of style table*/
	STHandle					styleTab;						/*handle to style table*/
	LHHandle					lhTab;							/*handle to line-height table*/
	long						teRefCon;						/*reserved for application use*/
	NullStHandle				nullStyle;						/*Handle to style set at null selection*/
	StyleRun					runs[8001];						/*ARRAY [0..8000] OF StyleRun*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct TEStyleRec TEStyleRec;

typedef TEStyleRec *TEStylePtr, **TEStyleHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct TextStyle {
	short						tsFont;							/*font (family) number*/
	Style						tsFace;							/*character Style*/
	char						filler;							/*tsFace is unpacked byte*/
	short						tsSize;							/*size in point*/
	RGBColor					tsColor;						/*absolute (RGB) color*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct TextStyle TextStyle;

typedef TextStyle *TextStylePtr, **TextStyleHandle;

typedef short TEIntHook;

#ifdef __cplusplus
extern "C" {
#endif

#if USESCODEFRAGMENTS
extern pascal Handle TEScrapHandle(void);
extern pascal long TEGetScrapLength(void);
#else
#define TEScrapHandle() (* (Handle*) 0xAB4)

#define TEGetScrapLength() ((long) * (unsigned short *) 0x0AB0)

#endif

extern pascal void TEInit(void)
 ONEWORDINLINE(0xA9CC);
extern pascal TEHandle TENew(const Rect *destRect, const Rect *viewRect)
 ONEWORDINLINE(0xA9D2);
extern pascal void TEDispose(TEHandle hTE)
 ONEWORDINLINE(0xA9CD);
extern pascal void TESetText(const void *text, long length, TEHandle hTE)
 ONEWORDINLINE(0xA9CF);
extern pascal CharsHandle TEGetText(TEHandle hTE)
 ONEWORDINLINE(0xA9CB);
extern pascal void TEIdle(TEHandle hTE)
 ONEWORDINLINE(0xA9DA);
extern pascal void TESetSelect(long selStart, long selEnd, TEHandle hTE)
 ONEWORDINLINE(0xA9D1);
extern pascal void TEActivate(TEHandle hTE)
 ONEWORDINLINE(0xA9D8);
extern pascal void TEDeactivate(TEHandle hTE)
 ONEWORDINLINE(0xA9D9);
extern pascal void TEKey(short key, TEHandle hTE)
 ONEWORDINLINE(0xA9DC);
extern pascal void TECut(TEHandle hTE)
 ONEWORDINLINE(0xA9D6);
extern pascal void TECopy(TEHandle hTE)
 ONEWORDINLINE(0xA9D5);
extern pascal void TEPaste(TEHandle hTE)
 ONEWORDINLINE(0xA9DB);
extern pascal void TEDelete(TEHandle hTE)
 ONEWORDINLINE(0xA9D7);
extern pascal void TEInsert(const void *text, long length, TEHandle hTE)
 ONEWORDINLINE(0xA9DE);
extern pascal void TESetAlignment(short just, TEHandle hTE)
 ONEWORDINLINE(0xA9DF);
extern pascal void TEUpdate(const Rect *rUpdate, TEHandle hTE)
 ONEWORDINLINE(0xA9D3);
extern pascal void TETextBox(const void *text, long length, const Rect *box, short just)
 ONEWORDINLINE(0xA9CE);
extern pascal void TEScroll(short dh, short dv, TEHandle hTE)
 ONEWORDINLINE(0xA9DD);
extern pascal void TESelView(TEHandle hTE)
 ONEWORDINLINE(0xA811);
extern pascal void TEPinScroll(short dh, short dv, TEHandle hTE)
 ONEWORDINLINE(0xA812);
extern pascal void TEAutoView(Boolean fAuto, TEHandle hTE)
 ONEWORDINLINE(0xA813);
extern pascal void TECalText(TEHandle hTE)
 ONEWORDINLINE(0xA9D0);
extern pascal short TEGetOffset(Point pt, TEHandle hTE)
 ONEWORDINLINE(0xA83C);
extern pascal Point TEGetPoint(short offset, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0008, 0xA83D);
extern pascal void TEClick(Point pt, Boolean fExtend, TEHandle h)
 ONEWORDINLINE(0xA9D4);
extern pascal TEHandle TEStyleNew(const Rect *destRect, const Rect *viewRect)
 ONEWORDINLINE(0xA83E);
extern pascal void TESetStyleHandle(TEStyleHandle theHandle, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0005, 0xA83D);
extern pascal TEStyleHandle TEGetStyleHandle(TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0004, 0xA83D);
extern pascal void TEGetStyle(short offset, TextStyle *theStyle, short *lineHeight, short *fontAscent, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0003, 0xA83D);
extern pascal void TEStylePaste(TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0000, 0xA83D);
extern pascal void TESetStyle(short mode, const TextStyle *newStyle, Boolean fRedraw, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0001, 0xA83D);
extern pascal void TEReplaceStyle(short mode, const TextStyle *oldStyle, const TextStyle *newStyle, Boolean fRedraw, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0002, 0xA83D);
extern pascal StScrpHandle TEGetStyleScrapHandle(TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0006, 0xA83D);
extern pascal void TEStyleInsert(const void *text, long length, StScrpHandle hST, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0007, 0xA83D);
extern pascal long TEGetHeight(long endLine, long startLine, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x0009, 0xA83D);
extern pascal Boolean TEContinuousStyle(short *mode, TextStyle *aStyle, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x000A, 0xA83D);
extern pascal void TEUseStyleScrap(long rangeStart, long rangeEnd, StScrpHandle newStyles, Boolean fRedraw, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x000B, 0xA83D);
extern pascal void TECustomHook(TEIntHook which, UniversalProcPtr *addr, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x000C, 0xA83D);
extern pascal long TENumStyles(long rangeStart, long rangeEnd, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x000D, 0xA83D);
extern pascal short TEFeatureFlag(short feature, short action, TEHandle hTE)
 THREEWORDINLINE(0x3F3C, 0x000E, 0xA83D);
extern pascal void TESetScrapLength(long length);
extern pascal OSErr TEFromScrap(void);
extern pascal OSErr TEToScrap(void);
extern pascal void TESetClickLoop(TEClickLoopUPP clikProc, TEHandle hTE);
extern pascal void TESetWordBreak(WordBreakUPP wBrkProc, TEHandle hTE);
extern void teclick(Point *pt, Boolean fExtend, TEHandle h);
#if OLDROUTINENAMES
#define TESetJust(just, hTE) TESetAlignment(just, hTE)

#define TextBox(text, length, box, just) TETextBox(text, length, box, just)

#define TEStylNew(destRect, viewRect) TEStyleNew(destRect, viewRect)

#define SetStylHandle(theHandle, hTE) TESetStyleHandle(theHandle, hTE)

#define SetStyleHandle(theHandle, hTE) TESetStyleHandle (theHandle, hTE)

#define GetStylHandle(hTE) TEGetStyleHandle(hTE)

#define GetStyleHandle(hTE) TEGetStyleHandle(hTE)

#define TEStylPaste(hTE) TEStylePaste(hTE)

#define GetStylScrap(hTE) TEGetStyleScrapHandle(hTE)

#define GetStyleScrap(hTE) TEGetStyleScrapHandle(hTE)

#define SetStylScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)  \
	TEUseStyleScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)

#define SetStyleScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)  \
	TEUseStyleScrap(rangeStart, rangeEnd, newStyles, redraw, hTE)

#define TEStylInsert(text, length, hST, hTE) TEStyleInsert(text, length, hST, hTE)

#define TESetScrapLen(length) TESetScrapLength(length)

#define TEGetScrapLen() TEGetScrapLength()

#define SetClikLoop(clikProc, hTE) TESetClickLoop(clikProc, hTE)

#define SetWordBreak(wBrkProc, hTE) TESetWordBreak(wBrkProc, hTE)

#endif

#ifdef __cplusplus
}
#endif

#endif

