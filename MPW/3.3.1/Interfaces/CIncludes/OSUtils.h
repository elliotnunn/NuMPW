/*
	File:		OSUtils.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __OSUTILS__
#define __OSUTILS__

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

enum  {
	useFree						= 0,
	useATalk					= 1,
	useAsync					= 2,
	useExtClk					= 3,							/*Externally clocked*/
	useMIDI						= 4,
/**** Environs Equates ****/
	curSysEnvVers				= 2,							/*Updated to equal latest SysEnvirons version*/
/* Machine Types */
	envMac						= -1,
	envXL						= -2,
	envMachUnknown				= 0,
	env512KE					= 1,
	envMacPlus					= 2,
	envSE						= 3,
	envMacII					= 4,
	envMacIIx					= 5,
	envMacIIcx					= 6,
	envSE30						= 7,
	envPortable					= 8,
	envMacIIci					= 9,
	envMacIIfx					= 11,
/* CPU types */
	envCPUUnknown				= 0
};

enum  {
	env68000					= 1,
	env68010					= 2,
	env68020					= 3,
	env68030					= 4,
	env68040					= 5,
/* Keyboard types */
	envUnknownKbd				= 0,
	envMacKbd					= 1,
	envMacAndPad				= 2,
	envMacPlusKbd				= 3,
	envAExtendKbd				= 4,
	envStandADBKbd				= 5,
	envPrtblADBKbd				= 6,
	envPrtblISOKbd				= 7,
	envStdISOADBKbd				= 8,
	envExtISOADBKbd				= 9,
	false32b					= 0,							/*24 bit addressing error*/
	true32b						= 1,							/*32 bit addressing error*/
/* result types for RelString Call */
	sortsBefore					= -1,							/*first string < second string*/
	sortsEqual					= 0,							/*first string = second string*/
	sortsAfter					= 1								/*first string > second string*/
};

enum  {
/* Toggle results */
	toggleUndefined				= 0,
	toggleOK					= 1,
	toggleBadField				= 2,
	toggleBadDelta				= 3,
	toggleBadChar				= 4,
	toggleUnknown				= 5,
	toggleBadNum				= 6,
	toggleOutOfRange			= 7,							/*synonym for toggleErr3*/
	toggleErr3					= 7,
	toggleErr4					= 8,
	toggleErr5					= 9,
/* Date equates */
	smallDateBit				= 31,							/*Restrict valid date/time to range of Time global*/
	togChar12HourBit			= 30,							/*If toggling hour by char, accept hours 1..12 only*/
	togCharZCycleBit			= 29,							/*Modifier for togChar12HourBit: accept hours 0..11 only*/
	togDelta12HourBit			= 28,							/*If toggling hour up/down, restrict to 12-hour range (am/pm)*/
	genCdevRangeBit				= 27,							/*Restrict date/time to range used by genl CDEV*/
	validDateFields				= -1,
	maxDateField				= 10,
	eraMask						= 0x0001,
	yearMask					= 0x0002,
	monthMask					= 0x0004,
	dayMask						= 0x0008,
	hourMask					= 0x0010,
	minuteMask					= 0x0020,
	secondMask					= 0x0040,
	dayOfWeekMask				= 0x0080,
	dayOfYearMask				= 0x0100,
	weekOfYearMask				= 0x0200,
	pmMask						= 0x0400,
	dateStdMask					= 0x007F						/*default for ValidDate flags and ToggleDate TogglePB.togFlags*/
};

enum  {
	eraField,
	yearField,
	monthField,
	dayField,
	hourField,
	minuteField,
	secondField,
	dayOfWeekField,
	dayOfYearField,
	weekOfYearField,
	pmField,
	res1Field,
	res2Field,
	res3Field
};

typedef unsigned char LongDateField;

enum  {
	dummyType,
	vType,
	ioQType,
	drvQType,
	evType,
	fsQType,
	sIQType,
	dtQType
};

typedef unsigned short QTypes;

enum  {
	OSTrap,
	ToolTrap
};

typedef unsigned char TrapType;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SysParmType {
	char						valid;
	char						aTalkA;
	char						aTalkB;
	char						config;
	short						portA;
	short						portB;
	long						alarm;
	short						font;
	short						kbdPrint;
	short						volClik;
	short						misc;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SysParmType SysParmType;

typedef SysParmType *SysPPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct QElem {
	struct QElem				*qLink;
	short						qType;
	short						qData[1];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct QElem QElem;

typedef QElem *QElemPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct QHdr {
	short						qFlags;
	QElemPtr					qHead;
	QElemPtr					qTail;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct QHdr QHdr;

typedef QHdr *QHdrPtr;


/*
	DeferredTaskProcs cannot be written in or called from a high-level 
	language without the help of mixed mode or assembly glue because they 
	use the following parameter-passing convention:

	typedef pascal void (*DeferredTaskProcPtr)(long dtParam);

		In:
			=> 	dtParam				A1.L
		Out:
			none
*/

enum  {
	uppDeferredTaskProcInfo		= kRegisterBased|REGISTER_ROUTINE_PARAMETER(1,kRegisterA1,kFourByteCode)
};

#if USESROUTINEDESCRIPTORS
typedef pascal void (*DeferredTaskProcPtr)(long dtParam);

typedef UniversalProcPtr DeferredTaskUPP;

#define CallDeferredTaskProc(userRoutine, dtParam)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppDeferredTaskProcInfo, (dtParam))

#define NewDeferredTaskProc(userRoutine)  \
	(DeferredTaskUPP) NewRoutineDescriptor((ProcPtr)(userRoutine),  \
	uppDeferredTaskProcInfo, GetCurrentISA())

#else
typedef ProcPtr DeferredTaskUPP;

#define NewDeferredTaskProc(userRoutine)  \
	(DeferredTaskUPP)(userRoutine)

#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct DeferredTask {
	QElemPtr					qLink;
	short						qType;
	short						dtFlags;
	DeferredTaskUPP				dtAddr;
	long						dtParam;
	long						dtReserved;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct DeferredTask DeferredTask;

typedef DeferredTask *DeferredTaskPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SysEnvRec {
	short						environsVersion;
	short						machineType;
	short						systemVersion;
	short						processor;
	Boolean						hasFPU;
	Boolean						hasColorQD;
	short						keyBoardType;
	short						atDrvrVersNum;
	short						sysVRefNum;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SysEnvRec SysEnvRec;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct MachineLocation {
	Fract						latitude;
	Fract						longitude;
	union {
		char						dlsDelta;					/*signed byte; daylight savings delta*/
		long						gmtDelta;					/*must mask - see documentation*/
	}							gmtFlags;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct MachineLocation MachineLocation;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct DateTimeRec {
	short						year;
	short						month;
	short						day;
	short						hour;
	short						minute;
	short						second;
	short						dayOfWeek;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct DateTimeRec DateTimeRec;

typedef wide LongDateTime;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
union LongDateCvt {
	wide						c;
	struct {
		long						lHigh;
		long						lLow;
	}							hl;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef union LongDateCvt LongDateCvt;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
union LongDateRec {
	struct {
		short						era;
		short						year;
		short						month;
		short						day;
		short						hour;
		short						minute;
		short						second;
		short						dayOfWeek;
		short						dayOfYear;
		short						weekOfYear;
		short						pm;
		short						res1;
		short						res2;
		short						res3;
	}							ld;
	short						list[14];						/*Index by LongDateField!*/
	struct {
		short						eraAlt;
		DateTimeRec					oldDate;
	}							od;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef union LongDateRec LongDateRec;

typedef char DateDelta;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct TogglePB {
	long						togFlags;						/*caller normally sets low word to dateStdMask=$7F*/
	ResType						amChars;						/*from 'itl0', but uppercased*/
	ResType						pmChars;						/*from 'itl0', but uppercased*/
	long						reserved[4];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct TogglePB TogglePB;

typedef short ToggleResults;

#ifdef __cplusplus
extern "C" {
#endif

extern pascal void LongDateToSeconds(const LongDateRec *lDate, LongDateTime *lSecs)
 FOURWORDINLINE(0x2F3C, 0x8008, 0xFFF2, 0xA8B5);
extern pascal void LongSecondsToDate(LongDateTime *lSecs, LongDateRec *lDate)
 FOURWORDINLINE(0x2F3C, 0x8008, 0xFFF0, 0xA8B5);
extern pascal ToggleResults ToggleDate(LongDateTime *lSecs, LongDateField field, DateDelta delta, short ch, const TogglePB *params)
 FOURWORDINLINE(0x2F3C, 0x820E, 0xFFEE, 0xA8B5);
extern pascal short ValidDate(const LongDateRec *vDate, long flags, LongDateTime *newSecs)
 FOURWORDINLINE(0x2F3C, 0x820C, 0xFFE4, 0xA8B5);
extern pascal Boolean IsMetric(void)
 THREEWORDINLINE(0x3F3C, 0x0004, 0xA9ED);
#if USESCODEFRAGMENTS
extern pascal SysPPtr GetSysPPtr(void);
#else
#define GetSysPPtr() ((SysPPtr) 0x01F8)

#endif


#if USES68KINLINES
#pragma parameter __D0 ReadDateTime(__A0)
#endif
extern pascal OSErr ReadDateTime(unsigned long *time)
 ONEWORDINLINE(0xA039);

#if USES68KINLINES
#pragma parameter  GetDateTime(__A0)
#endif
extern pascal void GetDateTime(unsigned long *secs)
 TWOWORDINLINE(0x20B8, 0x020C);

#if USES68KINLINES
#pragma parameter __D0 SetDateTime(__D0)
#endif
extern pascal OSErr SetDateTime(unsigned long time)
 ONEWORDINLINE(0xA03A);

#if USES68KINLINES
#pragma parameter  SetTime(__A0)
#endif
extern pascal void SetTime(const DateTimeRec *d)
 TWOWORDINLINE(0xA9C7, 0xA03A);

#if USES68KINLINES
#pragma parameter  GetTime(__A0)
#endif
extern pascal void GetTime(DateTimeRec *d)
 THREEWORDINLINE(0x2038, 0x020C, 0xA9C6);
extern pascal void DateToSeconds(const DateTimeRec *d, unsigned long *secs);

#if USES68KINLINES
#pragma parameter  SecondsToDate(__D0, __A0)
#endif
extern pascal void SecondsToDate(unsigned long secs, DateTimeRec *d)
 ONEWORDINLINE(0xA9C6);
extern pascal void SysBeep(short duration)
 ONEWORDINLINE(0xA9C8);

#if USES68KINLINES
#pragma parameter __D0 DTInstall(__A0)
#endif
extern pascal OSErr DTInstall(DeferredTaskPtr dtTaskPtr)
 ONEWORDINLINE(0xA082);
#if USES68KINLINES
#define GetMMUMode() (* (char*) 0x0CB2)


#if USES68KINLINES
#pragma parameter  SwapMMUMode(__A0)
#endif
extern pascal void SwapMMUMode(char *mode)
 THREEWORDINLINE(0x1010, 0xA05D, 0x1080);
#else
#define GetMMUMode() ((char)true32b)

#define SwapMMUMode(x) (*(char*)(x) = true32b)

#endif

#if SystemSixOrLater

#if USES68KINLINES
#pragma parameter __D0 SysEnvirons(__D0, __A0)
#endif
extern pascal OSErr SysEnvirons(short versionRequested, SysEnvRec *theWorld)
 ONEWORDINLINE(0xA090);
#else
extern pascal OSErr SysEnvirons(short versionRequested, SysEnvRec *theWorld);
#endif


#if USES68KINLINES
#pragma parameter  Delay(__A0, __A1)
#endif
extern pascal void Delay(long numTicks, long *finalTicks)
 TWOWORDINLINE(0xA03B, 0x2280);

/*
	GetTrapAddress and SetTrapAddress are obsolete and should not
	be used. Always use NGetTrapAddress and NSetTrapAddress instead.
	The old routines will not be supported for PowerPC apps.
*/

#if defined(OBSOLETE) && !defined(powerc) && !defined(__powerc)

#if USES68KINLINES
#pragma parameter __A0 GetTrapAddress(__D0)
#endif
extern pascal UniversalProcPtr GetTrapAddress(short trapNum)
 ONEWORDINLINE(0xA146);

#if USES68KINLINES
#pragma parameter  SetTrapAddress(__A0, __D0)
#endif
extern pascal void SetTrapAddress(UniversalProcPtr trapAddr, short trapNum)
 ONEWORDINLINE(0xA047);
#endif

extern pascal UniversalProcPtr NGetTrapAddress(short trapNum, TrapType tTyp);
extern pascal void NSetTrapAddress(UniversalProcPtr trapAddr, short trapNum, TrapType tTyp);

#if USES68KINLINES
#pragma parameter __A0 GetOSTrapAddress(__D0)
#endif
extern pascal UniversalProcPtr GetOSTrapAddress(short trapNum)
 ONEWORDINLINE(0xA346);

#if USES68KINLINES
#pragma parameter  SetOSTrapAddress(__A0, __D0)
#endif
extern pascal void SetOSTrapAddress(UniversalProcPtr trapAddr, short trapNum)
 ONEWORDINLINE(0xA247);

#if USES68KINLINES
#pragma parameter __A0 GetToolTrapAddress(__D0)
#endif
extern pascal UniversalProcPtr GetToolTrapAddress(short trapNum)
 ONEWORDINLINE(0xA746);

#if USES68KINLINES
#pragma parameter  SetToolTrapAddress(__A0, __D0)
#endif
extern pascal void SetToolTrapAddress(UniversalProcPtr trapAddr, short trapNum)
 ONEWORDINLINE(0xA647);

#if USES68KINLINES
#pragma parameter __A0 GetToolboxTrapAddress(__D0)
#endif
extern pascal UniversalProcPtr GetToolboxTrapAddress(short trapNum)
 ONEWORDINLINE(0xA746);

#if USES68KINLINES
#pragma parameter  SetToolboxTrapAddress(__A0, __D0)
#endif
extern pascal void SetToolboxTrapAddress(UniversalProcPtr trapAddr, short trapNum)
 ONEWORDINLINE(0xA647);
extern pascal OSErr WriteParam(void);

#if USES68KINLINES
#pragma parameter  Enqueue(__A0, __A1)
#endif
extern pascal void Enqueue(QElemPtr qElement, QHdrPtr qHeader)
 ONEWORDINLINE(0xA96F);

#if USES68KINLINES
#pragma parameter __D0 Dequeue(__A0, __A1)
#endif
extern pascal OSErr Dequeue(QElemPtr qElement, QHdrPtr qHeader)
 ONEWORDINLINE(0xA96E);
extern long SetCurrentA5(void)
 THREEWORDINLINE(0x200D, 0x2A78, 0x0904);

#if USES68KINLINES
#pragma parameter __D0 SetA5(__D0)
#endif
extern long SetA5(long newA5)
 ONEWORDINLINE(0xC18D);
#if !SystemSevenOrLater
extern pascal void Environs(short *rom, short *machine);
#endif

extern pascal OSErr HandToHand(Handle *theHndl);

#if USES68KINLINES
#pragma parameter __D0 PtrToXHand(__A0, __A1, __D0)
#endif
extern pascal OSErr PtrToXHand(const void *srcPtr, Handle dstHndl, long size)
 ONEWORDINLINE(0xA9E2);
extern pascal OSErr PtrToHand(const void *srcPtr, Handle *dstHndl, long size);

#if USES68KINLINES
#pragma parameter __D0 HandAndHand(__A0, __A1)
#endif
extern pascal OSErr HandAndHand(Handle hand1, Handle hand2)
 ONEWORDINLINE(0xA9E4);

#if USES68KINLINES
#pragma parameter __D0 PtrAndHand(__A0, __A1, __D0)
#endif
extern pascal OSErr PtrAndHand(const void *ptr1, Handle hand2, long size)
 ONEWORDINLINE(0xA9EF);

#if USES68KINLINES
#pragma parameter __D0 InitUtil
#endif
extern pascal OSErr InitUtil(void)
 ONEWORDINLINE(0xA03F);
#if defined(powerc) || defined(__powerc)
extern pascal void MakeDataExecutable(void *baseAddress, unsigned long length);
#else
extern pascal Boolean SwapInstructionCache(Boolean cacheEnable);
extern pascal void FlushInstructionCache(void);
extern pascal Boolean SwapDataCache(Boolean cacheEnable);
extern pascal void FlushDataCache(void);
#endif

extern pascal void ReadLocation(MachineLocation *loc)
 FIVEWORDINLINE(0x205F, 0x203C, 0x000C, 0x00E4, 0xA051);
extern pascal void WriteLocation(const MachineLocation *loc)
 FIVEWORDINLINE(0x205F, 0x203C, 0x000C, 0x00E4, 0xA052);
#if !USES68KINLINES
extern pascal UniversalProcPtr *GetTrapVector(short trapNumber);
#endif

#if OLDROUTINENAMES
#define LongDate2Secs(lDate, lSecs) LongDateToSeconds(lDate, lSecs)

#define LongSecs2Date(lSecs, lDate) LongSecondsToDate(lSecs, lDate)

#define IUMetric() IsMetric()

#define Date2Secs(d, secs) DateToSeconds(d, secs)

#define Secs2Date(secs, d) SecondsToDate(secs, d)

#endif

#ifdef __cplusplus
}
#endif

#endif

