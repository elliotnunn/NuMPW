/*
	File:		Editions.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __EDITIONS__
#define __EDITIONS__

#ifndef __MEMORY__
#include <Memory.h>
/*	#include <Types.h>											*/
/*		#include <ConditionalMacros.h>							*/
/*		#include <MixedMode.h>									*/
/*			#include <Traps.h>									*/
#endif

#ifndef __TYPES__
#endif

#ifndef __FILES__
#include <Files.h>
/*	#include <OSUtils.h>										*/
/*	#include <SegLoad.h>										*/
#endif

#ifndef __ALIASES__
#include <Aliases.h>
/*	#include <AppleTalk.h>										*/
#endif

#ifndef __DIALOGS__
#include <Dialogs.h>
/*	#include <Windows.h>										*/
/*		#include <Quickdraw.h>									*/
/*			#include <QuickdrawText.h>							*/
/*				#include <IntlResources.h>						*/
/*		#include <Events.h>										*/
/*		#include <Controls.h>									*/
/*			#include <Menus.h>									*/
/*	#include <TextEdit.h>										*/
#endif


/* resource types  */

#define rSectionType 'sect'


/* Finder types for edition files */

#define kPICTEditionFileType 'edtp'

#define kTEXTEditionFileType 'edtt'

#define ksndEditionFileType 'edts'

#define kUnknownEditionFileType 'edtu'

#define kPublisherDocAliasFormat 'alis'

#define kPreviewFormat 'prvw'

#define kFormatListFormat 'fmts'

enum  {
/* section types */
	stSubscriber				= 0x01,
	stPublisher					= 0x0A,
	sumAutomatic				= 0,							/* subscriber update mode - Automatically     */
	sumManual					= 1,							/* subscriber update mode - Manually */
	pumOnSave					= 0,							/* publisher update mode - OnSave            */
	pumManual					= 1,							/* publisher update mode - Manually */
	kPartsNotUsed				= 0,
	kPartNumberUnknown			= -1,							/* misc */
	kPreviewWidth				= 120,
	kPreviewHeight				= 120,
/* bits for formatsMask */
	kPICTformatMask				= 1,
	kTEXTformatMask				= 2,
	ksndFormatMask				= 4,
/* pseudo-item hits for dialogHooks 
 the first if for NewPublisher or NewSubscriber Dialogs */
	emHookRedrawPreview			= 150,
/* the following are for SectionOptions Dialog */
	emHookCancelSection			= 160,
	emHookGoToPublisher			= 161,
	emHookGetEditionNow			= 162,
	emHookSendEditionNow		= 162,
	emHookManualUpdateMode		= 163,
	emHookAutoUpdateMode		= 164
};

#define emOptionsDialogRefCon 'optn'

#define emCancelSectionDialogRefCon 'cncl'

#define emGoToPubErrDialogRefCon 'gerr'

enum  {
/* the refcon field of the dialog record during a modalfilter 
 or dialoghook contains one the following */
	kFormatLengthUnknown		= -1
};


/* one byte, stSubscriber or stPublisher */

typedef char SectionType;


/* seconds since 1904 */

typedef unsigned long TimeStamp;


/* similar to ResType */

typedef unsigned long FormatType;


/* used in Edition I/O */

typedef Handle EditionRefNum;


/* update modes */


/* sumAutomatic, pumSuspend, etc */

typedef short UpdateMode;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SectionRecord {
	SignedByte					version;						/* always 0x01 in system 7.0 */
	SectionType					kind;							/* stSubscriber or stPublisher */
	UpdateMode					mode;							/* auto or manual */
	TimeStamp					mdDate;							/* last change in document */
	long						sectionID;						/* app. specific, unique per document */
	long						refCon;							/* application specific */
	AliasHandle					alias;							/* handle to Alias Record */
	long						subPart;						/* which part of container file */
	struct SectionRecord		**nextSection;					/* for linked list of app's Sections */
	Handle						controlBlock;					/* used internally */
	EditionRefNum				refNum;							/* used internally */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SectionRecord SectionRecord;

typedef SectionRecord *SectionPtr, **SectionHandle;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct EditionContainerSpec {
	FSSpec						theFile;
	ScriptCode					theFileScript;
	long						thePart;
	Str31						thePartName;
	ScriptCode					thePartScript;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct EditionContainerSpec EditionContainerSpec;

typedef EditionContainerSpec *EditionContainerSpecPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct EditionInfoRecord {
	TimeStamp					crDate;							/* date EditionContainer was created */
	TimeStamp					mdDate;							/* date of last change */
	OSType						fdCreator;						/* file creator */
	OSType						fdType;							/* file type */
	EditionContainerSpec		container;						/* the Edition */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct EditionInfoRecord EditionInfoRecord;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct NewPublisherReply {
	Boolean						canceled;						/* O */
	Boolean						replacing;
	Boolean						usePart;						/* I */
	Handle						preview;						/* I */
	FormatType					previewFormat;					/* I */
	EditionContainerSpec		container;						/* I/O */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct NewPublisherReply NewPublisherReply;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct NewSubscriberReply {
	Boolean						canceled;						/* O */
	unsigned char				formatsMask;
	EditionContainerSpec		container;						/*I/O*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct NewSubscriberReply NewSubscriberReply;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SectionOptionsReply {
	Boolean						canceled;						/* O */
	Boolean						changed;						/* O */
	SectionHandle				sectionH;						/* I */
	ResType						action;							/* O */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SectionOptionsReply SectionOptionsReply;

typedef pascal Boolean (*ExpModalFilterProcPtr)(DialogPtr theDialog, EventRecord *theEvent, short itemOffset, short *itemHit, Ptr yourDataPtr);

enum {
	uppExpModalFilterProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(Boolean)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DialogPtr)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(EventRecord*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(short)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(short*)))
		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(Ptr)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr ExpModalFilterUPP;

#define CallExpModalFilterProc(userRoutine, theDialog, theEvent, itemOffset, itemHit, yourDataPtr)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppExpModalFilterProcInfo, (theDialog), (theEvent), (itemOffset), (itemHit), (yourDataPtr))
#define NewExpModalFilterProc(userRoutine)		\
		(ExpModalFilterUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppExpModalFilterProcInfo, GetCurrentISA())
#else
typedef ExpModalFilterProcPtr ExpModalFilterUPP;

#define CallExpModalFilterProc(userRoutine, theDialog, theEvent, itemOffset, itemHit, yourDataPtr)		\
		(*(userRoutine))((theDialog), (theEvent), (itemOffset), (itemHit), (yourDataPtr))
#define NewExpModalFilterProc(userRoutine)		\
		(ExpModalFilterUPP)(userRoutine)
#endif

typedef pascal short (*ExpDlgHookProcPtr)(short itemOffset, short itemHit, DialogPtr theDialog, Ptr yourDataPtr);

enum {
	uppExpDlgHookProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(short)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(DialogPtr)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(Ptr)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr ExpDlgHookUPP;

#define CallExpDlgHookProc(userRoutine, itemOffset, itemHit, theDialog, yourDataPtr)		\
		CallUniversalProc((UniversalProcPtr)(userRoutine), uppExpDlgHookProcInfo, (itemOffset), (itemHit), (theDialog), (yourDataPtr))
#define NewExpDlgHookProc(userRoutine)		\
		(ExpDlgHookUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppExpDlgHookProcInfo, GetCurrentISA())
#else
typedef ExpDlgHookProcPtr ExpDlgHookUPP;

#define CallExpDlgHookProc(userRoutine, itemOffset, itemHit, theDialog, yourDataPtr)		\
		(*(userRoutine))((itemOffset), (itemHit), (theDialog), (yourDataPtr))
#define NewExpDlgHookProc(userRoutine)		\
		(ExpDlgHookUPP)(userRoutine)
#endif

enum  {
	ioHasFormat,
	ioReadFormat,
	ioNewFormat,
	ioWriteFormat
};

typedef unsigned char FormatIOVerb;

enum  {
	eoOpen,
	eoClose,
	eoOpenNew,
	eoCloseNew,
	eoCanSubscribe
};

typedef unsigned char EditionOpenerVerb;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FormatIOParamBlock {
	long						ioRefNum;
	FormatType					format;
	long						formatIndex;
	unsigned long				offset;
	Ptr							buffPtr;
	unsigned long				buffLen;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FormatIOParamBlock FormatIOParamBlock;

typedef struct EditionOpenerParamBlock EditionOpenerParamBlock;

typedef pascal short (*FormatIOProcPtr)(FormatIOVerb selector, FormatIOParamBlock *PB);

typedef pascal short (*EditionOpenerProcPtr)(EditionOpenerVerb selector, EditionOpenerParamBlock *PB);

enum  {
	uppFormatIOProcInfo			= kPascalStackBased|RESULT_SIZE(kTwoByteCode)|STACK_ROUTINE_PARAMETER(1,kOneByteCode)|STACK_ROUTINE_PARAMETER(2,kFourByteCode),
	uppEditionOpenerProcInfo	= kPascalStackBased|RESULT_SIZE(kTwoByteCode)|STACK_ROUTINE_PARAMETER(1,kOneByteCode)|STACK_ROUTINE_PARAMETER(2,kFourByteCode)
};


/* Note: Use CallEditionOpenerProc and CallFormatIOProc to call these routines */

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr FormatIOUPP;

typedef UniversalProcPtr EditionOpenerUPP;

#define NewFormatIOProc(userRoutine)  \
	(FormatIOUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppFormatIOProcInfo, GetCurrentISA())

#define NewEditionOpenerProc(userRoutine)  \
	(EditionOpenerUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppEditionOpenerProcInfo, GetCurrentISA())

#else
typedef FormatIOProcPtr FormatIOUPP;

typedef EditionOpenerProcPtr EditionOpenerUPP;

#define NewFormatIOProc(userRoutine) (FormatIOUPP)(userRoutine)

#define NewEditionOpenerProc(userRoutine) (EditionOpenerUPP)(userRoutine)

#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct EditionOpenerParamBlock {
	EditionInfoRecord			info;
	SectionHandle				sectionH;
	FSSpecPtr					document;
	OSType						fdCreator;
	long						ioRefNum;
	FormatIOUPP					ioProc;
	Boolean						success;
	unsigned char				formatsMask;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif


/* 
 Section events now arrive in the message buffer using the AppleEvent format.
 The direct object parameter is an aeTemporaryIDParamType ('tid '). The temporary
 ID's type is rSectionType ('sect') and the 32-bit value is a SectionHandle.
 The following is a sample buffer
 
 name   offset contents
 ----   ------ --------
 
 header   0  'aevt'
 majorVersion 4  0x01
 minorVersion 6  0x01
 endOfMetaData 8  ';;;;' 
 directObjKey 12  '----' 
 paramType  16  'tid ' 
 paramLength  20  0x0008 
 tempIDType  24  'sect' 
 tempID    28  the SectionHandle <-- this is want you want*/

#define sectionEventMsgClass 'sect'

#define sectionReadMsgID 'read'

#define sectionWriteMsgID 'writ'

#define sectionScrollMsgID 'scrl'

#define sectionCancelMsgID 'cncl'

#define currentEditionMgrVers 0x0011

#ifdef __cplusplus
extern "C" {
#endif

#if !USESCODEFRAGMENTS
extern pascal OSErr InitEditionPack(void)
 FIVEWORDINLINE(0x3F3C, 0x0011, 0x303C, 0x0100, 0xA82D);
#else
extern pascal OSErr InitEditionPackVersion(short curEditionMgrVers)
 THREEWORDINLINE(0x303C, 0x0100, 0xA82D);
#define InitEditionPack() InitEditionPackVersion(currentEditionMgrVers)

#endif

extern pascal OSErr NewSection(const EditionContainerSpec *container, const FSSpec *sectionDocument, SectionType kind, long sectionID, UpdateMode initalMode, SectionHandle *sectionH)
 THREEWORDINLINE(0x303C, 0x0A02, 0xA82D);
extern pascal OSErr RegisterSection(const FSSpec *sectionDocument, SectionHandle sectionH, Boolean *aliasWasUpdated)
 THREEWORDINLINE(0x303C, 0x0604, 0xA82D);
extern pascal OSErr UnRegisterSection(SectionHandle sectionH)
 THREEWORDINLINE(0x303C, 0x0206, 0xA82D);
extern pascal OSErr IsRegisteredSection(SectionHandle sectionH)
 THREEWORDINLINE(0x303C, 0x0208, 0xA82D);
extern pascal OSErr AssociateSection(SectionHandle sectionH, const FSSpec *newSectionDocument)
 THREEWORDINLINE(0x303C, 0x040C, 0xA82D);
extern pascal OSErr CreateEditionContainerFile(const FSSpec *editionFile, OSType fdCreator, ScriptCode editionFileNameScript)
 THREEWORDINLINE(0x303C, 0x050E, 0xA82D);
extern pascal OSErr DeleteEditionContainerFile(const FSSpec *editionFile)
 THREEWORDINLINE(0x303C, 0x0210, 0xA82D);
extern pascal OSErr OpenEdition(SectionHandle subscriberSectionH, EditionRefNum *refNum)
 THREEWORDINLINE(0x303C, 0x0412, 0xA82D);
extern pascal OSErr OpenNewEdition(SectionHandle publisherSectionH, OSType fdCreator, const FSSpec *publisherSectionDocument, EditionRefNum *refNum)
 THREEWORDINLINE(0x303C, 0x0814, 0xA82D);
extern pascal OSErr CloseEdition(EditionRefNum whichEdition, Boolean successful)
 THREEWORDINLINE(0x303C, 0x0316, 0xA82D);
extern pascal OSErr EditionHasFormat(EditionRefNum whichEdition, FormatType whichFormat, Size *formatSize)
 THREEWORDINLINE(0x303C, 0x0618, 0xA82D);
extern pascal OSErr ReadEdition(EditionRefNum whichEdition, FormatType whichFormat, void *buffPtr, Size *buffLen)
 THREEWORDINLINE(0x303C, 0x081A, 0xA82D);
extern pascal OSErr WriteEdition(EditionRefNum whichEdition, FormatType whichFormat, const void *buffPtr, Size buffLen)
 THREEWORDINLINE(0x303C, 0x081C, 0xA82D);
extern pascal OSErr GetEditionFormatMark(EditionRefNum whichEdition, FormatType whichFormat, unsigned long *currentMark)
 THREEWORDINLINE(0x303C, 0x061E, 0xA82D);
extern pascal OSErr SetEditionFormatMark(EditionRefNum whichEdition, FormatType whichFormat, unsigned long setMarkTo)
 THREEWORDINLINE(0x303C, 0x0620, 0xA82D);
extern pascal OSErr GetEditionInfo(const SectionHandle sectionH, EditionInfoRecord *editionInfo)
 THREEWORDINLINE(0x303C, 0x0422, 0xA82D);
extern pascal OSErr GoToPublisherSection(const EditionContainerSpec *container)
 THREEWORDINLINE(0x303C, 0x0224, 0xA82D);
extern pascal OSErr GetLastEditionContainerUsed(EditionContainerSpec *container)
 THREEWORDINLINE(0x303C, 0x0226, 0xA82D);
extern pascal OSErr GetStandardFormats(const EditionContainerSpec *container, FormatType *previewFormat, Handle preview, Handle publisherAlias, Handle formats)
 THREEWORDINLINE(0x303C, 0x0A28, 0xA82D);
extern pascal OSErr GetEditionOpenerProc(EditionOpenerUPP *opener)
 THREEWORDINLINE(0x303C, 0x022A, 0xA82D);
extern pascal OSErr SetEditionOpenerProc(EditionOpenerUPP opener)
 THREEWORDINLINE(0x303C, 0x022C, 0xA82D);
extern pascal OSErr CallEditionOpenerProc(EditionOpenerVerb selector, EditionOpenerParamBlock *PB, EditionOpenerUPP routine)
 THREEWORDINLINE(0x303C, 0x052E, 0xA82D);
extern pascal OSErr CallFormatIOProc(FormatIOVerb selector, FormatIOParamBlock *PB, FormatIOUPP routine)
 THREEWORDINLINE(0x303C, 0x0530, 0xA82D);
extern pascal OSErr NewSubscriberDialog(NewSubscriberReply *reply)
 THREEWORDINLINE(0x303C, 0x0232, 0xA82D);
extern pascal OSErr NewSubscriberExpDialog(NewSubscriberReply *reply, Point where, short expansionDITLresID, ExpDlgHookUPP dlgHook, ExpModalFilterUPP filter, void *yourDataPtr)
 THREEWORDINLINE(0x303C, 0x0B34, 0xA82D);
extern pascal OSErr NewPublisherDialog(NewPublisherReply *reply)
 THREEWORDINLINE(0x303C, 0x0236, 0xA82D);
extern pascal OSErr NewPublisherExpDialog(NewPublisherReply *reply, Point where, short expansionDITLresID, ExpDlgHookUPP dlgHook, ExpModalFilterUPP filter, void *yourDataPtr)
 THREEWORDINLINE(0x303C, 0x0B38, 0xA82D);
extern pascal OSErr SectionOptionsDialog(SectionOptionsReply *reply)
 THREEWORDINLINE(0x303C, 0x023A, 0xA82D);
extern pascal OSErr SectionOptionsExpDialog(SectionOptionsReply *reply, Point where, short expansionDITLresID, ExpDlgHookUPP dlgHook, ExpModalFilterUPP filter, void *yourDataPtr)
 THREEWORDINLINE(0x303C, 0x0B3C, 0xA82D);
#ifdef __cplusplus
}
#endif

#endif

