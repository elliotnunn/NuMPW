/*
	File:		TextUtils.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __TEXTUTILS__
#define __TEXTUTILS__

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

#ifndef __SCRIPT__
#include <Script.h>
/*	#include <Quickdraw.h>										*/
/*		#include <QuickdrawText.h>								*/
/*			#include <IntlResources.h>							*/
/*	#include <Events.h>											*/
/*		#include <OSUtils.h>									*/
#endif

#ifndef __OSUTILS__
#endif


/* New constants for System 7.0: */

enum  {
/* Constants for truncWhere argument in TruncString and TruncText */
	truncEnd					= 0,							/* Truncate at end */
	truncMiddle					= 0x4000,						/* Truncate in middle */
	smTruncEnd					= 0,							/* Truncate at end - obsolete */
	smTruncMiddle				= 0x4000,						/* Truncate in middle - obsolete */
/* Constants for TruncString and TruncText results */
	notTruncated				= 0,							/* No truncation was necessary */
	truncated					= 1,							/* Truncation performed */
	truncErr					= -1,							/* General error */
	smNotTruncated				= 0,							/* No truncation was necessary - obsolete */
	smTruncated					= 1,							/* Truncation performed	- obsolete */
	smTruncErr					= -1							/* General error - obsolete */
};

enum  {
	fVNumber					= 0,							/* first version of NumFormatString */
/* Special language code values for Language Order */
	systemCurLang				= -2,							/* current (itlbLang) lang for system script */
	systemDefLang				= -3,							/* default (table) lang for system script */
	currentCurLang				= -4,							/* current (itlbLang) lang for current script */
	currentDefLang				= -5,							/* default lang for current script */
	scriptCurLang				= -6,							/* current (itlbLang) lang for specified script */
	scriptDefLang				= -7							/* default language for a specified script */
};

enum  {
	iuSystemCurLang				= -2,							/* <obsolete> current (itlbLang) lang for system script */
	iuSystemDefLang				= -3,							/* <obsolete> default (table) lang for system script */
	iuCurrentCurLang			= -4,							/* <obsolete> current (itlbLang) lang for current script */
	iuCurrentDefLang			= -5,							/* <obsolete> default lang for current script */
	iuScriptCurLang				= -6							/* <obsolete> current (itlbLang) lang for specified script */
};

enum  {
/* <obsolete> default language for a specified script */
	iuScriptDefLang				= -7
};

enum  {
	smBreakWord,
	smBreakChar,
	smBreakOverflow
};

typedef unsigned char StyledLineBreakCode;

enum  {
	fPositive,
	fNegative,
	fZero
};

typedef unsigned char FormatClass;

enum  {
	fFormatOK,
	fBestGuess,
	fOutOfSynch,
	fSpuriousChars,
	fMissingDelimiter,
	fExtraDecimal,
	fMissingLiteral,
	fExtraExp,
	fFormatOverflow,
	fFormStrIsNAN,
	fBadPartsTable,
	fExtraPercent,
	fExtraSeparator,
	fEmptyFormatString
};

typedef unsigned char FormatResultType;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct NumFormatString {
	char						fLength;
	char						fVersion;
	char						data[254];						/* private data */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct NumFormatString NumFormatString;

typedef struct NumFormatString NumFormatStringRec;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FVector {
	short						start;
	short						length;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FVector FVector;


/* index by [fPositive..fZero] */

typedef FVector TripleInt[3];

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct ScriptRunStatus {
	char						script;
	char						variant;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct ScriptRunStatus ScriptRunStatus;


/* New types for System 7.0: */


/* Type for truncWhere parameter in new TruncString, TruncText */

typedef short TruncCode;

enum  {
	shortDate,
	longDate,
	abbrevDate
};

typedef unsigned char DateForm;

enum  {
/* String2Date status values */
	fatalDateTime				= 0x8000,						/* String2Date and String2Time mask to a fatal error */
	longDateFound				= 1,							/* String2Date mask to long date found */
	leftOverChars				= 2,							/* String2Date & Time mask to warn of left over characters */
	sepNotIntlSep				= 4,							/* String2Date & Time mask to warn of non-standard separators */
	fieldOrderNotIntl			= 8,							/* String2Date & Time mask to warn of non-standard field order */
	extraneousStrings			= 16,							/* String2Date & Time mask to warn of unparsable strings in text */
	tooManySeps					= 32,							/* String2Date & Time mask to warn of too many separators */
	sepNotConsistent			= 64,							/* String2Date & Time mask to warn of inconsistent separators */
	tokenErr					= 0x8100,						/* String2Date & Time mask for 'tokenizer err encountered' */
	cantReadUtilities			= 0x8200,
	dateTimeNotFound			= 0x8400,
	dateTimeInvalid				= 0x8800
};

typedef short StringToDateStatus;

typedef short String2DateStatus;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct DateCacheRecord {
	short						hidden[256];					/* only for temporary use */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct DateCacheRecord DateCacheRecord;

typedef DateCacheRecord *DateCachePtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct BreakTable {
	char						charTypes[256];
	short						tripleLength;
	short						triples[1];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct BreakTable BreakTable;

typedef BreakTable *BreakTablePtr;


/* New NBreakTable for System 7.0: */

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct NBreakTable {
	signed char					flags1;
	signed char					flags2;
	short						version;
	short						classTableOff;
	short						auxCTableOff;
	short						backwdTableOff;
	short						forwdTableOff;
	short						doBackup;
	short						length;							/* length of NBreakTable */
	char						charTypes[256];
	short						tables[1];
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct NBreakTable NBreakTable;

typedef NBreakTable *NBreakTablePtr;

#ifdef __cplusplus
extern "C" {
#endif

extern pascal void IUDateString(long dateTime, DateForm longFlag, Str255 result)
 TWOWORDINLINE(0x4267, 0xA9ED);
extern void iudatestring(long dateTime, DateForm longFlag, char *result);
extern pascal void IUDatePString(long dateTime, DateForm longFlag, Str255 result, Handle intlHandle)
 THREEWORDINLINE(0x3F3C, 0x000E, 0xA9ED);
extern void iudatepstring(long dateTime, DateForm longFlag, char *result, Handle intlHandle);
extern pascal void IUTimeString(long dateTime, Boolean wantSeconds, Str255 result)
 THREEWORDINLINE(0x3F3C, 0x0002, 0xA9ED);
extern void iutimestring(long dateTime, Boolean wantSeconds, char *result);
extern pascal void IUTimePString(long dateTime, Boolean wantSeconds, Str255 result, Handle intlHandle)
 THREEWORDINLINE(0x3F3C, 0x0010, 0xA9ED);
extern void iutimepstring(long dateTime, Boolean wantSeconds, char *result, Handle intlHandle);
extern pascal void IULDateString(LongDateTime *dateTime, DateForm longFlag, Str255 result, Handle intlHandle)
 THREEWORDINLINE(0x3F3C, 0x0014, 0xA9ED);
extern void iuldatestring(LongDateTime *dateTime, DateForm longFlag, char *result, Handle intlHandle);
extern pascal void IULTimeString(LongDateTime *dateTime, Boolean wantSeconds, Str255 result, Handle intlHandle)
 THREEWORDINLINE(0x3F3C, 0x0016, 0xA9ED);
extern void iultimestring(LongDateTime *dateTime, Boolean wantSeconds, char *result, Handle intlHandle);
extern pascal OSErr InitDateCache(DateCachePtr theCache)
 FOURWORDINLINE(0x2F3C, 0x8204, 0xFFF8, 0xA8B5);
extern pascal StringToDateStatus StringToDate(Ptr textPtr, long textLen, DateCachePtr theCache, long *lengthUsed, LongDateRec *dateTime)
 FOURWORDINLINE(0x2F3C, 0x8214, 0xFFF6, 0xA8B5);
extern pascal StringToDateStatus StringToTime(Ptr textPtr, long textLen, DateCachePtr theCache, long *lengthUsed, LongDateRec *dateTime)
 FOURWORDINLINE(0x2F3C, 0x8214, 0xFFF4, 0xA8B5);
extern pascal Boolean EqualString(ConstStr255Param str1, ConstStr255Param str2, Boolean caseSens, Boolean diacSens);
extern Boolean equalstring(char *str1, char *str2, Boolean caseSens, Boolean diacSens);
extern pascal void UpperString(Str255 theString, Boolean diacSens);
extern void upperstring(char *theString, Boolean diacSens);
extern pascal short RelString(ConstStr255Param str1, ConstStr255Param str2, Boolean caseSens, Boolean diacSens);
extern short relstring(char *str1, char *str2, Boolean caseSens, Boolean diacSens);
extern pascal StringHandle GetString(short stringID)
 ONEWORDINLINE(0xA9BA);
extern pascal long Munger(Handle h, long offset, const void *ptr1, long len1, const void *ptr2, long len2)
 ONEWORDINLINE(0xA9E0);
extern pascal void SetString(StringHandle theString, ConstStr255Param strNew)
 ONEWORDINLINE(0xA907);
extern void setstring(StringHandle theString, char *strNew);
extern pascal StringHandle NewString(ConstStr255Param theString)
 ONEWORDINLINE(0xA906);
extern StringHandle newstring(char *theString);
extern pascal void GetIndString(Str255 theString, short strListID, short index);
extern void getindstring(char *theString, short strListID, short index);

/* following four will be obsolete. Use equivalent PString call and pass a NIL handle */

extern pascal short IUMagString(const void *aPtr, const void *bPtr, short aLen, short bLen)
 THREEWORDINLINE(0x3F3C, 0x000A, 0xA9ED);
extern pascal short IUMagIDString(const void *aPtr, const void *bPtr, short aLen, short bLen)
 THREEWORDINLINE(0x3F3C, 0x000C, 0xA9ED);
extern pascal short IUCompString(ConstStr255Param aStr, ConstStr255Param bStr);
extern short iucompstring(char *aStr, char *bStr);
extern pascal short IUEqualString(ConstStr255Param aStr, ConstStr255Param bStr);
extern short iuequalstring(char *aStr, char *bStr);
extern pascal void StringToNum(ConstStr255Param theString, long *theNum);
extern void stringtonum(char *theString, long *theNum);
extern pascal void NumToString(long theNum, Str255 theString);
extern void numtostring(long theNum, char *theString);
extern pascal short IUMagPString(const void *aPtr, const void *bPtr, short aLen, short bLen, Handle itl2Handle)
 THREEWORDINLINE(0x3F3C, 0x001A, 0xA9ED);
extern pascal short IUMagIDPString(const void *aPtr, const void *bPtr, short aLen, short bLen, Handle itl2Handle)
 THREEWORDINLINE(0x3F3C, 0x001C, 0xA9ED);
extern pascal short IUCompPString(ConstStr255Param aStr, ConstStr255Param bStr, Handle itl2Handle);
extern short iucomppstring(char *aStr, char *bStr, Handle intlHandle);
extern pascal short IUEqualPString(ConstStr255Param aStr, ConstStr255Param bStr, Handle itl2Handle);
extern short iuequalpstring(char *aStr, char *bStr, Handle intlHandle);
extern pascal short ScriptOrder(ScriptCode script1, ScriptCode script2)
 THREEWORDINLINE(0x3F3C, 0x001E, 0xA9ED);
extern pascal short IUScriptOrder(ScriptCode script1, ScriptCode script2)
 THREEWORDINLINE(0x3F3C, 0x001E, 0xA9ED);
extern pascal short IULangOrder(LangCode language1, LangCode language2)
 THREEWORDINLINE(0x3F3C, 0x0020, 0xA9ED);
extern pascal short IUTextOrder(const void *aPtr, const void *bPtr, short aLen, short bLen, ScriptCode aScript, ScriptCode bScript, LangCode aLang, LangCode bLang)
 THREEWORDINLINE(0x3F3C, 0x0022, 0xA9ED);
extern pascal short IUStringOrder(ConstStr255Param aStr, ConstStr255Param bStr, ScriptCode aScript, ScriptCode bScript, LangCode aLang, LangCode bLang);
extern short iustringorder(char *aStr, char *bStr, ScriptCode aScript, ScriptCode bScript, LangCode aLang, LangCode bLang);
extern pascal void FindWord(Ptr textPtr, short textLength, short offset, Boolean leadingEdge, BreakTablePtr breaks, OffsetTable offsets)
 FOURWORDINLINE(0x2F3C, 0x8012, 0x001A, 0xA8B5);
extern pascal void FindWordBreaks(Ptr textPtr, short textLength, short offset, Boolean leadingEdge, BreakTablePtr breaks, OffsetTable offsets, ScriptCode script)
 FOURWORDINLINE(0x2F3C, 0xC012, 0x001A, 0xA8B5);
extern pascal void UprText(Ptr textPtr, short len)
 THREEWORDINLINE(0x301F, 0x205F, 0xA054);
extern pascal void LwrText(Ptr textPtr, short len)
 THREEWORDINLINE(0x301F, 0x205F, 0xA056);

/*  New for 7.0  */

extern pascal void LowerText(Ptr textPtr, short len)
 THREEWORDINLINE(0x301F, 0x205F, 0xA056);
extern pascal void StripText(Ptr textPtr, short len)
 THREEWORDINLINE(0x301F, 0x205F, 0xA256);
extern pascal void UpperText(Ptr textPtr, short len)
 THREEWORDINLINE(0x301F, 0x205F, 0xA456);
extern pascal void StripUpperText(Ptr textPtr, short len)
 THREEWORDINLINE(0x301F, 0x205F, 0xA656);
extern pascal StyledLineBreakCode StyledLineBreak(Ptr textPtr, long textLen, long textStart, long textEnd, long flags, Fixed *textWidth, long *textOffset)
 FOURWORDINLINE(0x2F3C, 0x821C, 0xFFFE, 0xA8B5);
extern pascal FormatStatus StringToFormatRec(ConstStr255Param inString, const NumberParts *partsTable, NumFormatString *outString)
 FOURWORDINLINE(0x2F3C, 0x820C, 0xFFEC, 0xA8B5);
extern pascal FormatStatus FormatRecToString(const NumFormatString *myCanonical, const NumberParts *partsTable, Str255 outString, TripleInt positions)
 FOURWORDINLINE(0x2F3C, 0x8210, 0xFFEA, 0xA8B5);
extern pascal FormatStatus ExtendedToString(extended80 *x, const NumFormatString *myCanonical, const NumberParts *partsTable, Str255 outString)
 FOURWORDINLINE(0x2F3C, 0x8210, 0xFFE8, 0xA8B5);
extern pascal FormatStatus StringToExtended(ConstStr255Param source, const NumFormatString *myCanonical, const NumberParts *partsTable, extended80 *x)
 FOURWORDINLINE(0x2F3C, 0x8210, 0xFFE6, 0xA8B5);
extern pascal ScriptRunStatus FindScriptRun(Ptr textPtr, long textLen, long *lenUsed)
 FOURWORDINLINE(0x2F3C, 0x820C, 0x0026, 0xA8B5);
extern pascal void NFindWord(Ptr textPtr, short textLength, short offset, Boolean leadingEdge, NBreakTablePtr nbreaks, OffsetTable offsets)
 FOURWORDINLINE(0x2F3C, 0x8012, 0xFFE2, 0xA8B5);
extern pascal short TruncString(short width, Str255 theString, TruncCode truncWhere)
 FOURWORDINLINE(0x2F3C, 0x8208, 0xFFE0, 0xA8B5);
extern pascal short TruncText(short width, Ptr textPtr, short *length, TruncCode truncWhere)
 FOURWORDINLINE(0x2F3C, 0x820C, 0xFFDE, 0xA8B5);
extern pascal short ReplaceText(Handle baseText, Handle substitutionText, Str15 key)
 FOURWORDINLINE(0x2F3C, 0x820C, 0xFFDC, 0xA8B5);
extern pascal void LowercaseText(Ptr textPtr, short len, ScriptCode script)
 SIXWORDINLINE(0x3F3C, 0x0000, 0x2F3C, 0x800A, 0xFFB6, 0xA8B5);
extern pascal void StripDiacritics(Ptr textPtr, short len, ScriptCode script)
 SIXWORDINLINE(0x3F3C, 0x0200, 0x2F3C, 0x800A, 0xFFB6, 0xA8B5);
extern pascal void UppercaseText(Ptr textPtr, short len, ScriptCode script)
 SIXWORDINLINE(0x3F3C, 0x0400, 0x2F3C, 0x800A, 0xFFB6, 0xA8B5);
extern pascal void UppercaseStripDiacritics(Ptr textPtr, short len, ScriptCode script)
 SIXWORDINLINE(0x3F3C, 0x0600, 0x2F3C, 0x800A, 0xFFB6, 0xA8B5);
#if OLDROUTINENAMES
#define LongDateString(dateTime, longFlag, result, intlHandle)  \
	IULDateString(dateTime, longFlag, result, intlHandle)

#define longdatestring(dateTime, longFlag, result, intlHandle)  \
	iuldatestring(dateTime, longFlag, result, intlHandle)

#define LongTimeString(dateTime, wantSeconds, result, intlHandle)  \
	IULDateString(dateTime, wantSeconds, result, intlHandle)

#define longtimestring(dateTime, wantSeconds, result, intlHandle)  \
	iultimestring(dateTime, wantSeconds, result, intlHandle)

#define String2Date(textPtr, textLen, theCache, lengthUsed, dateTime)  \
	StringToDate(textPtr, textLen, theCache, lengthUsed, dateTime)

#define String2Time(textPtr, textLen, theCache, lengthUsed, dateTime)  \
	StringToTime(textPtr, textLen, theCache, lengthUsed, dateTime)

#define UprString(theString, diacSens) UpperString(theString, diacSens)

#define uprstring(theString, diacSens) upperstring(theString, diacSens)

#define CompareString(aStr, bStr, itl2Handle) IUCompPString(aStr, bStr, itl2Handle)

#define comparestring(aStr, bStr, intlHandle) iucomppstring(aStr, bStr, intlHandle)

#define CompareText(aPtr, bPtr, aLen, bLen, itl2Handle)  \
	IUMagPString(aPtr, bPtr, aLen, bLen, itl2Handle)

#define IdenticalText(aPtr, bPtr, aLen, bLen, itl2Handle)  \
	IUMagIDPString(aPtr, bPtr, aLen, bLen, itl2Handle)

#define IdenticalString(aStr, bStr, itl2Handle) IUEqualPString(aStr, bStr, itl2Handle)

#define identicalstring(aStr, bStr, intlHandle) iuequalpstring(aStr, bStr, intlHandle)

#define LanguageOrder(language1, language2) IULangOrder(language1, language2)

#define TextOrder(aPtr, bPtr, aLen, bLen, aScript, bScript, aLang, bLang)  \
	IUTextOrder(aPtr, bPtr, aLen, bLen, aScript, bScript, aLang, bLang)

#define StringOrder(aStr, bStr, aScript, bScript, aLang, bLang)  \
	IUStringOrder(aStr, bStr, aScript, bScript, aLang, bLang)

#define Str2Format(inString, partsTable, outString)  \
	StringToFormatRec(inString, partsTable, outString)

#define Format2Str(myCanonical, partsTable, outString, positions)  \
	FormatRecToString(myCanonical, partsTable, outString, positions)

#define FormatX2Str(x, myCanonical, partsTable, outString)  \
	ExtendedToString(x, myCanonical, partsTable, outString)

#define FormatStr2X(source, myCanonical, partsTable, x)  \
	StringToExtended(source, myCanonical, partsTable, x)

#define DateString(dateTime, longFlag, result, intlHandle)  \
	IUDatePString(dateTime, longFlag, result, intlHandle)

#define datestring(dateTime, longFlag, result, intlHandle)  \
	iudatepstring(dateTime, longFlag, result, intlHandle)

#define TimeString(dateTime, wantSeconds, result, intlHandle)  \
	IUTimePString(dateTime, wantSeconds, result, intlHandle)

#define timestring(dateTime, wantSeconds, result, intlHandle)  \
	iutimepstring(dateTime, wantSeconds, result, intlHandle)

#endif

#ifdef __cplusplus
}
#endif

#endif

