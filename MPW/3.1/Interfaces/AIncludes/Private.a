; Version: 2.83
; Created: Monday, September 25, 1989 at 10:38:59 AM
;
; File: Private.a
;
; Assembler Interface to the Macintosh Libraries
; Copyright Apple Computer, Inc. 1986-1988
; All Rights Reserved
;
;
; The following information was formerly in "private" files that were
; not released to the general developer community.
;
; The information in this file is not needed for normal application
; development. These equates and macros were necessary for development
; of the Macintosh ToolBox and Operating System, and are likely to be
; dependent on their current implementation. Use of any information
; in this file is likely to cause your software to fail on future
; versions of Macintosh system software or hardware.
;
; Apple Developer Support will not support any use of the following
; information.
;
; In order to prevent any "accidental" use of this information, it has
; been disabled using the conditional-assembly variable defined below.
; If you change this to a non-zero value, you're on your own.
;___________________________________________________________________________



				IF			(&TYPE('PrNonPortable') = 'UNDEFINED') THEN
PrNonPortable	EQU 		0
				ENDIF

				IF			PrNonPortable THEN


;_______________________________________________________________________
;
; System Equates -- These equates supplement the low-level equates for the
; Macintosh hardware and software defined in SysEqu. These equates are private
; to Apple Computer, Inc. and should be used solely for building system
; software.
;
;_______________________________________________________________________

;+ Hardware Address Equates (for 512K through 128K Macs)

; Unpacked, user versions of parameter ram

SdEnable		EQU 		$261					; Sound enabled? [byte]

; Event Record Definition

evtMax			EQU 		$1E 					; maximum number of events in buffer

; Heap Zone header

spare1			EQU 		$2C 					; unused spare [long]


; Mouse/Keyboard

Tocks			EQU 		$173					; Lisa sub-tick count [byte]

;Chooser

ChooserBits 	EQU 		$946					; bit 7 = 0, don't run; bit 6 = 0, gray out Appletalk
minFree 		EQU 		12						; (minimum block size) for old MemManager
freeTag 		EQU 		$0						; Tag for Free block
nRelTag 		EQU 		$40000000				; Tag for Non-Relocatable block
relTag			EQU 		$80000000				; Tag for Relocatable block
minAddr 		EQU 		$0						; Min legal address
maxAddr 		EQU 		$800000 				; Max legal address for 512K machine
maxMasters		EQU 		$1000					; Ridiculously large allocation chunk size
dfltMasters 	EQU 		32						; Default to 32 master pointers

; Driver Status record definition

dsQType 		EQU 		$A
														; not used [word]
dsNeedsFlush	EQU 		$13 					; reserved [byte]

;This variable was named RetryCount in SONYEqu

SONYRetry		EQU 		5
SonyVars		EQU 		$134					; 3-1/2 disk driver vars [pointer]
DskRtnAdr		EQU 		$124					; temp for disk driver [pointer]
PollRtnAddr 	EQU 		$128					; 'other' driver locals [pointer]
PWMValue		EQU 		$138					; current PWM value [word]
PollStack		EQU 		$13A					; SCC poll data start stack location [pointer]
PollProc		EQU 		$13E					; SCC poll data procedure [pointer]
DiskVars		EQU 		$222					; Disk driver variables [62 bytes]


LastPGlobal 	EQU 		$954					; address of last printer global

; QuickDraw Glue Vectors

JHideCursor 	EQU 		$800
JShowCursor 	EQU 		$804
JShieldCursor	EQU 		$808
JScrnAddr		EQU 		$80C
JScrnSize		EQU 		$810
JInitCrsr		EQU 		$814
JSetCrsr		EQU 		$818
JCrsrObscure	EQU 		$81C
JUpdateProc 	EQU 		$820
LGrafJump		EQU 		$824
JSwapFont		EQU 		$8E0					; jump entry for FMSwapFont [long]
JFontInfo		EQU 		$8E4					; jump entry for FMFontMetrics [long]

; Miscellaneous Globals

SysCom			EQU 		$100					; start of system communication area
DispatchTab 	EQU 		$400					; A-Trap dispatch table [1024 bytes]
OSTable 		EQU 		$0400					; 256 longs, up to $800, where old table of 512 words was
toolDisp		EQU 		10						; bit #10 distinguishes Tool/OS Get/Set Trap address
oldDisp 		EQU 		9						; bit #9 distinguishes Old/New trap numbering
; moved HeapStart equate to hwequ file <C1/14Apr86>
; moved DoEject equate to hwequ file <C1/14Apr86>

FontFlag		EQU 		$15E					; font manager loop flag [byte]
JShell			EQU 		$212					; journaling shell state [wprd]
MacJmp			EQU 		$120					; MACSBUG jumptable [pointer]
MacJmpFlag		EQU 		$BFF					; MacsBug flag [byte]
FileVars		EQU 		$340					; file system vars [184 bytes]
LoadVars		EQU 		$900					; loader variables [68 bytes]
LastLGlobal 	EQU 		$944					; address past last loader global
CoreEditVars	EQU 		$954					; core edit variables [12 bytes]
ScreenVars		EQU 		$292					; Screen driver variables [8 bytes]
SoundVars		EQU 		$262					; Sound driver variables [32 bytes]
BootGlobPtr 	EQU 		$DDC					; ptr to BootGlobs record at top of memory <2.9><3.2><3.3>

; Font Manager Low Memory Globals

FOutError		EQU 		$998					; error code
FOutFontHandle	EQU 		$99A					; handle to font bits
FOutBold		EQU 		$99E					; bolding factor
FOutItalic		EQU 		$99F					; italic factor
FOutULOffset	EQU 		$9A0					; underline offset
FOutULShadow	EQU 		$9A1					; underline halo
FOutULThick 	EQU 		$9A2					; underline thickness
FOutShadow		EQU 		$9A3					; shadow factor
FOutExtra		EQU 		$9A4					; extra horizontal width
FOutAscent		EQU 		$9A5					; height above baseline
FOutDescent 	EQU 		$9A6					; height below baseline
FOutWidMax		EQU 		$9A7					; maximum width of character
FOutLeading 	EQU 		$9A8					; space between lines
FOutUnused		EQU 		$9A9					; unused byte (must have even number)
FOutNumer		EQU 		$9AA					; point for numerators of scale factor
FOutDenom		EQU 		$9AE					; point for denominators of scale factor

;_______________________________________________________________________
;
; Toolbox Equates -- These equates supplement the high-level equates for the
; Macintosh toolbox software in ToolEqu.a. These equates are private
; to Apple Computer, Inc. and should be used solely for building system
; software.
;
;_______________________________________________________________________

DeskPort		EQU 		$9E2					; Desk grafPort (Whole screen) [pointer]

;_______________________________________________________________________
;
; QuickDraw Equates -- This file supplements the public equates for QuickDraw.
; found in the file QuickEqu.a These equates are private
; to Apple Computer, Inc. and should be used solely for building system
; software.
;
;_______________________________________________________________________

symbols 		EQU 		0
forMac			EQU 		1

; Region State record

rgnPtr			EQU 		$0						; [handle]
dataPtr 		EQU 		$4						; [handle]
scanBuf 		EQU 		$8						; [pointer]
scanSize		EQU 		$C						; [word]
thisV			EQU 		$E						; [word]
nextV			EQU 		$10 					; [word]
minH			EQU 		$12 					; [word]
maxH			EQU 		$14 					; [word]
leftH			EQU 		$16 					; [word]
rgnRec			EQU 		$18 					; size of as region record

;-----------------------------------------------------
;
; Offsets in a PicSave record:
;
thePic			EQU 		0						;PICHANDLE
picMax			EQU 		4						;LongInt
picIndex		EQU 		8						;LongInt
picClipRgn		EQU 		12						;RgnHandle
picBkPat		EQU 		16						;Pattern
picTxFont		EQU 		24						;WORD
picTxFace		EQU 		26						;Style
picTxMode		EQU 		28						;WORD
picTxSize		EQU 		30						;WORD
picSpExtra		EQU 		32						;Fixed Point
picTxNumer		EQU 		36						;Point
picTxDenom		EQU 		40						;Point
picTxLoc		EQU 		44						;Point
picPnLoc		EQU 		48						;Point
picPnSize		EQU 		52						;Point
picPnMode		EQU 		56						;WORD
picPnPat		EQU 		58						;Pattern
picFillPat		EQU 		66						;Pattern
picTheRect		EQU 		74						;Rect
picOvSize		EQU 		82						;Point
picOrigin		EQU 		86						;Point
picFgColor		EQU 		90						;Long
picBkColor		EQU 		94						;Long
picSaveRec		EQU 		98						;total size in bytes

; Quickdraw privates

; additional offsets in a PicSave record

picVersion		EQU 		98						;WORD
picRGBFgCol 	EQU 		100 					;RGB (6 bytes)
picRGBBkCol 	EQU 		106 					;RGB (6 bytes)
picChExtra		EQU 		112 					;WORD
picLocHFrac 	EQU 		114 					;WORD
picRGBOpColor	EQU 		116 					;RGB (6 bytes)
picRGBHiColor	EQU 		122 					;RGB (6 bytes)
picFillPP		EQU 		128 					;Handle
picPnPP 		EQU 		132 					;Handle
picBkPP 		EQU 		136 					;Handle
npicSaveRec 	EQU 		140 					;total size in bytes
pictVersion 	EQU 		1						;version number for pict
npicVersion 	EQU 		$2FF					;version number for npic

;-----------------------------------------------
;
; PICTURE OPCODES
;

opNOP			EQU 		$0						; nop opcode
opClip			EQU 		$1						; clip opcode
opBkPat 		EQU 		$2						; background pattern opcode
opTxFont		EQU 		$3						; text font opcode
opTxFace		EQU 		$4						; text face opcode
opTxMode		EQU 		$5						; text mode opcode
opSpExtra		EQU 		$6						; space extra opcode
opPnSize		EQU 		$7						; pen size opcode
opPnMode		EQU 		$8						; pen mode opcode
opPnPat 		EQU 		$9						; pen pattern opcode
opFillPat		EQU 		$A						; fill pattern opcode
opOvSize		EQU 		$B						; oval size opcode
opOrigin		EQU 		$C						; origin opcode
opTxSize		EQU 		$D						; text size opcode
opFgColor		EQU 		$E						; foreground color opcode
opBkColor		EQU 		$F						; background color opcode
opTxRatio		EQU 		$10 					; text ratio opcode
opVersion		EQU 		$11 					; version opcode
opBkPixPat		EQU 		$12 					; color background pattern opcode
opPnPixPat		EQU 		$13 					; color pen pattern opcode
opFillPixPat	EQU 		$14 					; color fill pattern opcode
opPnLocHFrac	EQU 		$15 					; fractional pen position opcode
opChExtra		EQU 		$16 					; extra for each character

; opcode $17 unused

opIFore 		EQU 		$18 					; foreColor index opcode
opIBack 		EQU 		$19 					; backColor index opcode
opRGBFgCol		EQU 		$1A 					; RGB foreColor opcode
opRGBBkCol		EQU 		$1B 					; RGB backColor opcode
opHiliteMode	EQU 		$1C 					; hilite mode flag
opHiliteColor	EQU 		$1D 					; RGB hilite color
opDefHilite 	EQU 		$1E 					; Use default hilite color
opOpColor		EQU 		$1F 					; RGB OpColor for arithmetic modes
opLine			EQU 		$20 					; line opcode
opLineFrom		EQU 		$21 					; line from opcode
opShortLine 	EQU 		$22 					; short line opcode
opShortLineFrom   EQU		$23 					; short line from opcode
opLongText		EQU 		$28 					; long text opcode
opDHText		EQU 		$29 					; dh text opcode
opDVText		EQU 		$2A 					; dv text opcode
opDHDVText		EQU 		$2B 					; dh,dv text opcode
opBitsRect		EQU 		$90 					; copybits, rect clipped opcode
opBitsRgn		EQU 		$91 					; copybits, rgn clipped opcode
opPackBitsRect	EQU 		$98 					; packed copybits, rect clipped opcode
opPackBitsRgn	EQU 		$99 					; packed copybits, rgn clipped opcode
opShortComment	EQU 		$A0 					; short comment opcode
opLongComment	EQU 		$A1 					; long comment opcode
opEndPic		EQU 		$FF 					; end of picture opcode
ngHeaderOp		EQU 		$0C00					; NuGraf Header opcode
;-----------------------------------------------
;
; COLOR QUICKDRAW EQUATES
;

rbMask			EQU 		$1FFF					; mask top 3 bits of rowbytes
pmFlag			EQU 		$8000					; flag to say it's a new pixMap
cPortFlag		EQU 		$C000					; isPixMap+isCPort
pixVersion		EQU 		$0000					; isPixMap
isPixMap		EQU 		15						; for testing high bit of pRowbytes
isCPort 		EQU 		14						; indicates that "bitmap" belongs to port


;for Mac+ Only - 2-way comm cmd

rDSync			EQU 		0						; sync up w/each other

; command byte from nub to MPS

rDSysErr		EQU 		1						; system error
rDTrapCall		EQU 		2						; trap call
rDDta			EQU 		3						; data comin' down the road 

; command byte from MPS to nub

rDGetN			EQU 		1						; GetNBytes
rDSetN			EQU 		2						; SetNBytes
rDCallProc		EQU 		3						; CallProc
rDSetAtrap		EQU 		4						; SetATrap
rDResume		EQU 		5						; Resume execution

; end Mac+ only


FlEvtMask		EQU 		$25E					; (word) mask of allowable events to flush at FlushEvents.
TrapAgain		EQU 		$B00					; use 4 bytes here for another trap
PWMBuf1 		EQU 		$B0A					; (long) PWM buffer ptr
BootMask		EQU 		$B0E					; (word) needed during boot 
AtalkHk1		EQU 		$B14					; (long) Appletalk hook
AtalkHk2		EQU 		$B18					; (long) Appletalk hook
UnSwitchedFlags   EQU		$B20					; (byte) special flags, not switched by multifinder <3.3>
usRelTaskRun	EQU 		7						;		 bit 7=1 if Reliability Mgr mtbf task NOT installed <3.3>
SwitchedFlags	EQU 		$B21					; (byte) special flags, switched by multifinder
SCSIFlag		EQU 		$B22					; (word) Configuration Flag for SCSI
HWCfgFlags		EQU 		SCSIFlag				; (word) HW Configuration flags 
; bit 15 - SCSI port present
; bit 14 - New Clock Chip Present
; bit 13 - Extra Parameter Ram Valid at boottime.

BtDskRfn		EQU 		$B34					; (word) refnum for boot drive driver refnum
BootTmp8		EQU 		$B36					; (8bytes) temp space needed by StartBoot
T1Arbitrate 	EQU 		$B3F					; (byte) $FF if Timer T1 up for grabs.
RMGRHiVars		EQU 		$B80					; $B80-$BFF are switched vars
; RMGR vars extend $B80 through $B9F

NewUnused		EQU 		$BC0					; (word) - used to be FlEvtMask
FmtDefaults 	EQU 		52+$36A 				; ptr to formatting defs (TFSVars + 52) [long]

; addresses of TE hooks installed in trap table

TETrimMeasure	EQU 		(4*253+OSTable) 		; trimMeasure hook
TEFindWord		EQU 		(4*254+OSTable) 		; findWord hook
TEFindLine		EQU 		(4*255+OSTable) 		; findLine hook
JBlockMove		EQU 		$4B8					; Special equate for OUR HeapGuts Jump Table
JInsTime		EQU 		(600-512)*4+OSTable 	;
JRmvTime		EQU 		(601-512)*4+OSTable 	;
JPrimeTime		EQU 		(602-512)*4+OSTable 	;
JADBop			EQU 		($7C*4)+OSTable 		; OS trap table entry for _ADBop
JIOPMsgRequest	EQU 		($87*4)+OSTable 		; OS trap table entry for _IOPMsgRequest
JLg2Phys		EQU 		(703-512)*4+OSTable 	;
JFlushCache 	EQU 		(704-512)*4+OSTable 	;
JGetBlock		EQU 		(705-512)*4+OSTable 	;
JMarkBlock		EQU 		(706-512)*4+OSTable 	;
JRelBlock		EQU 		(707-512)*4+OSTable 	;
JTrashBlocks	EQU 		(708-512)*4+OSTable 	;
JTrashVBlks 	EQU 		(709-512)*4+OSTable 	;
JCacheWrIP		EQU 		(710-512)*4+OSTable 	;
JCacheRdIP		EQU 		(711-512)*4+OSTable 	;


JBasicIO		EQU 		(712-512)*4+OSTable 	;
JRdBlocks		EQU 		(713-512)*4+OSTable 	;
JWrBlocks		EQU 		(714-512)*4+OSTable 	;
JSetUpTags		EQU 		(715-512)*4+OSTable 	;
JBTClose		EQU 		(716-512)*4+OSTable 	;
JBTDelete		EQU 		(717-512)*4+OSTable 	;
JBTFlush		EQU 		(718-512)*4+OSTable 	;
JBTGetRecord	EQU 		(719-512)*4+OSTable 	;
JBTInsert		EQU 		(720-512)*4+OSTable 	;
JBTOpen 		EQU 		(721-512)*4+OSTable 	;
JBTSearch		EQU 		(722-512)*4+OSTable 	;
JBTUpdate		EQU 		(723-512)*4+OSTable 	;
JGetNode		EQU 		(724-512)*4+OSTable 	;
JRelNode		EQU 		(725-512)*4+OSTable 	;
JAllocNode		EQU 		(726-512)*4+OSTable 	;
JFreeNode		EQU 		(727-512)*4+OSTable 	;
JExtBTFile		EQU 		(728-512)*4+OSTable 	;
JDeallocFile	EQU 		(729-512)*4+OSTable 	;
JExtendFile 	EQU 		(730-512)*4+OSTable 	;
JTruncateFile	EQU 		(731-512)*4+OSTable 	;
JCMSetUp		EQU 		(732-512)*4+OSTable 	;
JDtrmV1 		EQU 		(734-512)*4+OSTable 	;
JBlkAlloc		EQU 		(735-512)*4+OSTable 	;
JBlkDeAlloc 	EQU 		(736-512)*4+OSTable 	;
JFileOpen		EQU 		(737-512)*4+OSTable 	;
JPermssnChk 	EQU 		(738-512)*4+OSTable 	;
JFndFilName 	EQU 		(739-512)*4+OSTable 	;
JRfNCall		EQU 		(740-512)*4+OSTable 	;
JAdjEOF 		EQU 		(741-512)*4+OSTable 	;
JFileClose		EQU 		(745-512)*4+OSTable 	; $7a4 <dnf v2.6>
JFileRead		EQU 		(746-512)*4+OSTable 	; $7a8 <dnf v2.6>
JFileWrite		EQU 		(747-512)*4+OSTable 	; $7ac <dnf v2.6>


JClkNoMem		EQU 		(595-512)*4+OSTable 	;vector for clock


JSegStack		EQU 		(760-512)*4+OSTable 	;vector for segment loader

; vectors for RMGR low levels routines
JSuperLoad		EQU 		(761-512)*4+OSTable 	;
JCmpFrm 		EQU 		(762-512)*4+OSTable 	;
JNewMap 		EQU 		(763-512)*4+OSTable 	;
JCheckLoad		EQU 		(764-512)*4+OSTable 	;
JRMgrStdEntry	EQU 		($A6*4)+OSTable 		;vector for standard entry routine
JRMgrStdExit	EQU 		($A7*4)+OSTable 		;vector for standard exit routine


;_______________________________________________________________________
;
; heap flags

checking		EQU 		0						;check arguments and data structures
statistics		EQU 		0						;gather statistics on usage 
robust			EQU 		0						;enables super-robust internal checks
countMPs		EQU 		0						;enables counting of master pointers
dfltFlags		EQU 		0						;Checking is on when zone is init'd 
nOSTable		EQU 		$0400					; 256 longs, up to $800
JMtCheck		EQU 		($AF)*4+nOSTable		; ($A0AF) $0400 is n/OSTable
JCheckReMount	EQU 		($B0)*4+nOSTable		; ($A0B0) $0400 is n/OSTable
JDtrmV2 		EQU 		($B1)*4+nOSTable		; ($A0B1) $0400 is n/OSTable
JFindDrive		EQU 		($B2)*4+nOSTable		; ($A0B2) $0400 is n/OSTable
JFClose 		EQU 		($B3)*4+nOSTable		; ($A0B3) $0400 is n/OSTable
JFlushMDB		EQU 		($B4)*4+nOSTable		; ($A0B4) $0400 is n/OSTable
JGoDriver		EQU 		($B5)*4+nOSTable		; ($A0B5) $0400 is n/OSTable
JWaitUntil		EQU 		($B6)*4+nOSTable		; ($A0B6) $0400 is n/OSTable
JSyncWait		EQU 		($B7)*4+nOSTable		; ($A0B7) $0400 is n/OSTable
JSoundDead		EQU 		($B8)*4+nOSTable		; ($A0B8) $0400 is n/OSTable
JDisptch		EQU 		($B9)*4+nOSTable		; ($A0B9) $0400 is n/OSTable
;JStartinit EQU ($B9)*4+nOSTable ; ($A0B9) $0400 is n/OSTable <C681><C811>
JIAZInit		EQU 		($BA)*4+nOSTable		; ($A0BA) $0400 is n/OSTable
JIAZPostInit	EQU 		($BB)*4+nOSTable		; ($A0BB) $0400 is n/OSTable
JLaunchInit 	EQU 		($BC)*4+nOSTable		; ($A0BC) $0400 is n/OSTable
JCacheFlush 	EQU 		($BD)*4+nOSTable		; ($A0BD) $0400 is n/OSTable
JStripAddress	EQU 		($55)*4+nOSTable		; ($A055) $0400 is n/OSTable  <v1.7>
JjSwapMMU		EQU 		($5D)*4+nOSTable		; ($A05D) $0400 is n/OSTable  <v2.1>
JTranslate24to32  EQU		($91)*4+nOSTable		; ($A091) $0400 is n/OSTable  <v3.4>

;_______________________________________________________________________
;
; addresses of TE hooks installed in trap table for new color text edit <C144>

JPixel2Char 	EQU 		(742-512)*4+nOSTable	; ($A0E6) $0400 is nOSTable 
JChar2Pixel 	EQU 		(743-512)*4+nOSTable	; ($A0E7) $0400 is nOSTable 
JHiliteText 	EQU 		(744-512)*4+nOSTable	; ($A0E8) $0400 is nOSTable 

;_______________________________________________________________________
;
; tfs vectors <A281>
JUpdAltMDB		EQU 		($ED)*4+nOSTable		; ($A0ED) $0400 is n/OSTable
JCkExtFS		EQU 		($EE)*4+nOSTable		; ($A0EE) $0400 is n/OSTable
JDTrmV3 		EQU 		($EF)*4+nOSTable		; ($A0EF) $0400 is n/OSTable
JBMChk			EQU 		($F0)*4+nOSTable		; ($A0F0) $0400 is n/OSTable
JTstMod 		EQU 		($F1)*4+nOSTable		; ($A0F1) $0400 is n/OSTable
JLocCRec		EQU 		($F2)*4+nOSTable		; ($A0F2) $0400 is n/OSTable
JTreeSearch 	EQU 		($F3)*4+nOSTable		; ($A0F3) $0400 is n/OSTable
JMapFBlock		EQU 		($F4)*4+nOSTable		; ($A0F4) $0400 is n/OSTable
JXFSearch		EQU 		($F5)*4+nOSTable		; ($A0F5) $0400 is n/OSTable
JReadBM 		EQU 		($F6)*4+nOSTable		; ($A0F6) $0400 is n/OSTable

; other equs

talkCmd 		EQU 		$0C 					; Command for Talk R0
listenCmd		EQU 		$08 					; Command for Listen R0 
kbdAddr 		EQU 		$02 					; keyboard type device
mouseAddr		EQU 		$03 					; mouse type device 
numFDBAdr		EQU 		$10 					; number of avaiblae FDB address
bcMask			EQU 		$00FFFFFF				; Mask for the 24 bit Byte Count
GrafBegin		EQU 		$800					; graf global area
GrafEnd 		EQU 		$8F2					; end of graphics globals

;Font Manager

; additional private low memory globals

SaveFondFlags	EQU 		$986					;important byte from current FOND flags
FondState		EQU 		$903					;saved FOND purge state

; additional private low memory globals for nuMac’s and later <C346>

SynListHandle	EQU 		$0D32					;a handle to a list of synthesized fonts
LastFore		EQU 		$0D36					;8 bytes: last foreground and background colors (FM)
LastMode		EQU 		$0D3E					;word: last text mode (Font Manager)
LastDepth		EQU 		$0D40					;word: last depth font prepared for
FMExist 		EQU 		$0D42					;byte: clear if InitFonts has already been called
SavedHilite 	EQU 		$0D43					;byte: used for state across Mac II QD patches


;------------------
; fields within patXMap

patXRow 		EQU 		$00 					; [word] rowbytes of expanded pattern
patXHMask		EQU 		$02 					; [word] horizontal mask
patXVMask		EQU 		$04 					; [word] vertical mask
LastCTable		EQU 		$06 					; [long] seed value for last color table
LastOfst		EQU 		$0A 					; [word] last global-local offset
LastInvert		EQU 		$0C 					; [long] last invert value
LastAlign		EQU 		$10 					; [long] last horizontal align
LastStretch 	EQU 		$14 					; [word] last stretch
ppXInfo 		EQU 		$16 					; size of expanded data

; Offsets into boot blocks

bbID			EQU 		0						; (word) offset to boot blocks ID
bbEntry 		EQU 		2						; (contains BRA.S) entrypoint to boot blocks
bbVersion		EQU 		6						; (word) version number
bbPageFlags 	EQU 		8						; (word) page 2 usage flags
bbSysName		EQU 		$0A 					; system resource code file name (byte length + 0-15 chars)
bbShellName 	EQU 		$1A 					; system shell file name ('Finder')
bbDbg1Name		EQU 		$2A 					; debugger file name (first load)
bbDbg2Name		EQU 		$3A 					; debugger file name (second load)
bbScreenName	EQU 		$4A 					; boot screen file name
bbHelloName 	EQU 		$5A 					; startup program file name
bbScrapName 	EQU 		$6A 					; system scrap file name
bbCntFCBs		EQU 		$7A 					; (word) # of FCBs to allocate (determines max open files)
bbCntEvts		EQU 		$7C 					; (word) # of event queue elements to allocate
bb128KSHeap 	EQU 		$7E 					; size of system heap on a 128K Mac (no longer used)
bb256KSHeap 	EQU 		$82 					; size of system heap on a 256K Mac (no longer used)
bb512KSHeap 	EQU 		$86 					; size of system heap on a 512K Mac
bbSysHeapSize	EQU 		$86 					; (long) absolute size of the system heap (for all machines).
; (word) unused - reserved
bbSysHeapExtra	EQU 		$8C 					; (long) minimum additional system heap space required.
bbSysHeapFract	EQU 		$90 					; (long) fraction of memory available to be used for sys heap.


; The version number of the boot blocks affects the interpretation of the system heap size:
;
; if (BBVersion) <= BBOldVers then
; System heap size becomes DefSysHeapSize (see HWEqu).
;
; if BBOldVers < (BBVersion) < BBNewVers then
; if (BBVersion) = execBBvers then
; Executes boot blocks starting at BBEntry.
; System heap size becomes (BBSysHeapSize) (if it isn't already bigger).
;
; if BBNewBit is set in (BBVersion) then
; if BBExecBit is set then
; Executes boot blocks starting at BBEntry.
; if BBRelBit is cleared then
; System heap size becomes (BBSysHeapSize) (if it isn't already bigger)
; if BBRelBit is set then
; System heap is extended by BBSysHeapExtra + (BBSysHeapFract * (MemTop))

; Values for boot blocks.
bbOldVers		EQU 		$14 					; really old versions of boot blocks are <= this
bbOldExecVers	EQU 		'D' 					; old version for executable boot blocks

; Bits for new boot blocks:
bbNewBit		EQU 		7						; set to indicate the use of the new format
bbExecBit		EQU 		6						; set to indicate dispatchable boot blocks
bbRelBit		EQU 		5						; set to indicate relative heap size specification
; bits 4 through 0 are reserved for future use by Apple and must be cleared.

; Corresponding values
bbNewMask		EQU 		$80 					; new boot blocks use #'s >= this
bbExecMask		EQU 		$40 					;
bbRelMask		EQU 		$20 					;

; inverse Table structure (shouldn't be a public structure, but is obvious) 
iTabSeed		EQU 		$0						;[long] ID of owning color table
iTabRes 		EQU 		$4						;[word] client ID
iTTable 		EQU 		$6						;table of indices starts here
iTabHidden		EQU 		$00 					;number of hidden entries (0 for balanced table)
iTabReserved	EQU 		$02 					;space for a handle or pointer to other info
iTabInfo		EQU 		$06
iTExtraSize 	EQU 		$106					;1 byte per color at the moment
;-----------------------------------------------------
;
; EQUATES FOR COLOR CURSOR SAVE AREA
;
; NOTE THAT THE FIRST FOUR FIELDS ARE PARALLEL TO THE FIRST FOUR FIELDS
; OF A PATTERN SO THAT PATCONVERT CAN BE USED TO EXPAND A CURSOR
;
ccType			EQU 		0						;[WORD] CURSOR TYPE
ccMap			EQU 		ccType+2				;[LONG] HANDLE TO CURSOR'S PIXMAP
ccData			EQU 		ccMap+4 				;[LONG] HANDLE TO CURSOR'S COLOR DATA
ccXData 		EQU 		ccData+4				;[LONG] HANDLE TO EXPANDED DATA
ccXMask 		EQU 		ccXData+4				;[LONG] HANDLE TO EXPANDED MASK
ccSave			EQU 		ccXMask+4				;[LONG] HANDLE TO SAVE BITS UNDER CURSOR
ccLastCrsr		EQU 		ccSave+4				;[32 BYTES] DATA FOR LAST B/W CURSOR DRAWN
ccID			EQU 		ccLastCrsr+32			;[LONG] ID FOR LAST COLOR CURSOR DRAWN
ccDepth 		EQU 		ccID+4					;[WORD] DEPTH FOR LAST CURSOR DRAWN
ccStateRegs 	EQU 		ccDepth+2				;[16 BYTES] STATE INFO OF SAVED DATA
ccBytes 		EQU 		ccStateRegs+16			;[WORD] ROWBYTES OF EXPANDED DATA
ccMaxDepth		EQU 		ccBytes+2				;[WORD] MAXIMUM SCREEN DEPTH
ccSaveRec		EQU 		ccMaxDepth+2			;SIZE OF CURSOR SAVE AREA
;----------------------------------------------
;
; Trap table equates used by QuickDraw:
;
JStdTbTbl		EQU 		$0E00
JStdArc 		EQU 		JStdTbTbl+(4*$BD)
JStdBits		EQU 		JStdTbTbl+(4*$EB)
JStdComment 	EQU 		JStdTbTbl+(4*$F1)
JStdGetPic		EQU 		JStdTbTbl+(4*$EE)
JStdLine		EQU 		JStdTbTbl+(4*$90)
JStdOval		EQU 		JStdTbTbl+(4*$B6)
JStdPoly		EQU 		JStdTbTbl+(4*$C5)
JStdPutPic		EQU 		JStdTbTbl+(4*$F0)
JStdRect		EQU 		JStdTbTbl+(4*$A0)
JStdRgn 		EQU 		JStdTbTbl+(4*$D1)
JStdRRect		EQU 		JStdTbTbl+(4*$AF)
JStdText		EQU 		JStdTbTbl+(4*$82)
JStdTxMeas		EQU 		JStdTbTbl+(4*$ED)
JStdOpcode		EQU 		JStdTbTbl+(4*$3F8)
				MACRO
				_StackAvail
				MOVE.L		$400+4*$65,A0			;get address of stack space routine
				JSR 		(A0)					;get stack space into D0 and return
				ENDM
				MACRO
				_GetScreenBits						; it's in crsrcore!!
				DC.W		($A833) 				;new trap number
				ENDM
; Power Manager Data Structures


pmCommand		EQU 		0						; Power manager parameter block
pmLength		EQU 		pmCommand+2 			;Power manager parameter block
pmSBuffer		EQU 		pmLength+2				;Power manager parameter block
pmRBuffer		EQU 		pmSBuffer+4 			;Power manager parameter block
contrast		EQU 		$40 					;Power Manager parameter block - Screen contrast control
modemRead		EQU 		$58 					;Power Manager parameter block - Internal modem setup
batteryRead 	EQU 		$68 					;Power Manager parameter block - Battery/charger level and status
; equates for dynamic menuList structure
;
;----- Part 1 -- regular menus
mbResID 		EQU 		4						; menuBar variant offset in menuList [word]
menu1Size		EQU 		mbResID + 2 			; Must be = 6 forever!!!

;----- Part 2 -- hierarchical menus
lastHMenu		EQU 		0						; offset in HMenu part of dynamic menuList [word]
menuTitleSave	EQU 		lastHMenu + 2			; handle to saved bits behind title rectangle [handle]
menu2Size		EQU 		menuTitleSave+4 		; size of HMenu entry
menuHoH 		EQU 		0						; hierarchical menu [handle]

;----- Size of menuList at InitMenus time -- no menus, no hierarchical menus
initMListSize	EQU 		menu1Size + menu2Size
; equates for mbarproc's save structure created when it receives Init Msg (Msg #3)
;
;----- Header
lastMBSave		EQU 		0						; offset to last menu saved in structure [word]
mbCustomStorage   EQU		lastMBSave + 2			; private storage for custom mbarproc's [handle]
mbItemRect		EQU 		mbCustomStorage + 4 	; rect of currently chosen menu item [rect]
mbMenuDelay 	EQU 		mbItemRect + 8			; get MenuDelay from paramram and store here [byte]
mbMenuDrag		EQU 		mbMenuDelay + 1 		; get MenuDrag from paramram and store here [byte]
mbUglyScroll	EQU 		mbMenuDrag + 1			; flag to tell whether HMenu has been brought [word]
; before scrolling happens
mbIconState 	EQU 		mbUglyScroll + 2		; Place to save NMgr icon state
mbHeader		EQU 		mbIconState + 2 		; size of mb save header [$14]
; !!!!! CAUTION: mbHeader MUST be smaller than mbEntrySize !!!!!

;----- Entry
mbRectSave		EQU 		0						; rectangle of menu on screen [8 bytes]
mbBitsSave		EQU 		mbRectSave + 8			; handle to saved bits behind menu rectangle
mbMenuDir		EQU 		mbBitsSave + 4			; direction menu was placed on screen,
; to right or left of title (if first menu) 
; or previous menu (if hierarchical menu)
mbMLOffset		EQU 		mbMenuDir + 2			; 6 byte offset of menu in menuList [word]
mbMLHandle		EQU 		mbMLOffset + 2			; handle of menu in menuList
mbTopScroll 	EQU 		mbMLHandle + 4			; top scrolled to menu item, from global topMenuItem [word]
mbBotScroll 	EQU 		mbTopScroll + 2 		; bottom scrolled to menu item, from global atMenuBottom [word]
mbReserved		EQU 		mbBotScroll + 2 		; reserved field [long]
mbEntrySize 	EQU 		mbReserved + 4
mbSaveSize		EQU 		mbEntrySize*6			; x-byte header and 5 entries of x-bytes each
firstAltMenuCmd   EQU		$1B
altMenuCmd1 	EQU 		$1D 					; itemCmd == $1D ==> unused indicator reserved for future Apple use
altMenuCmd2 	EQU 		$1E 					; itemCmd == $1E ==> unused indicator reserved for future Apple use
altMenuCmd3 	EQU 		$1F 					; itemCmd == $1F ==> unused indicator reserved for future Apple use
lastAltMenuCmd	EQU 		$1F
mbRightDir		EQU 		0						; menu went to the right (direction)
mbLeftDir		EQU 		1						; menu went to the left (direction)
menuDelay		EQU 		$7E 					; param ram locations for user settable
menuDrag		EQU 		$7F 					; hierarchical menu delay and drag ticks

				MACRO
				_GetWaitFlags
				MOVEA.W 	#2,A0
				_InternalWait
				ENDM

				MACRO
				_SetWaitFlags
				MOVEA.W 	#3,A0
				_InternalWait
				ENDM

				MACRO
				_DisableDynWait
				MOVEA.W 	#4,A0
				_InternalWait
				ENDM

				MACRO
				_EnableDynWait
				MOVEA.W 	#5,A0
				_InternalWait
				ENDM

				MACRO
				_DisablePermWait
				MOVEA.W 	#6,A0
				_InternalWait
				ENDM

				MACRO
				_EnablePermWait
				MOVEA.W 	#7,A0
				_InternalWait
				ENDM

; _AssumeEq Arg1, Arg2 -- macro to generate a compile-time error if two <01Oct85>
; arguments are unequal. <01Oct85>

				MACRO
				_AssumeEq
				IF			&EVAL(&SysList[1]) <> &EVAL(&SysList[2]) THEN
				ERR 								; Invalid statement - will cause error
				ENDIF
				ENDM


; sleep queue commands
SleepRequest	EQU 		1						; sleep request
SleepDemand 	EQU 		2						; Sleep Demand
SleepWakeUp 	EQU 		3						; wake up

; Sleep Queue Flags - SleepqFlags
NoCalls 		EQU 		1						; no need to call
NoRequest		EQU 		2						; no need to send sleep request


				ENDIF								;end exclusion of private information

;-------------------------------------------------------------------
;
; Time Manager Local Variable Struct
;

TTInt			EQU 		0						; time of this interrupt cycle [long]
TTAppoint		EQU 		4						; pointer to next appointment in MSQueue [long]
MSQueue 		EQU 		8						; queue header for MS Queue [10 bytes]
MSLSize 		EQU 		18						; size of these variables for allocation purposes
TimeVars		EQU 		$0						; the low memory pointer to the variable struct
msLink			EQU 		0						; Link to next element [pointer]
msType			EQU 		4						; Unique ID for validity [word]
msAddr			EQU 		6						; service routine [pointer]
msCount 		EQU 		10						; timeout count [word]
msQSize 		EQU 		14
